<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>操作系统背背佳</title>
      <link href="/2022/10/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%83%8C%E8%83%8C%E4%BD%B3/"/>
      <url>/2022/10/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%83%8C%E8%83%8C%E4%BD%B3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-什么是复杂指令集？什么是精简指令集？80x86采用的是哪种？"><a href="#1-什么是复杂指令集？什么是精简指令集？80x86采用的是哪种？" class="headerlink" title="1. 什么是复杂指令集？什么是精简指令集？80x86采用的是哪种？"></a>1. 什么是复杂指令集？什么是精简指令集？80x86采用的是哪种？</h2><p>复杂指令集（CISC，Complex Instruction Set Computing）架构的处理器有两大特点，一是可变指令长度，二是单一指令的功能比较复杂（完整）。因此可以不需要太多指令就能完成一个程序，减少了取指令时间。处理器的运作流程是：1. 读入指令 2. 将指令解码 3. 依据解码的结果执行动作。如此循环下去。其中解码将指令分解成一个个基本的处理器动作。由于指令长度不一，因此每个指令的解码后得到的动作个数不一，这样会使得指令执行的时间难以估计，很难进行流水作业。后来的统计研究发现，一个程序中大部分往往只用到了一少部分的指令集。后来就有了精简指令集（RISC）的出现。</p><p>精简指令集（RISC，Reduced Instruction Set Computing）的特点：1. 统一采用单周期指令，指令周期数长短统一。2. 采用高效的流水线操作，让指令在流水线中实现并行处理，大幅度提高CPU处理效率。3. 精简执行机摒弃了复杂指令集中的微程序，因为微程序的使用会增加复杂性和每条指令的执行周期。4. 简化和标准化了指令的格式，这能提高流水线效率。5. 尽量减少了寻址方式，这能简化硬件逻辑部件的设计，并且缩短译码时间。6. 采用面向寄存器堆的指令。7. 采用装入、存储指令结构，至访问存储器，其他的所有数据都要从内存中暂时读到寄存器中，不需要访问内存。</p><p>80x86采用的是复杂指令集。</p><h2 id="2-什么是小端存储？什么是大端存储？80x86采用的是哪种？"><a href="#2-什么是小端存储？什么是大端存储？80x86采用的是哪种？" class="headerlink" title="2. 什么是小端存储？什么是大端存储？80x86采用的是哪种？"></a>2. 什么是小端存储？什么是大端存储？80x86采用的是哪种？</h2><p>小端存储：较高的有效字节放在较高的存储器地址，较低的有效字节放在较低的存储器地址。</p><p>大端存储：较高的有效字节放在较低的存储器地址，较低的有效字节放在较高的存储器地址。</p><p>80x86系列仍然在使用小段存储（1234存储时低地址是34，高地址是12）的方式。</p><h2 id="3-8086有哪5类寄存器？请分别举例说明其作用。"><a href="#3-8086有哪5类寄存器？请分别举例说明其作用。" class="headerlink" title="3. 8086有哪5类寄存器？请分别举例说明其作用。"></a>3. 8086有哪5类寄存器？请分别举例说明其作用。</h2><p>数据寄存器、指针寄存器、变址寄存器、控制寄存器、段寄存器</p><p>前三个合成通用寄存器</p><h3 id="（一）通用寄存器"><a href="#（一）通用寄存器" class="headerlink" title="（一）通用寄存器"></a>（一）通用寄存器</h3><h4 id="（1）数据寄存器"><a href="#（1）数据寄存器" class="headerlink" title="（1）数据寄存器"></a>（1）数据寄存器</h4><p>AX(accumulator)：累加寄存器，常用于运算；在乘除等指令中指定用来存放操作数，另外，所有的I&#x2F;O指令都使用这一寄存器与外接设备传送数据。</p><p>BX(base)：基址寄存器，常用于地址索引。</p><p>CX(count)：计数寄存器，常用于计数；常用于保存计算值，如在移位指令时，循环和串处理指令中用作隐含的计数器。</p><p>DX(data)：数据寄存器，常用于数据传递。</p><h4 id="（2）指针寄存器"><a href="#（2）指针寄存器" class="headerlink" title="（2）指针寄存器"></a>（2）指针寄存器</h4><p>SP（Stack Pointer）：堆栈指针寄存器，与SS配合使用，可指向目前的堆栈位置。</p><p>BP（Base Pointer）：基址指针寄存器，可用作SS的一个相对基址位置</p><h4 id="（3）变址寄存器"><a href="#（3）变址寄存器" class="headerlink" title="（3）变址寄存器"></a>（3）变址寄存器</h4><p>SI（Source Index）：源变址寄存器，可用来存放相对于DS段之源变址指针</p><p>DI（Destination Index）：目的变址寄存器，可用来存放相对于ES段之目的变址指针。</p><h3 id="（二）控制寄存器"><a href="#（二）控制寄存器" class="headerlink" title="（二）控制寄存器"></a>（二）控制寄存器</h3><p><strong>1. 指令指针寄存器 IP：</strong>指令指针 IP 是一个 16 位专用寄存器，它指向当前需要取出的</p><p>指令字节，当 BIU 从内存中取出一个指令字节后，IP 就自动加(取出该字节的长度，</p><p>如:BIU 从内存中取出的是 1 个字节，IP 就会自动加 1，如果 BIU 从内存中取出的字</p><p>节数长度为 3，IP 就自动加 3)，指向下一个指令字节。注意，IP 指向的是指令地址</p><p>的段内地址偏移量，又称偏移地址(Offset Address)或有效地址(EA，Effective</p><p>Address)。</p><p><strong>2. 状态标志寄存器 FLAG：</strong>80x86 有一个 16 位的标志性寄存器 FR，在 FR 中有意义的有</p><p>9 位，其中 6 位是状态位，3 位是控制位。标志寄存器(Flags Register,FR)又称程</p><p>序状态字(Program Status Word,PSW)。这是一个存放条件标志、控制标志寄存器，</p><p>主要用于反映处理器的状态和运算结果的某些特征及控制指令的执行。</p><h3 id="（三）段寄存器"><a href="#（三）段寄存器" class="headerlink" title="（三）段寄存器"></a>（三）段寄存器</h3><p>为了运用所有的内存空间，8086 设定了四个段寄存器，专门用来保存段地址.</p><ol><li>CS(Code Segment):代码段寄存器</li><li>DS(Data Segment):数据段寄存器</li><li>SS(Stack Segment):堆栈段寄存器</li><li>ES(Extra Segment):附加段寄存器。</li></ol><h2 id="4-有哪些段寄存器？它们的作用是什么？"><a href="#4-有哪些段寄存器？它们的作用是什么？" class="headerlink" title="4. 有哪些段寄存器？它们的作用是什么？"></a>4. 有哪些段寄存器？它们的作用是什么？</h2><ol><li>CS(Code Segment):代码段寄存器</li><li>DS(Data Segment):数据段寄存器</li><li>SS(Stack Segment):堆栈段寄存器</li><li>ES(Extra Segment):附加段寄存器。</li></ol><h2 id="5-什么是寻址？8086有哪些寻址方式？"><a href="#5-什么是寻址？8086有哪些寻址方式？" class="headerlink" title="5. 什么是寻址？8086有哪些寻址方式？"></a>5. 什么是寻址？8086有哪些寻址方式？</h2><p>找到操作数的地址（从而能够取出操作数）叫做<strong>寻址</strong></p><p><strong>立即寻址</strong> </p><p>MOV AX 1234H #给出了操作数，事实上没有“寻址”</p><p><strong>直接寻址</strong> </p><p>MOV AX [1234H] #直接给出了地址 1234H,用[]符号取数</p><h2 id="6-什么是直接寻址？直接寻址的缺点是什么？"><a href="#6-什么是直接寻址？直接寻址的缺点是什么？" class="headerlink" title="6. 什么是直接寻址？直接寻址的缺点是什么？"></a>6. 什么是直接寻址？直接寻址的缺点是什么？</h2><p>立即寻址，寄存器寻址，直接寻址，寄存器间接寻址，寄存器相对寻址，基址变址寻址，相对基址变址寻址。</p><h3 id="1）立即寻址"><a href="#1）立即寻址" class="headerlink" title="1）立即寻址"></a>1）立即寻址</h3><p>立即寻址方式所提供的操作数紧跟在操作码后面，与操作码一起放在指令代码段中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1234h</span><br></pre></td></tr></table></figure><h3 id="2）寄存器寻址"><a href="#2）寄存器寻址" class="headerlink" title="2）寄存器寻址"></a>2）寄存器寻址</h3><p>寄存器寻址的特点是操作数在CPU内部的寄存器中，在指令中指定寄存器号。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov al,dh</span><br></pre></td></tr></table></figure><h3 id="3）直接寻址"><a href="#3）直接寻址" class="headerlink" title="3）直接寻址"></a>3）直接寻址</h3><p>直接寻址的操作数在存储器中，指令直接包含有操作数的有效地址。由于操作数一般存放在数据段，所以操作数的地址由DS加上指令中给出的16位偏移得到。（当然，除了DS寄存器以外，还可以指定其他段寄存器）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[1234h]</span><br><span class="line">mov ax,DS:[1234h]</span><br><span class="line">mov ES:[5678h],bl</span><br></pre></td></tr></table></figure><h3 id="4）寄存器间接寻址"><a href="#4）寄存器间接寻址" class="headerlink" title="4）寄存器间接寻址"></a>4）寄存器间接寻址</h3><p>寄存器间接寻址的操作数在存储器中，操作数有效地址在SI、DI、BX、BP这四个寄存器之一中。在一般情况下，如果有效地址在SI、DI和BX中，则以DS段寄存器中的内容为段值，如果有效地址在BP中，则以SS段寄存器的内容为段值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOV AX, [SI] ; 自动引用DS作为段寄存器</span><br><span class="line">MOV DL, CS:[BX]  ;引用的段寄存器是CS</span><br><span class="line">MOV [BP], CX  ;此时引用的段寄存器是SS</span><br></pre></td></tr></table></figure><h3 id="5）寄存器相对寻址"><a href="#5）寄存器相对寻址" class="headerlink" title="5）寄存器相对寻址"></a>5）寄存器相对寻址</h3><p>操作数在存储器中，操作数的有效地址是一个基址寄存器（BX、BP）或变址寄存器（SI、DI）内容加上指令中给定的8位或16位位移量之和。</p><p>即 EA &#x3D; (BX)或(BP)或(SI)或(DI) + 8位或16位位移量。</p><p>在一般情况下，如果SI、DI或BX的内容作为有效地址的一部分，那么引用的段寄存器是DS。如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV AX, [DI+1223H] ; 引用的段寄存器是DS</span><br></pre></td></tr></table></figure><p>假设，（DS）&#x3D; 5000H，（DI）&#x3D; 3678H。</p><p>那么，存取的物理存储单元地址是5489BH。再假设该字存储单元的内容是55AAH，那么在执行该指令后，（AX）&#x3D; 55AAH。</p><p>而当BP的内容作为有效地址一部分时，那么引用的段寄存器是SS，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV BX, [BP-4]  ; 引用的段寄存器是SS</span><br></pre></td></tr></table></figure><p>当然也可以自行指定段寄存器，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV ES:[BX+5], AL ; 引用ES作为段寄存器</span><br></pre></td></tr></table></figure><p>这种寻址方式同样可用于表格处理，表格的首地址可设置为指令中的位移量，利用修改基址或变址寄存器的内容来存取表格中的项值。</p><p>以下两种写法等价：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOV AX, [SI+3]</span><br><span class="line"></span><br><span class="line">MOV AX, 3[SI]</span><br></pre></td></tr></table></figure><h3 id="6）基址变址寻址方式"><a href="#6）基址变址寻址方式" class="headerlink" title="6）基址变址寻址方式"></a>6）基址变址寻址方式</h3><p>操作数在存储器中，操作数的有效地址由基址寄存器之一的内容与变址寄存器之一的内容相加得到。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">即：EA = (BX)或(BP) + (SI)或(DI)</span><br></pre></td></tr></table></figure><p>在一般情况下，如果BP的内容作为有效地址的一部分，则以SS的内容作为段值，否则以DS的内容作为段值。</p><p>当所得的有效地址超过FFFFFH时，就取其64K的模。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如： MOV AX, [BX+DI] ; 此时引用DS段寄存器</span><br></pre></td></tr></table></figure><p>假设，（DS）&#x3D; 5000H，（BX）&#x3D; 1223H， （DI）&#x3D; 54H</p><p>那么，存取的物理存储单元地址是51277H。再假设改字存储单元的内容是168H，那么在执行该指令后，（AX）&#x3D; 168H</p><p>当然，还可以增加段超越前缀来指定段寄存器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line"></span><br><span class="line">MOV AX, ES:[BX+SI]  ; 引用ES作为段寄存器</span><br><span class="line">MOV DS:[BP+SI], AL  ; 引用DS作为段寄存器</span><br></pre></td></tr></table></figure><p>这种寻址方式适用于数组或表格处理。用基址寄存器存放数组首地址，而用变址寄存器来定位数组中的各元素，或反之。</p><p>另外，以下两种表示方法是等价的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOV AX, [BX+DI]</span><br><span class="line"></span><br><span class="line">MOV AX, [DI][BX]</span><br></pre></td></tr></table></figure><h3 id="7）相对基址变址寻址方式"><a href="#7）相对基址变址寻址方式" class="headerlink" title="7）相对基址变址寻址方式"></a>7）相对基址变址寻址方式</h3><p>操作数在存储器中，操作数的有效地址由基址寄存器之一的内容与变址寄存器之一的内容及指令中给定的8位或16位位位移量相加得到。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">即：EA = (BX)或(BP) + (SI)或(DI) + 8位或16位位移量</span><br></pre></td></tr></table></figure><p>在一般情况下，如果BP作为有效地址的一部分，则以SS段寄存器的内容为段值，否则以DS段寄存器的内容为段值。</p><p>在指令中给定的8位或16位位移量采用补码形式表示。在计算有效地址时，如果偏移量是8位，那么被带符号扩展成16位。当所得的有效地址超过FFFFH时，就取其64K的模。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">举例：MOV AX, [BX+DI-2] ; 自动引用DS作为段寄存器</span><br></pre></td></tr></table></figure><p>假设，（DS）&#x3D; 5000H，（BX）&#x3D; 1223H, （DI）&#x3D; 54H<br>那么，存取的物理存储单元地址是51275H。再设该字存储单元的内容是7654H，那么在执行该指令后，（AX）&#x3D; 7654H</p><p>以下四种表示方法均是等价的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MOV AX, [BX+DI+1234H]</span><br><span class="line"></span><br><span class="line">MOV AX, 1234H[BX+DI]</span><br><span class="line"></span><br><span class="line">MOV AX, 1234H[BX][DI]</span><br><span class="line"></span><br><span class="line">MOV AX, 1234H[DI][BX]</span><br></pre></td></tr></table></figure><h2 id="7-主程序与子程序之间如何传递参数？你的实验代码中在哪里体现的？"><a href="#7-主程序与子程序之间如何传递参数？你的实验代码中在哪里体现的？" class="headerlink" title="7. 主程序与子程序之间如何传递参数？你的实验代码中在哪里体现的？"></a>7. 主程序与子程序之间如何传递参数？你的实验代码中在哪里体现的？</h2><p><strong>（一）利用寄存器传递参数</strong> </p><p>利用寄存器传递参数就是把参数放在约定的寄存器中，这种方法的优点是实行简</p><p>单和调用方便，但是由于寄存器的个数有限，并且寄存器往往还需要存放其他数据因此</p><p>只适合传递参数比较少的情况</p><p><strong>（二）利用约定的存储单元传递参数</strong> </p><p>在传递参数较多的情况下，可以利用约定的内存变量来传递参数，这种方法的优点</p><p>是子程序要处理的数据或送出的结果都有独立的存储单元，编写程序的时候不容易出</p><p>错但是，这种方法要占用一定的存储单元并且通用性较差</p><p><strong>（三）利用堆栈传递参数</strong> </p><p>如果使用堆栈传递入口参数，那么主程序在调用子程序之前，把需要传递的参数依</p><p>次压入堆栈，子程序从堆栈中取入口参数，如果使用堆栈传递出口参数，那么子程序在</p><p>返回前，把需要返回的参数存入堆栈，主程序在堆栈中取出口参数即可利用堆栈传递参数可以不用占用寄存器，也无需额外使用存储单元，由于参数和子</p><p>程序的返回地址混在一起，有时还要考虑保护寄存器，所以比较复杂，通常利用堆栈传</p><p>递参数的入口参数，而利用寄存器传递出口参数</p><p><strong>（四）利用 CALL 后续区传递参数</strong> </p><p>CALL 后续区是指位于 CALL 指令后的存储区，主程序在调用子程序之前，把入口参</p><p>数存入 CALL 指令后面的存储区，子程序根据保存在堆栈中的返回地址找到入口参数，</p><p>这种传递参数的方法称为 CALL 后续传递参数法，由于这种方法把数据和代码混在一起，</p><p>在 x86 系列中使用的不多</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>20221015</title>
      <link href="/2022/10/16/20221015/"/>
      <url>/2022/10/16/20221015/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p> 开了个巨长的会<img src="/img/ava.jpg"></p><p>去半步颠小聚</p><p><img src="/img/banbudian.jpg"></p><p>回宿舍后，刘巨赶去了快递站，拿来了姜小姐给他寄的东西（实名羡慕）</p><p><img src="/img/pinganxile.jpg"></p><p>还和学妹撸了猫猫！</p><p><img src="/img/maw.jpg"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue中的一些说明及注意事项</title>
      <link href="/2022/06/29/Vue%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AF%B4%E6%98%8E%E5%8F%8A%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
      <url>/2022/06/29/Vue%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AF%B4%E6%98%8E%E5%8F%8A%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="Vue中-click-native-prevent说明"><a href="#Vue中-click-native-prevent说明" class="headerlink" title="Vue中@click.native.prevent说明"></a>Vue中@click.native.prevent说明</h2><p>元素中绑定了这个事件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-button :loading=&quot;loading&quot; type=&quot;primary&quot; style=&quot;width:100%;margin-bottom:30px;&quot; @click.native.prevent=&quot;handleLogin&quot;&gt;登录&lt;/el-button&gt;</span><br></pre></td></tr></table></figure><p>1、在封装好的组件上使用，所以要加上.native才能click。<br>2、prevent是用来阻止默认的事件。就相当于…event.preventDefault()，父组件想在子组件上监听自己的click的话，需要加上native修饰符。</p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue生命周期</title>
      <link href="/2022/06/29/Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/2022/06/29/Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Vue生命周期中mounted和created的区别"><a href="#Vue生命周期中mounted和created的区别" class="headerlink" title="Vue生命周期中mounted和created的区别"></a>Vue生命周期中mounted和created的区别</h1><h2 id="一、什么是生命周期？"><a href="#一、什么是生命周期？" class="headerlink" title="一、什么是生命周期？"></a>一、什么是生命周期？</h2><p>用通俗的语言来说，就是Vue中实例或者组件从创建到消灭中间经过的一系列过程。</p><h2 id="二、created和mounted的区别？"><a href="#二、created和mounted的区别？" class="headerlink" title="二、created和mounted的区别？"></a>二、created和mounted的区别？</h2><p>官方图解如下：</p><p><img src="https://img-blog.csdn.net/20170919221428421?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGRubG92ZW1l/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center"></p><p>从图中我们看两个节点：</p><p>created：在模板渲染成html前调用，即通常是初始化某些属性值，然后再渲染成视图。</p><p>mounted：在模板渲染成html后调用，通常是初始化页面完成后，再对html的dom节点进行一些需要的操作。</p><p>其实两者比较好理解，通常created使用的次数多，而mounted通常是在一些插件的使用或者组件的使用中进行操作，比如插件chart.js的使用：var ctx &#x3D; document.getElementById(ID)；通常会有这一步，而如果你写入组件中，你会发现在created中无法对chart进行一些初始化配置，一定要等这个html渲染完后才可以进行，那么mounted就是不二之选。下面看一个例子（用组件）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;span style=<span class="string">&quot;font-size:14px;&quot;</span>&gt;<span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&quot;demo1&quot;</span>,&#123;  </span><br><span class="line">        <span class="attr">data</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;  </span><br><span class="line">            <span class="keyword">return</span> &#123;  </span><br><span class="line">                <span class="attr">name</span>:<span class="string">&quot;&quot;</span>,  </span><br><span class="line">                <span class="attr">age</span>:<span class="string">&quot;&quot;</span>,  </span><br><span class="line">                <span class="attr">city</span>:<span class="string">&quot;&quot;</span>  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;,  </span><br><span class="line">        <span class="attr">template</span>:<span class="string">&quot;&lt;ul&gt;&lt;li id=&#x27;name&#x27;&gt;&#123;&#123;name&#125;&#125;&lt;/li&gt;&lt;li&gt;&#123;&#123;age&#125;&#125;&lt;/li&gt;&lt;li&gt;&#123;&#123;city&#125;&#125;&lt;/li&gt;&lt;/ul&gt;&quot;</span>,  </span><br><span class="line">        <span class="attr">created</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;  </span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">name</span>=<span class="string">&quot;唐浩益&quot;</span>  </span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">age</span> = <span class="string">&quot;12&quot;</span>  </span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">city</span> =<span class="string">&quot;杭州&quot;</span>  </span><br><span class="line">            <span class="keyword">var</span> x = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;name&quot;</span>)<span class="comment">//第一个命令台错误  </span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(x.<span class="property">innerHTML</span>);  </span><br><span class="line">        &#125;,  </span><br><span class="line">        <span class="attr">mounted</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;  </span><br><span class="line">            <span class="keyword">var</span> x = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;name&quot;</span>)/&lt;<span class="regexp">/span&gt;/</span>第二个命令台输出的结果&lt;span style=<span class="string">&quot;font-size:14px;&quot;</span>&gt;  </span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(x.<span class="property">innerHTML</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;);  </span><br><span class="line">    <span class="keyword">var</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;  </span><br><span class="line">        <span class="attr">el</span>:<span class="string">&quot;#example1&quot;</span>  </span><br><span class="line">    &#125;)&lt;/span&gt;  </span><br></pre></td></tr></table></figure><p>可以看到输出如下：</p><ul><li>唐浩益</li><li>12</li><li>杭州</li></ul><p>可以看到都在created赋予初值的情况下成功渲染出来了。</p><p>然是同时看console台如下：</p><p><img src="https://img-blog.csdn.net/20170919222905341?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGRubG92ZW1l/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center"></p><p>可以看到第一个报了错，实际是因为找不到id，getElementById(ID)没有找到元素。原因如下：</p><p><b>在created的时候，视图中的html并没有渲染出来。所以此时如果直接去操作html的dom节点，一定找不到相关的元素。而在mounted中，由于此时html已经渲染出来了，所以可以直接操作dom节点，故输出了结果“唐浩益”。</b></p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA VO/PO/POJO等等的区别</title>
      <link href="/2022/06/28/JAVA-VO-PO-POJO%E7%AD%89%E7%AD%89%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2022/06/28/JAVA-VO-PO-POJO%E7%AD%89%E7%AD%89%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="entity、bo、vo、po、dto、pojo的区别"><a href="#entity、bo、vo、po、dto、pojo的区别" class="headerlink" title="entity、bo、vo、po、dto、pojo的区别"></a>entity、bo、vo、po、dto、pojo的区别</h1><h2 id="Entity"><a href="#Entity" class="headerlink" title="Entity"></a>Entity</h2><p>最常用的实体类，基本和数据表一一对应，一个实体一张表。</p><h2 id="BO（business-object）"><a href="#BO（business-object）" class="headerlink" title="BO（business object）"></a>BO（business object）</h2><p>业务对象主要作用是把业务逻辑封装为一个对象。这个对象可以包括一个或多个其它的对象。</p><p>比如一个简历，有教育经历、工作经历、社会关系等等。我们可以把教育经历对应一个PO，工作经历对应一个PO，社会关系对应一个PO。</p><p>建立一个对应简历的BO对象处理简历，每个BO包含这些PO。</p><p>这样处理业务逻辑时，我们就可以针对BO去处理。</p><p>封装业务逻辑为一个对象（可以包括多个PO，通常需要将BO转化成PO，才能进行数据的持久化，反之，从DB中得到的PO，需要转化成BO才能在业务层使用）。</p><p>关于BO主要有三种概念</p><p>1 、只包含业务对象的属性；</p><p>2 、只包含业务方法；</p><p>3 、两者都包含。</p><p>在实际使用中，认为哪一种概念正确并不重要，关键是实际应用中适合自己项目的需要。</p><h2 id="VO（value-object值对象-x2F-view-object表现层对象）"><a href="#VO（value-object值对象-x2F-view-object表现层对象）" class="headerlink" title="VO（value object值对象&#x2F;view object表现层对象）"></a>VO（value object值对象&#x2F;view object表现层对象）</h2><p>1 ．主要对应页面显示（web页面&#x2F;swt、swing界面）的数据对象。</p><p>2 ．可以和表对应，也可以不，这根据业务的需要。</p><h2 id="PO（persistent-object"><a href="#PO（persistent-object" class="headerlink" title="PO（persistent object)"></a>PO（persistent object)</h2><ol><li>有时也被称为Data对象，对应数据库中的entity，可以简单认为一个PO对应数据库中的一条记录。</li><li>在<a href="https://so.csdn.net/so/search?q=hibernate&spm=1001.2101.3001.7020">hibernate</a>持久化框架中与insert&#x2F;delet操作密切相关。</li><li>PO中不应该包含任何对数据库的操作。</li></ol><h2 id="DTO（data-transfer-object"><a href="#DTO（data-transfer-object" class="headerlink" title="DTO（data transfer object)"></a>DTO（data transfer object)</h2><p>1 ．用在需要跨进程或远程传输时，它不应该包含业务逻辑。</p><p>2 ．比如一张表有100个字段，那么对应的PO就有100个属性（大多数情况下，DTO内的数据来自多个表）。但view层只需显示10个字段，没有必要把整个PO对象传递到client，这时我们就可以用只有这10个属性的DTO来传输数据到client，这样也不会暴露server端表结构。到达客户端以后，如果用这个对象来对应界面显示，那此时它的身份就转为VO。</p><h2 id="POJO（plain-ordinary-java-object）"><a href="#POJO（plain-ordinary-java-object）" class="headerlink" title="POJO（plain ordinary java object）"></a>POJO（plain ordinary java object）</h2><p>代表简单无规则java对象。</p><p>一个中间对象，可以转化为PO、DTO、VO。</p><p>1 ．POJO持久化之后&#x3D;&#x3D;〉PO</p><p>（在运行期，由Hibernate中的cglib动态把POJO转换为PO，PO相对于POJO会增加一些用来管理数据库entity状态的属性和方法。PO对于programmer来说完全透明，由于是运行期生成PO，所以可以支持增量编译，增量调试。）</p><p>2 ．POJO传输过程中&#x3D;&#x3D;〉DTO</p><p>3 ．POJO用作表示层&#x3D;&#x3D;〉VO</p><p>PO 和VO都应该属于它</p><h2 id="DAO（data-access-object）"><a href="#DAO（data-access-object）" class="headerlink" title="DAO（data access object）"></a>DAO（data access object）</h2><p>1 ．主要用来封装对DB的访问（CRUD操作）。</p><p>2 ．通过接收Business层的数据，把POJO持久化为PO。</p><h2 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h2><p>代表控制层，主要是Action&#x2F;Servlet等构成（Spring MVC则是通过@Controller标签使用）。此层是业务层与视图层打交道的中间层，负责传输VO对象和调用BO层的业务方法，负责视图层请求的数据处理后响应给视图层。</p><h2 id="View"><a href="#View" class="headerlink" title="View"></a>View</h2><p>代表视图层的意思，主要是指由JSP、HTML等文件形成的显示层。</p><p>所以实际项目中，一般都是这样应用的：</p><p>控制层（controller-action），业务层&#x2F;服务层（bo-manager-service），实体层（po-entity),dao(dao)，视图对象（vo-），视图层（view-jsp&#x2F;html）</p><p><img src="https://img-blog.csdn.net/20180717104224284?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE4NzA1NDc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 后端开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内联函数的特点及注意事项</title>
      <link href="/2022/06/18/%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E7%9A%84%E7%89%B9%E7%82%B9%E5%8F%8A%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
      <url>/2022/06/18/%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E7%9A%84%E7%89%B9%E7%82%B9%E5%8F%8A%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>如果代码中有一些函数频繁地被调用，那么会不断地函数参数入栈、出栈，造成代码时间上的浪费。为了解决这个问题，特别引入了inline修饰符，表示内联函数。</p><p>内联函数就和带参数宏类似，都是使用函数体直接替换调用出地代码，所以不需要参数入栈和出栈，节约了时间。</p><p>但是需要注意地是，内联函数只适合函数功能简单，操作少，被调用多的情况下，这样才能对代码效率进行提升。当内联函数中，函数体功能复杂，需要循环、嵌套等大量操作，那么当内联函数体在编译时替换调用处的代码，会占据大量的内存，而且变异的时间也有可能会大大增加，造成的影响远远大于不使用内联函数。</p><p>内联函数与带参数宏定义的区别：</p><ol><li><p>宏调用并不执行类型检查（任意类型皆可），但是函数调用却要检查</p></li><li><p>宏替换发生在预处理阶段，函数发生在编译阶段</p></li><li><p>宏是简单的文本替换，会出现意想不到的错误，而函数不会。如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MUL(x, y) x * y</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">mul</span><span class="params">(<span class="type">int</span> x , <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>, c = <span class="number">3</span>, d = <span class="number">4</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;mul(a, b) = &quot;</span> &lt;&lt; <span class="built_in">mul</span>(a+b, c+d) &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;MUL(a, b) = &quot;</span> &lt;&lt; <span class="built_in">MUL</span>(a+b, c+d) &lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：内联函数add的结果是正确的，但是宏ADD是错误的，那么为什么是11呢？只要展开就明白了；调用点展开：<code>cout &lt;&lt; &quot;ADD(a, b) = &quot; &lt;&lt; 1+2*3+4 &lt;&lt;endl;</code>那么结果肯定是11啊，所以对于经验不是特别丰富的程序员使用带参数宏，很容易出现错误！</p><p>那么有经验的该怎么写呢？<code>#define ADD(x, y) ((x) * (y))</code>，这样，就不会出错了！</p></li></ol><p>内联函数的定义一般直接写在头文件中，因为内联函数在编译时是直接将函数体替换调用点的代码，所以如果内联函数定义在某xx.cc中，声明是定义在头文件中，那么当调用内联函数的时候，在编译阶段调用该内联函数的代码替换成函数体，那么就不会再有该内联函数的函数名了，链接器自然无法解析。</p><p>当然你如果非要将内联函数声明写在头文件，定义在xx.cc中，然后还想在aa.cc中调用在xx.cc中的内联函数，那么需要在头文件中加上<code>#include &quot;xx.cc&quot;</code>，这种写法多此一举，不建议这样操作！</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++里面的重写带有默认参数的虚函数的问题</title>
      <link href="/2022/06/18/C++%E9%87%8C%E9%9D%A2%E7%9A%84%E9%87%8D%E5%86%99%E5%B8%A6%E6%9C%89%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2022/06/18/C++%E9%87%8C%E9%9D%A2%E7%9A%84%E9%87%8D%E5%86%99%E5%B8%A6%E6%9C%89%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>在C++里面虚函数是实现多态的主要方式。而虚函数的实现是在运行时通过查找虚函数里面的函数指针来实现对于不同的子类的虚函数的调用。注意到这里虚函数的调用是<b>运行时</b>的。</p><p>而默认参数则是C++方便程序员在定义函数的时候当一些默认情况下，给定默认值的一种方式。主义到默认参数的传递是在编译器由编译期确定的。也就是说如果有下面的函数定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">hello</span><span class="params">(string&amp; s = <span class="string">&quot;hello, world!&quot;</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在调用<code>hello()</code>的时候，会传递默认的<code>&quot;hello,world!&quot;</code>给<code>hello()</code>。</p><p>那么，如果类里面的虚函数定义了默认参数，情况又是怎么样呢？</p><p>试想这样一种情况，定义一个基类Base，定义函数虚函数ShowMessage(int i &#x3D; 1)，而<a href="https://so.csdn.net/so/search?q=%E5%AD%90%E7%B1%BB&spm=1001.2101.3001.7020">子类</a>Derived继承于Base，重写了ShowMessage(int i &#x3D; 2)。也就是如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">ShowMessage</span><span class="params">(<span class="type">int</span> i = <span class="number">1</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Base::ShowMessage</span><span class="params">( <span class="type">int</span> i <span class="comment">/*= 1*/</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base: &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">ShowMessage</span><span class="params">(<span class="type">int</span> i = <span class="number">2</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Derived::ShowMessage</span><span class="params">( <span class="type">int</span> i )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Derived: &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么运行下面的程序的结果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Base *a = <span class="keyword">new</span> Derived;</span><br><span class="line">Derived b;</span><br><span class="line"> </span><br><span class="line">a-&gt;<span class="built_in">ShowMessage</span>(); <span class="comment">// output: Derived: 1</span></span><br><span class="line">b.<span class="built_in">ShowMessage</span>();  <span class="comment">// output: Derived: 2</span></span><br></pre></td></tr></table></figure><p>第2行的结果应该是和语气中一样的，但是第一行为什么是1不是2呢？</p><p>原因就在于<b>默认参数的确定是在编译期完成的</b>，而在编译过程中，编译器并不知道a指向的实际上是Base还是Derived，所以它就把a当成是Base，而Base的ShowMessage的默认参数是1，传给第一个参数的值是1。而到了程序运行时，由于多态性，ShowMessage调用的是Derived的ShowMessage，只不过参数是1而已。</p><p>由于这个原因，在重写带有默认参数的虚函数的时候，一定要和原来的参数一样，不然会造成很多问题。</p><p>那么，如果我们在Derived中定义的ShowMessage不带有默认参数呢？如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">ShowMessage</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>而主程序调用b.ShowMessage()。</p><p>结果是程序在b.ShowMessage()处出现编译错误。原因是当虚函数带有默认参数的时候，如果想要重写的话，则参数表里面的默认参数的位置必须是对应的。如果基类中的虚函数是带有默认参数，而子类的没有，则虽然类型是一样的，编译器是认为这两个函数是不一样的。那么<b>子类中的函数就是代替了基类中的函数</b>。具体可以看《C++ Primer》的P593。</p><p>如果想要通过上面的编译，需要在Derived的定义中加入using Base::ShowMessage;这句话。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>近代史纲要</title>
      <link href="/2022/06/16/%E8%BF%91%E4%BB%A3%E5%8F%B2%E7%BA%B2%E8%A6%81/"/>
      <url>/2022/06/16/%E8%BF%91%E4%BB%A3%E5%8F%B2%E7%BA%B2%E8%A6%81/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>[TOC]</p><h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><h3 id="列强的入侵战争及签订条约"><a href="#列强的入侵战争及签订条约" class="headerlink" title="列强的入侵战争及签订条约"></a>列强的入侵战争及签订条约</h3><ol><li><p>1840-1842年，第一次鸦片战争，签订南京条约。</p><p>南京条约内容：（1）割让香港岛；（2）赔偿英国二千一百万银元；（3）五口通商，开放广州、福建、厦门、宁波、上海为通商口岸，允许英国人居住并设派领事；（4）协定关税；（5）允许英国商人在华自由贸易等</p><p>影响：破坏了中国的领土完整和关税主权，中国开始沦为半殖民地半封建社会。</p></li><li><p>1856-1860年，第二次鸦片战争，签订天津条约和北京条约。</p><p>天津条约内容：（1）公使常驻北京；（2）开放牛庄、登州、台湾、淡水、潮州、琼州、汉口、九江、南京、镇江为通商口岸；（3）传教人士自由传教；（4）对英国赔款400万两，对法国赔款200万两。</p><p>北京条约内容：（1）承认天津条约有效；（2）开放天津为商埠；（3）割让九龙司地方一区给英国；（4）允许英法招募华工出国；（5）对英法的赔款各增至800万两</p><p>影响：1. 丧失的领土和主权增多，英国割让九龙司地方一区，沙俄占中国100多万平方公里；外国公使进驻北京的规定，更为外国侵略者直接控制清政府准备了条件。2. 外国侵略势力的深入及扩展，第二次鸦片战争之后，中国又增开了天津在内的11处通商口岸，使外国侵略势力从东南沿海扩展到整个沿海，从沿海深入到内地。3. 中国的半殖民地半封建程度进一步加深。</p></li><li><p>1894年，中日甲午战争，签订马关条约</p><p>马关条约内容：（1）割让辽东半岛、台湾岛以及其附属各岛屿、澎湖列岛给日本；（2）赔偿日本军费白银两亿两；（3）开放沙市、重庆、苏州、杭州为商埠；（4）允许日本在中国的通商口岸投资办厂。</p><p>影响：（1）台湾等大片领土的割让，进一步破坏了中国主权的完整，刺激列强瓜分中国的野心，民族危机进一步加深；（2）巨额赔款加重了中国人民的负担，同时加速了日本军国主义的发展。清政府因此大借外债，使列强控制了中国的经济命脉；（3）通商口岸的开放，使帝国主义侵略势力深入到中国内地。允许在华投资办厂，严重阻碍了民族资本主义的发展；（4）中国半殖民地半封建程度大大加深。</p></li><li><p>1900年，八国联军侵华战争，签订辛丑条约</p><p>辛丑条约内容：（1）对各国赔款4.5亿两，价息合计超过9.8亿两白银，并以关税和盐税作为抵押；（2）划定北京东交民巷为使馆界，允许各国驻兵保护，不允许中国人在界内居住；（3）拆毁天津大沽口到北京沿线设防的炮台，允许各国驻兵北京到山海关铁路沿线要地；（4）清政府保证严禁人民参加反帝运动；（5）改总理各国事务衙门为外务部，班列六部之前等</p><p>影响：辛丑条约的签订，进一步加强了帝国主义对中国的全面控制和掠夺，表明清政府已经完全沦为帝国主义统治中国的工具，标志着中国已经完全沦为半殖民地半封建社会。</p></li></ol><h3 id="早期的维新思想"><a href="#早期的维新思想" class="headerlink" title="早期的维新思想"></a>早期的维新思想</h3><ol><li>林则徐是近代中国睁眼看世界的第一人，进行查禁鸦片和抗英斗争，编成《四洲志》，讲述世界地理。</li><li>魏源在1843年编成《海国图志》，提出“师夷长技以制夷”的思想，主张学习外国先进的军事和科学技术，以期富国强兵，抵御外国侵略。</li><li>严复翻译《天演论》，用“物竞天择”“适者生存”的社会进化论思想，为救亡图存提供了理论根据。</li><li>19 世纪 70 年代以后，郑观应等人不仅主张学习西方的科学技术，同时也要求吸纳西方的政治、经济学说。如郑观应在所著《盛世危言》中提出大力发展民族工商业，同西方国家进行“商战”，设立议院，实行“君民共主”制度等主张。这些主张具有重要的思想启蒙的意义。</li><li>孙中山1894年成立兴中会，喊出“振兴中华”的口号。</li></ol><h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><h3 id="太平天国运动失败的原因"><a href="#太平天国运动失败的原因" class="headerlink" title="太平天国运动失败的原因"></a>太平天国运动失败的原因</h3><ol><li>农民阶级不是新的生产力和生产关系的代表，无法克服小生产者所固有的阶级局限性，缺乏科学思想理论的指导，没有先进阶级的领导，因而无法从根本上提出完整的、正确的政治纲领和社会改革方案。</li><li>太平天国无法制止和克服领导集团腐败现象的滋生。</li><li>太平天国军事战略上出现了重大失误。</li><li>太平天国是以宗教来发动、组织群众的，但是，拜上帝教不仅不能正确指导斗争，而且给农民带来了危害。</li><li>太平天国未能正确对待儒学。</li><li>太平天国不能把西方国家的侵略者和人民群众区别开来，对西方资本主义侵略者缺乏理性的认识。</li></ol><h3 id="洋务运动起到的历史作用"><a href="#洋务运动起到的历史作用" class="headerlink" title="洋务运动起到的历史作用"></a>洋务运动起到的历史作用</h3><p>洋务派提出“自强”“求富”的主张，通过所掌握的国家权力集中力量优先发展军事工业，同时也试图“稍分洋商之利”，发展若干民用企业，在客观上对中国早期工业和民族资本主义的发展起了某些促进作用。但是，洋务派兴办洋务新政，主要是为了维护封建统治，并不是要使中国朝着独立的资本主义方向发展。</p><p>洋务运动时期，为了培养通晓洋务的人才，开办了一批新式学堂，派出了最早的官派留学生，这是中国近代教育的开始。与此同时，还翻译了一批近代自然科学书籍，给当时的中国带来了新的知识，使人们开阔了眼界。</p><p>洋务运动时期，伴随着资本主义生产方式的出现，传统的“重本抑末”等观念收到冲击，社会风气和价值观念开始变化，工商业者的地位上升。对一部分人来说，西方的各种技术和器物不再被当作“奇技淫巧”受到排斥，而是被视为模仿、学习的对象。这一切，都有利于资本主义经济的发展，也有利于社会风气的改变。</p><h3 id="戊戌变法的内容"><a href="#戊戌变法的内容" class="headerlink" title="戊戌变法的内容"></a>戊戌变法的内容</h3><p>政治方面：改革行政机构，裁撤闲散、重叠机构；裁汰冗员，澄清吏治，提倡倡廉；提倡向皇帝上书言事；准许旗人自谋生计，取消国家供养的特权。</p><p>经济方面：保护、奖励工农商业和交通采矿业，中央设立农工商总局与铁路矿物总局，各省设立商务局；提倡开办实业，奖励发明创造；注重农学发展，提倡西法耕植，建立新式农场；广办邮政，修筑铁路；开办商学、商报，设立商会等各类组织；改革财政，编制国家预决算。</p><p>军事方面：裁剪旧式绿营兵，改练新式陆军；采用西洋兵制，练洋操，习洋枪等。</p><p>文化教育方面：创设京师大学堂，各省书院改为高等学堂，在各地设立中、小学堂；提倡西学，废除八股，改试策论，开经济特科；设立译书局，翻译国外书籍，派人出国留学；奖励新著，奖励创办报刊，允许自由组织学会。</p><h2 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h2><h3 id="清末革命与改良的辩论"><a href="#清末革命与改良的辩论" class="headerlink" title="清末革命与改良的辩论"></a>清末革命与改良的辩论</h3><p>1905至1907年，围绕中国究竟是采用革命手段还是改良方式这个问题，革命派与改良派分别以《民报》《新民丛报》为主要舆论阵地，展开了一场大论战。</p><ol><li><p>要不要以革命手段推翻清王朝</p><p>改良派认为，革命会引起下层社会暴乱，招致外国干涉、瓜分，使中国“血流成河”“亡国灭种”，所以要爱国就不能革命，只能改良、立宪。</p><p>革命派针锋相对地之处，清政府是帝国主义的“鹰犬”，因此爱国必须革命。只有通过革命，才能“免瓜分之祸”，获得民族独立和社会进步。</p><p>革命牌还进一步驳斥了改良派认为因革命要“杀人流血”“破坏一切”而不可革命地说法。他们指出：</p><p>第一，进行革命，固然会有牺牲，但是，不进行革命，而容忍清王朝在中国的统治，中国人民将长期地遭受痛苦和做出更大的牺牲。</p><p>第二，人们在革命过程中所付出的努力，乃至作出的牺牲，是以换取历史的进步作为补偿的。</p></li><li><p>要不要推翻帝制，实行共和</p><p>改良派认为，中国“国民恶劣”“智力低下”，没有实行民主共和政治的能力。如果实行，非亡国不可。因此，实行君主立宪才是中国政治的现实出路。</p><p>革命派指出，不是“国民恶劣“，而是”政府恶劣“。民主共和是大势所趋，人心所向。拯救中国与建设中国都必须取法乎上，直接推行民主制度，而不能以国民素质低劣为借口，搞君主立宪甚或开明专制。只有”兴民权改民主“，才是中国的唯一出路。中国国民自有颠覆专制制度、建立民主共和的能力。</p></li><li><p>要不要进行社会革命</p><p>改良派反对土地国有，反对平均地权。他们认为，中国社会经济组织优良，土地问题不是中国最重要的问题，不存在社会革命的可能。社会革命只会导致中国的大动乱。他们还攻击主张平均地权是煽动乞丐流氓，主张土地国有是危害国本，并表示在这个问题上”宁死不让“。</p><p>革命派强调，当时的中国存在着严重的”地主强权“”地权失平“的现象。必须通过平均地权以实现土地国有，在进行政治革命的同时实现社会革命，才能避免贫富不均等社会问题的出现。</p></li></ol><p>这场论战划清了革命与改良的界限，传播了民主革命思想，促进了革命形势的发展。但这场论战也暴露了革命派在思想理论方面的弱点。</p><h3 id="反清革命团体（同盟会）"><a href="#反清革命团体（同盟会）" class="headerlink" title="反清革命团体（同盟会）"></a>反清革命团体（同盟会）</h3><h4 id="同盟会的成立"><a href="#同盟会的成立" class="headerlink" title="同盟会的成立"></a>同盟会的成立</h4><p>1905 年 8 月 20 日，孙中山等人以兴中会和华兴会为基础，在日本东京成立中国同盟会，孙中山被公举为总理。同盟会以《民报》为机关报，并确定了革命纲领。这是近代中国第一个领导资产阶级革命的全国性政党，它的成立标志着中国资产阶级民主革命进入了一个新的阶段。</p><p>同盟会的政治纲领是“驱除鞑虏，恢复中华，创立民国，平均地权”。孙中山其概括为三大主义，即民族主义、民权主义、民生主义，后被称为三民主义。</p><p>但是，同盟会纲领中的民族主义没有从正面鲜明地提出反对帝国主义的主张。当时的革命派对于帝国主义的本质认识不清，害怕帝国主义干涉，甚至幻想以承认不平等条约“继续有效”为条件来换取列强对自己的支持。同时，他们也没有明确地把汉族军阀、官僚、地主作为革命对象，从而给了这部分人后来从内部和外部破坏革命以可乘之机。</p><h4 id="同盟会领导的武装斗争"><a href="#同盟会领导的武装斗争" class="headerlink" title="同盟会领导的武装斗争"></a>同盟会领导的武装斗争</h4><p>孙中山领导的同盟会不仅提出了革命纲领，而且从事实际的革命活动，产生了广泛的影响。其中影响最大的是 1911年 4 月 27 日举行的广州起义。是日，黄兴率敢死队 120 余人在广州举行起义，大部在激战中牺牲。其中 72 位烈士的遗骸被葬于黄花岗，故是役史称“黄花岗起义”。</p><p>1911 年 5 月，清政府宣布“铁路干线收归国有”，借“国有”名义把铁路利权岀卖给帝国主义，同时借此“劫夺”商股。这激起了湖北、湖南、广东、四川四省的保路风潮，其中以四川为最烈。立宪派本来主张把保路运动限制在“文明争路”的范围之内，但署理四川总督赵尔丰竟下令军警向手无寸铁的请愿群众开枪，造成“成都血案”。广大群众忍无可忍，在同盟会成员的参与下，掀起了全川的武装暴动，史称保路运动。</p><h3 id="辛亥革命的历史意义"><a href="#辛亥革命的历史意义" class="headerlink" title="辛亥革命的历史意义"></a>辛亥革命的历史意义</h3><p>辛亥革命是资产阶级领导的以反对封建君主专制制度、建立资产阶级共和国为目的的革命，是一次比较完全意义上的资产阶级民主革命。</p><p>第一，辛亥革命推翻了封建势力的政治代表、帝国主义在中国的代理人清王朝的统治，沉重打击了中外反动势力，使中国反动统治者在政治上乱了阵脚。在这以后，帝国主义和封建势力在中国再也不能建立起比较稳定的统治，从而为中国人民斗争的发展开辟了道路。</p><p>第二，辛亥革命结束了中国延续两千多年的封建君主专制制度，建立了中国历史上第一个资产阶级共和政府，使民主共和的观念开始深入人心，并在中国形成了”敢有帝制自为者，天下共击之“的民主主义观念。</p><p>第三，辛亥革命推动了中国人民的思想解放，激发了人民的爱国热情和民族觉醒，打开了禁锢思想进步的闸门。</p><p>第四，辛亥革命推动了中国的社会变革，促使中国的社会经济、思想习惯和社会风俗等方面发生了新的积极变化。</p><p>第五，辛亥革命不仅在一定程度上打击了帝国主义的侵略势力，而且推动了亚洲各国民族解放运动的高涨。</p><h3 id="辛亥革命失败的原因"><a href="#辛亥革命失败的原因" class="headerlink" title="辛亥革命失败的原因"></a>辛亥革命失败的原因</h3><ol><li>从根本上来说，是因为在帝国主义时代，在半殖民地半封建的中国，资本主义的建国方案是行不通的，帝国主义绝不允许中国建立一个独立、富强的资产阶级共和国，从而使自己失去剥削、奴役的对象。</li><li>从主观方面来说，在于它的领导者资产阶级革命派本身存在着许多弱点和错误。第一，没有提出彻底的反帝反封建的革命纲领。第二，不能充分发动和依靠人民群众。第三，不能建立坚强的革命政党，作为团结一切的革命力量的强有力的核心。</li></ol><h2 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h2><h3 id="五四运动爆发的原因"><a href="#五四运动爆发的原因" class="headerlink" title="五四运动爆发的原因"></a>五四运动爆发的原因</h3><p>五四运动是在新的时代条件和社会历史条件下发生的。</p><p>首先，是新的社会力量的成长、壮大。第一次世界大战期间，中国的资本主义经济得到迅速发展，中国资产阶级和工人阶级也进一步成长起来，五四运动获得了比以往革命斗争更加广泛的群众基础。</p><p>其次，是新文化运动掀起的思想解放潮流，年轻一代知识界，尤其是初步具有共产主义思想的知识分子，为五四运动准备了最初的群众队伍和骨干力量。</p><p>最后，是俄国十月革命对中国的影响。</p><h3 id="五四运动的过程"><a href="#五四运动的过程" class="headerlink" title="五四运动的过程"></a>五四运动的过程</h3><p>五四运动的直接导火线，是巴黎和会上中国外交的失败。五四运动开始时，英勇地出现在斗争前面的是学生。学生的爱国行动遭到北洋政府的严厉镇压。在此关口，中国工人阶级开始以独立的姿态登上政治舞台。随后，这场反帝爱国运动扩展到了20多个省区，100多个城市。</p><p>这时，五四运动突破了知识分子的狭小围，成为有工人阶级、小资产阶级和民族资产阶级参加的全国规模的革命运动。斗争的主力由学生转向了工人，运动的中心由北京转到了上海。迫于人民群众的压力，中国政府没有出席巴黎和约签字仪式，五四运动的直接斗争目标得以实现。</p><h2 id="五四运动的历史特点和意义"><a href="#五四运动的历史特点和意义" class="headerlink" title="五四运动的历史特点和意义"></a>五四运动的历史特点和意义</h2><p>由于五四运动是在新的社会历史条件下发生的，它具有以辛亥革命为代表的旧民主主义革命所不具备的历史特点，具有伟大意义。</p><p>就特点来看，五四运动是一场以先进青年知识分子为先锋、广大人民群众参与的彻底反帝反封建的伟大爱国革命运动，是一场中国人民为拯救民族危亡、捍卫民族尊严、凝聚民族力量而掀起的伟大社会革命运动，是一场传播新思想新文化新知识的伟大思想启蒙运动和新文化运动，以磅礴之力鼓动了中国人民和中华民族实现民族复兴的志向和信心。</p><p>就意义看，第一，五四运动是中国旧民主主义革命走向新民主主义革命的转折点，具有里程碑意义。它以彻底反帝反封建的革命性、追求救国强国真理的进步性、各族各界群众积极参与的广泛性，推动了中国社会进步，促进了马克思主义在中国的传播，促进了马克思主义同中国工人运动的结合，为中国共产党的成立做了思想上干部上的准备，为新的革命力量、革命文化、革命斗争登上历史舞台创造了条件。第二，五四运动孕育了以爱国、进步、民主、科学为主要内容的伟大五四精神，其核心是爱国主义。第三，五四运动改变了以往只有觉悟的革命者而缺少觉醒的人民大众的斗争状况，实现了中国人民和中华民族自鸦片战争以来的第一次全面觉醒。</p><p>总之，五四运动标志着中国新民主主义革命的开端。</p><h2 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h2><h3 id="长征的起因和经过"><a href="#长征的起因和经过" class="headerlink" title="长征的起因和经过"></a>长征的起因和经过</h3><h4 id="遵义会议"><a href="#遵义会议" class="headerlink" title="遵义会议"></a>遵义会议</h4><p>1934 年 10 月中旬，中共中央和中央红军 8.6 万人撤离根据地，向西突围转移，开始长征。其后，1935 年 3 月、4 月，红四方面军从川陕根据地出发长征。同年 11月，红二、六军团（后组成红二方面军）从湘鄂川黔根据地出发长征。</p><p>1935 年 1 月 15 日至 17 日召开了遵义会议。</p><p>遵义会议批评了博古、李德在第五次反“围剿”中的错误，增选毛泽东为中央政治局常务委员，做出了军事、组织方面的一系列重大决策，是在中国共产党同共产国际的联系中断的情况下，独立自主地作出的。</p><p>遵义会议开始确立以毛泽东为主要代表的马克思主义的正确路线在党中央的领导地位，从而在极其危急的情况下挽救了中国共产党、挽救了中国工农红军、挽救了中国革命，成为中国共产党历史上一个生死攸关的转折点。这为党和革命事业转危为安、不断打开新局面提供了最重要的保证。</p><h4 id="红军长征的胜利"><a href="#红军长征的胜利" class="headerlink" title="红军长征的胜利"></a>红军长征的胜利</h4><p>遵义会议后，在毛泽东等的领导下，中央红军采取灵活机动的战略战术，四渡赤水河，巧渡金沙江，抢渡大渡河，翻越人迹罕至、终年积雪的夹金山，摆脱了数十万国民党军队的围追堵截，赢得了战争的主动权。随后中共中央决定将北上红军改称陕甘支队，先行北上，于 10 月 19 日到达陕北吴起镇；11 月初，同红十五军团会合，中国共产党所领导的革命力量有了新的落脚点和战略基地。至此，中央红军的二万五千里长征胜利结束。1936 年 10 月，红二、四方面军先后同红一方面军会师。至此，三大主力红军的长征胜利结束。</p><h3 id="长征胜利的意义"><a href="#长征胜利的意义" class="headerlink" title="长征胜利的意义"></a>长征胜利的意义</h3><p>长征的胜利，极大地促进了党在政治上和思想上的成熟；</p><p>是中国革命转危为安的关键；</p><p>宣告了国民党反动派消灭中国共产党和红军的图谋彻底失败，宣告了中国共产党和红军胜利实现了北上抗日的战略转移，实现了中国革命事业从挫折走向胜利的伟大转折，开启了中国共产党为实现民族独立、人民解放而斗争的新的伟大进军。</p><p>长征铸就了伟大的长征精神，开启了中国革命的新局面。</p><h2 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h2><h3 id="九一八事变、华北事变、卢沟桥事变"><a href="#九一八事变、华北事变、卢沟桥事变" class="headerlink" title="九一八事变、华北事变、卢沟桥事变"></a>九一八事变、华北事变、卢沟桥事变</h3><p>1931年9月18日深夜，日本关东军炸毁“南满铁路“沈阳的一段路轨，反诬中国军队所为，当即炮轰东北军驻地北大营，接着向沈阳城等地发起进攻，这就是九一八事变。九一八事变是中国抗日战争的起点，标志着中国局部抗战的开始。</p><p>1935年，日本在华北制造一系列争端，中国在河北、察哈尔两省的主权大部丧失，华北成为日军可以自由出入的”真空地带“。接着，日本策动华北五省两市的”防共自治运动“，制造傀儡政权，这就是华北事变。</p><p>1937年7月7日，日军在卢沟桥以北进行军事演习，借口一名士兵失踪，要求进入宛平县城搜查，遭拒绝后开炮轰城，向中国驻军进攻。日本全面侵华战争由此开始。</p><p>由于遭到中国军民的顽强抵抗，日军在 1938 年 10 月占领广州、武汉以后，被迫停止对正面战场的战略性进攻。在坚持灭亡中国的总方针下，日本调整侵华政策，实施“以华制华”和“以战养战”策略，对国民党政府采取政治诱降为主、军事打击为辅的方针；在占领区加紧扶植傀儡政权，建立和发展汉奸组织；逐步将主要兵力用于对共产党领导的敌后抗日根据地进行“扫荡”。1944 年 4 月至 1945 年 1 月，日本发动豫湘桂战役，占领 20 多万平方公里的中国领土。这是日军在中国的最后一次大规模进攻。</p><h3 id="统一战线的形成"><a href="#统一战线的形成" class="headerlink" title="统一战线的形成"></a>统一战线的形成</h3><p>华北事变后，中日民族矛盾进一步激化。在中国共产党救亡图存、全民抗战的号召和地下党组织领导下，1935年12月9日北平学生举行抗日游行，喊出”停止内战，一致对外“的口号。由此开始的一二·九运动迅速波及全国。它促进了中华民族觉醒，标志着中国人民抗日救亡运动新高潮的到来。</p><p>中国共产党提出了建立抗日民族统一战线的政策，发表八一宣言，主张停止内战，组织国防政府和抗日联军。12月瓦窑堡召开政治局扩大会议，提出党的基本策略任务是建立广泛的抗日民族统一战线，批评了左倾主义倾向。</p><p>卢沟桥事变的第二天，中国共产党通电全国，号召全中国同胞团结起来，筑成抗日民族统一战线，建立八路军和新四军。为促进国共两党合作抗日，发表国共合作宣言，标志着以国共两党第二次合作为基础的抗日民族统一战线的正式形成。</p><h3 id="西安事变及其和平解决"><a href="#西安事变及其和平解决" class="headerlink" title="西安事变及其和平解决"></a>西安事变及其和平解决</h3><p>蒋介石“攘外必先安内”的方针并没有根本改变。1936年12月初，他到达西安，逼张学良、杨虎城“剿共”。张、杨在向蒋介石要求抗日遭拒后，于12日凌晨毅然实行“兵谏”，扣留蒋介石，并通电全国，提出停止内战、一致抗日等八项主张。这就是西安事变。</p><p>党中央派周恩来于17日到达西安。在弄清情况后，党中央以中华民族团结抗日大局为重，独立自主确定了用和平方式解决西安事变的方针。周恩来与张、杨共同努力，经过谈判，迫使蒋介石作出“停止剿共，联红抗日”的承诺。西安事变的和平解决成为时局转换的枢纽，十年内战局面基本结束，国内和平初步实现。</p><blockquote><p>为促进国共两党合作，1937年2月，中共中央致电国民党五届三中全会，提出停止内战等五项要求。如果国民党将这五项要求定为国策，共产党愿意实行包括停止武力推翻国民党政府的方针在内的四项保证。上述主张在全国引起巨大反响，也得到国民党内抗日派的赞同。国民党五届三中全会表示同意国共两党进行谈判，并在会议文件上第一次写上了“抗日”字样。</p><p>国共两党实行第二次合作成为不可抗拒的历史潮流。</p></blockquote><h3 id="论持久战的主要内容"><a href="#论持久战的主要内容" class="headerlink" title="论持久战的主要内容"></a>论持久战的主要内容</h3><p>1938年，毛泽东发表《论持久战》，总结全民族抗战10个月以来的经验，批驳了亡国论、速胜论等错误观点，系统的阐明了持久战方针。</p><p>毛泽东指出，中日战争是半殖民地半封建的中国和帝国主义的日本之间在20世纪30年代进行的一个决死的战争。一方面，日本是强国，中国是弱国，弱国强国的对比，决定了抗日战争只能是持久战。另一方面，日本是小国，发动的是退步的、野蛮的侵略战争，在国际上失道寡助；而中国是大国，进行的是进步的、正义的反侵略战争，在国际上得道多助。中国已经有了代表中华民族和中国根本利益的、在政治上成熟的中国共产党以及其领导的抗日根据地和人民军队。因此，最后胜利又将是属于中国的。</p><p>毛泽东强调，”兵民是胜利之本“。战胜日本的侵略，必须进行人民战争。毛泽东科学遇见了抗日战争的发展进程，即抗日战争将经过战略防御、战略相持、战略反攻三阶段。战略相持是最关键阶段，只要坚持持久抗战、坚持抗日民族统一战线，中国将在这个阶段获得转弱为强的力量。</p><p>《论持久战》系统阐明了抗日战争的发展规律和坚持抗战、争取抗战胜利必须实行的战略总方针，是中国共产党领导抗日战争的纲领性文献，对全国抗战的战略指导产生了积极影响。</p><h2 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h2><h3 id="重庆谈判的起源和经过"><a href="#重庆谈判的起源和经过" class="headerlink" title="重庆谈判的起源和经过"></a>重庆谈判的起源和经过</h3><p>1945年8月14日、20日、23日，蒋介石三次电邀毛泽东到重庆“共定大计”。为了争取和平民主，毛泽东不顾个人安危，于8月28日偕周恩来、王若飞赴重庆与国民党当局进行谈判。这一行动，充分体现了中国共产党谋求和平的真诚愿望。10月10日，双方签署《政府与中共代表会谈纪要》，即“双十协定”，确认和平建国的基本方针，同意“长期合作，坚决避免内战”。</p><h3 id="三大战役"><a href="#三大战役" class="headerlink" title="三大战役"></a>三大战役</h3><p>三大战役是辽沈、淮海、平津三大战役。</p><p>辽沈战役自1948年9月12日开始至11月2日结束，历时52天。东北野战军主力70万人在林彪、罗荣桓领导下，共歼敌47.2万人。淮海战役自1948年11月6日开始至1949年1月10日结束，历时66天。华东野战军、中原野战军以及地方武装共60万人，在刘伯承、陈毅、邓小平、粟裕、谭震林组成的总前委（邓小平为书记）领导下，歼敌55.5万人。平津战役自1948年11月29日开始至1949年1月31日结束，历时64天。入关作战的东北野战军、华北解放军主力与地方武装共100万人，在由林彪、罗荣桓、聂荣臻组成的平津前线总前委领导下，歼灭和改编国民党军队52万余人。</p><p>三大战役历时4个月零19天，共歼灭国民党军队有生力量154万余人，加上1948年7月至1949年1月期间在济南战役和其他战役中的损失，国民党军队共丧失兵力230余万人。国民党赖以维持其反动统治的主要军事力量基本上被摧毁。</p><p>三大战役，无论是战争的规模还是取得的成果，在中国战争史上都是空前的，在世界战争史上也是罕见的。这是人民战争的胜利，是毛泽东军事思想的胜利。</p><h2 id="第八章"><a href="#第八章" class="headerlink" title="第八章"></a>第八章</h2><h3 id="论十大关系"><a href="#论十大关系" class="headerlink" title="论十大关系"></a>论十大关系</h3><p>重工业和轻工业、农业的关系；</p><p>沿海工业和内地工业的关系；</p><p>经济建设和国防建设的关系；</p><p>国家、生产单位和生产者个人的关系；</p><p>中央和地方的关系；</p><p>汉族和少数民族的关系；</p><p>党和非党的关系；</p><p>革命和反革命的关系；</p><p>是非关系；</p><p>中国和外国的关系</p><h3 id="七千人大会"><a href="#七千人大会" class="headerlink" title="七千人大会"></a>七千人大会</h3><p>1962年，七千人大会在北京召开。刘少奇代表中央提出的书面报告草稿，总结了“大跃进”以来经济建设工作的经验教训，分析了产生缺点错误的原因。毛泽东着重阐述了民主集中制的极端重要性，并带头做了自我批评，特别强调在社会主义建设上，我们还有很大的盲目性，今后要下苦功夫调查研究，弄清楚社会主义经济的规律。要使中国赶上和超过世界上最先进的资本主义国家，没有一百多年的时间是不行的。这是党中央和毛泽东对社会主义建设长期性的进一步认识。邓小平、周恩来分别代表中央书记处和国务院在大会上作自我批评，并提出恢复党的优良传统和克服目前困难的主要办法。这次会议发扬了党内的民主和自我批评精神，统一了全党的认识，对动员全党团结奋斗战胜困难起了极其重要的作用。</p><p>经过七千人大会前后近两年的挑战，到1965年底，大跃进和人民公社化运动带来的严重困难局面终于得到了改变。</p><h3 id="四个现代化"><a href="#四个现代化" class="headerlink" title="四个现代化"></a>四个现代化</h3><p>1964年底，周恩来在三届全国人大一次会议上提出实现“四个现代化”的历史任务，即“在不太长的历史时期内，把我国建设成一个具有现代农业、现代工业、现代国防和现代科学技术的社会主义强国，赶上和超过世界先进水平”。中央还确定分两步走实现现代化的战略构想，即从第三个五年计划开始，第一步，经过三个五年计划时期，建立一个独立的比较完整的工业体系和国民经济体系；第二步，全面实现农业、工业、国防和科学技术的现代化，使中国经济走在世界前列。“四个现代化”从此成为党和全国各族人民的共同奋斗目标，成为凝聚和团结全国各族人民不懈奋斗的强大精神力量。</p>]]></content>
      
      
      <categories>
          
          <category> 近代史纲要 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 近代史纲要 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java分层模型</title>
      <link href="/2022/06/15/Java%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B/"/>
      <url>/2022/06/15/Java%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>表现层 presentation<br>业务逻辑层 service<br>数据持久层 dao</p><p>表示层(让控制层调用业务逻辑层显示数据，或者可以说直接使用业务逻辑层的数据。可以简单看成jsp页面)</p><p>业务逻辑层(service比DAO更为细化处理判断提取出来的数据，例如对某一个操作的细化)<br>XXXServiceDao(简单看成变量，或指针) –(指向)–&gt;XXXServiceDaoImpl(简单看成是变量的赋值，或实际的值)</p><p>DAO层(DAO，简单处理判断从数据库中提取出来的数据。可以看成就是增删改查操作)</p><p>XXXDao(简单看成变量，或指针)–(指向)–&gt;XXXDaoImpl(简单看成是变量的赋值，或实际的值)</p><p><strong>总结</strong>:本来业务逻辑层是没有数据的，但是由于DAO层的数据被业务逻辑层使用（实际上是”面向接口”编程，造成的接口回调。在我看来，其实就是类之间的引用。）</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>聚合与组合</title>
      <link href="/2022/06/15/%E8%81%9A%E5%90%88%E4%B8%8E%E7%BB%84%E5%90%88/"/>
      <url>/2022/06/15/%E8%81%9A%E5%90%88%E4%B8%8E%E7%BB%84%E5%90%88/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="聚合和组合"><a href="#聚合和组合" class="headerlink" title="聚合和组合"></a>聚合和组合</h1><h2 id="聚合（整体和部分可以分开）"><a href="#聚合（整体和部分可以分开）" class="headerlink" title="聚合（整体和部分可以分开）"></a>聚合（整体和部分可以分开）</h2><p>聚合关系表示一个整体与部分的关系，通常在定义一个整体类后，再去分析这个整体类的租场结构，从而找出一些成员类，该整体类和成员类之间就形成了聚合关系。</p><p>在聚合关系中，成员类是整体类的一部分，即成员对象是整体对象的一部分，但是成员对象可以脱离整体对象独立存在。</p><p><img src="https://img-blog.csdnimg.cn/20191229184245573.png"></p><p>聚合关系用于表示实体对象之间的关系，表示整体由部分构成的语义；例如一个部门由多个员工组成。</p><p>与组合关系不同的是，整体和部分不是强依赖的，即使整体不存在了，部分仍然存在；例如， 部门撤销了，人员不会消失，他们依然存在。</p><p>实例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">People</span>&#123;</span><br><span class="line">    Car car;</span><br><span class="line">    House house; </span><br><span class="line">    <span class="comment">//聚合关系中作为成员变量的类一般使用set方法赋值</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">setCar</span><span class="params">(Car car)</span></span>&#123;</span><br><span class="line">        This.car = car;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">setHouse</span><span class="params">(House house)</span></span>&#123;</span><br><span class="line">        This.house = house;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">driver</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(“车的型号：”+car.<span class="built_in">getType</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">sleep</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(“我在房子里睡觉：”+house.<span class="built_in">getAddress</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组合（整体和部分不能分开）"><a href="#组合（整体和部分不能分开）" class="headerlink" title="组合（整体和部分不能分开）"></a>组合（整体和部分不能分开）</h2><p>组合关系表示类之间整体和部分的关系，但是组合关系中部分和整体具有统一的生存期。一旦整体对象不存在，部分对象也将不存在，部分对象与整体对象之 间具有同生共死的关系。</p><p>在组合关系中，成员类是整体类的一部分，而且整体类可以控制成员类的生命周期，即成员类的存在依赖于整体类。</p><p><img src="https://img-blog.csdnimg.cn/20191229184852279.png"></p><p>与聚合关系一样，组合关系同样表示整体由部分构成的语义；比如公司由多个部门组成。</p><p>但组合关系是一种强依赖的特殊聚合关系，如果整体不存在了，则部分也不存在了；例如， 公司不存在了，部门也将不存在了。</p><p>实例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Public <span class="keyword">class</span> <span class="title class_">People</span>&#123;</span><br><span class="line">    Soul soul;</span><br><span class="line">    Body body; </span><br><span class="line">    <span class="comment">//组合关系中的成员变量一般会在构造方法中赋值</span></span><br><span class="line">     <span class="function">Public <span class="title">People</span><span class="params">(Soul soul, Body body)</span></span>&#123; </span><br><span class="line">        This.soul = soul;</span><br><span class="line">        This.body = body;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">Public <span class="type">void</span> <span class="title">study</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(“学习要用灵魂”+soul.<span class="built_in">getName</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Public <span class="type">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(“吃饭用身体：”+body.<span class="built_in">getName</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h2><p>1、依赖性区别</p><p>聚合中的两种类（或实体）是可以单独存在的，不会相互影响；被关联的一方可以独立于关联一方，依赖性不强。</p><p>相反，组合中的两个实体（或者类）是高度依赖于彼此的，它们之间会相互影响。</p><p>2、关系类型的区别</p><p>聚合代表了has-a关系，一种单向关系；组合代表了part-of关系。</p><p>3、关联强度的不同</p><p>聚合是一种弱关联关系；组合是一种强关联关系。</p><p>4、生命周期的不同</p><p>在聚合关系中的两个类（或实体）的生命周期是不同步；但，在组合关系中的两个类（或实体）的生命周期是同步的。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拷贝构造和拷贝赋值</title>
      <link href="/2022/06/09/%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%92%8C%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC/"/>
      <url>/2022/06/09/%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%92%8C%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://blog.csdn.net/weixin_43691639/article/details/124756222">(55条消息) 1. 拷贝构造、拷贝赋值、析构_Simple_667的博客-CSDN博客_拷贝构造 拷贝赋值</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深拷贝和浅拷贝</title>
      <link href="/2022/06/08/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
      <url>/2022/06/08/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>C++中类的拷贝有两种：深拷贝和浅拷贝；当出现等号赋值时，即会调用拷贝函数</p><h2 id="一、深拷贝和浅拷贝的区别"><a href="#一、深拷贝和浅拷贝的区别" class="headerlink" title="一、深拷贝和浅拷贝的区别"></a>一、深拷贝和浅拷贝的区别</h2><p>在未定义显示拷贝构造函数的情况下，系统会调用默认的拷贝函数——即浅拷贝，它能够完成成员的一一复制。当数据成员中没有指针时，浅拷贝是可行的；但当数据成员中有指针时，如果采用简单的浅拷贝，则两类中的两个指针将指向同一个地址，当对象快结束时，会调用两次析构函数，而导致指针悬挂现象，所以，此时，必须采用深拷贝。</p><p>深拷贝与浅拷贝的区别就在于深拷贝会在堆内存中另外申请空间来储存数据，从而也就解决了指针悬挂的问题。简而言之，当数据成员中有指针时，必须要用深拷贝。</p><h2 id="二、解释"><a href="#二、解释" class="headerlink" title="二、解释"></a>二、解释</h2><p>浅拷贝就是对象的数据成员之间的简单复制。如果你设计了一个类而没有提供它的复制构造函数，当该类的一个对象去给另一个对象赋值时所执行的过程就是浅拷贝。</p><p>然而当一个对象中有指针时，两个指针就会指向堆上的同一块内存，析构时就会对该内存释放两次。对同一块内存执行两次以上的释放结果时未定义的，所以这将导致内存泄漏或程序崩溃。</p><p>所以这里就需要深拷贝来解决这个问题。深拷贝就是当拷贝对象中有其他资源（如堆、文件、系统等）的指针或引用时，对象另开辟一块新的资源，而不再拷贝对象中堆其他资源的指针或引用进行单纯的赋值。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对象切片(Object slicing)</title>
      <link href="/2022/06/08/%E5%AF%B9%E8%B1%A1%E5%88%87%E7%89%87-Object-slicing/"/>
      <url>/2022/06/08/%E5%AF%B9%E8%B1%A1%E5%88%87%E7%89%87-Object-slicing/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>在C++编程中，将派生类类型（subclass type）的对象复制到基类类型（superclass）的对象时，将发生对象切片；基类副本将没有在派生类中定义的任何成员变量。实际上，这些变量已经被“分隔”。</p><p>更巧妙的是，当基类的赋值运算符将派生类类型的对象复制到相同类型的对象时，对象切片同样会发生，在这些情况下，目标对象的某些成员变量将保留其原始值，而不是从源对象复制过来。</p><h4 id="Example："><a href="#Example：" class="headerlink" title="Example："></a>Example：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> m_value&#123;&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> value): m_value&#123; value &#125;</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">getName</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;Base&quot;</span>; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_value; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>(<span class="type">int</span> value): Base&#123; value &#125;</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">getName</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;Derived&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derived derived&#123; <span class="number">5</span> &#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;derived is a &quot;</span> &lt;&lt; derived.<span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot; and has value &quot;</span> &lt;&lt; derived.<span class="built_in">getValue</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    Base &amp;ref&#123; derived &#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ref is a &quot;</span> &lt;&lt; ref.<span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot; and has value &quot;</span> &lt;&lt; ref.<span class="built_in">getValue</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    Base *ptr&#123; &amp;derived &#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ptr is a &quot;</span> &lt;&lt; ptr-&gt;<span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot; and has value &quot;</span> &lt;&lt; ptr-&gt;<span class="built_in">getValue</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例中，&amp;ref和*ptr指向派生对象，派生对象具有积累部分和派生部分。由于ref和ptr的类型为Base，因此ref和ptr只能看到derived的Base部分。</p><p>但是derived的Derived部分仍然存在，只是根本无法通过ref或ptr看到。但是通过使用虚函数，我们可以访问函数的最衍生版本。因此，以上程序打印：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">derived is a Derived and has value 5</span><br><span class="line">ref is a Derived and has value 5</span><br><span class="line">ptr is a Derived and has value 5</span><br></pre></td></tr></table></figure><p><b>但是，如果我们仅将派生对象分配给基类对象，而不是派生对象的基类引用或指针，会发生什么情况呢？</b></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Derived derived&#123;<span class="number">5</span>&#125;;</span><br><span class="line">Base base&#123;derived&#125;;<span class="comment">// what happens here?</span></span><br><span class="line">std::cout&lt;&lt;<span class="string">&quot;basee is a &quot;</span>&lt;&lt;base.<span class="built_in">getName</span>()&lt;&lt;<span class="string">&quot; and has value &quot;</span>&lt;&lt;base.<span class="built_in">getValue</span>()&lt;&lt;std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请记住，派生类具有基类部分和派生部分。当我们将派生对象分配给基类对象时，仅<b>复制派生对象的基类部分</b>，而不复制派生部分。在上面的示例中，base接收了派生的Base部分的副本，但没有Derived部分。该派生部分已被有效地“sliced off”。因此，将派生类对象分配给基类对象称为对象切片。</p><p>因为变量base没有派生部分，所以<code>base.getName()</code>解析为<code>Base::getName()</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">base is a Base <span class="keyword">and</span> has value <span class="number">5</span></span><br></pre></td></tr></table></figure><h4 id="Slicing-and-functions"><a href="#Slicing-and-functions" class="headerlink" title="Slicing and functions"></a>Slicing and functions</h4><p>现在，你可能会觉得上面的示例有点愚蠢，毕竟，你为什么要像这样分派派生给基础？你可能不会。但是，切片很可能会偶然发生在函数上。</p><p>考虑以下功能：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printName</span><span class="params">(<span class="type">const</span> Base base)</span> <span class="comment">//note: base passed by value,not reference</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout&lt;&lt;<span class="string">&quot;I am a &quot;</span>&lt;&lt;base.<span class="built_in">getName</span>()&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个非常简单的函数，带有const基础对象参数，该参数按值传递。如果我们这样调用此函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Derived d&#123;<span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in">printName</span>(d);<span class="comment">//oops,didn&#x27;t realize this way pass by value on the calling end</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在编写该程序时，你可能没有注意到base是一个值函数，而不是引用。因此，当调用<code>printName(d)</code>，我们可能期望<code>base.getName()</code>调用virtual函数<code>getName()</code>并显示“I am a Derived”，但是它没有发生。相反，<b>派生对象d被切片并且仅将基类部分复制到基类参数中</b>。执行<code>base.getName()</code>时，即使&#96;&#96;getName()&#96;函数已被虚拟化，该类也没有派生部分可以解析。因此，该程序将打印：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I am a Base</span><br></pre></td></tr></table></figure><p>当然，修改方法是通过将函数参数作为引用而不是按值传递（这也是按引用而不是按值传递类参数是个好主意的另一个原因），可以轻松避免在此处切片。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printName</span><span class="params">(<span class="type">const</span> Base &amp;base)</span> <span class="comment">//note: base now passed by reference</span></span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I am a Derived</span><br></pre></td></tr></table></figure><h4 id="Slicing-vectors"><a href="#Slicing-vectors" class="headerlink" title="Slicing vectors"></a>Slicing vectors</h4><p>新程序员在切片方面遇到麻烦的另一个领域是尝试使用<code>std :: vector</code>实现多态。考虑以下程序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::vector&lt;Base&gt; v&#123;&#125;;  <span class="comment">// std :: vector 被声明为 Base类型的向量</span></span><br><span class="line">v.<span class="built_in">push_back</span>(Base&#123; <span class="number">5</span> &#125;); <span class="comment">// add a Base object to our vector</span></span><br><span class="line">v.<span class="built_in">push_back</span>(Derived&#123; <span class="number">6</span> &#125;); <span class="comment">// add a Derived object to our vector</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Print out all of the elements in our vector</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; element : v)</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;I am a &quot;</span> &lt;&lt; element.<span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot; with value &quot;</span> &lt;&lt; element.<span class="built_in">getValue</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I am a Base with value 5</span><br><span class="line">I am a Base with value 6</span><br></pre></td></tr></table></figure><p>与前面的示例相似，因为<code>std :: vector</code>被声明为<code>Base</code>类型的向量，所以当将<code>Derived（6）</code>添加到该向量时，将其切片。</p><p>解决这个问题要困难一些。许多新程序员尝试创建对对象的引用的<code>std :: vector</code>，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::vector&lt;Base*&gt; v&#123;&#125;;</span><br><span class="line"></span><br><span class="line">Base b&#123; <span class="number">5</span> &#125;; <span class="comment">// b and d can&#x27;t be anonymous objects</span></span><br><span class="line">Derived d&#123; <span class="number">6</span> &#125;;</span><br><span class="line"> </span><br><span class="line">v.<span class="built_in">push_back</span>(&amp;b); <span class="comment">// add a Base object to our vector</span></span><br><span class="line">v.<span class="built_in">push_back</span>(&amp;d); <span class="comment">// add a Derived object to our vector</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Print out all of the elements in our vector</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>* element : v)</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;I am a &quot;</span> &lt;&lt; element-&gt;<span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot; with value &quot;</span> &lt;&lt; element-&gt;<span class="built_in">getValue</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I am a Base with value <span class="number">5</span></span><br><span class="line">I am a Derived with value <span class="number">5</span></span><br></pre></td></tr></table></figure><p>哪个有效? 有关于此的一些评论。首先，nullptr现在是一个有效的选项，可能不希望如此。其次，您现在必须处理指针语义，这可能很尴尬。但是从好的方面来说，这也允许动态内存分配，如果您的对象可能超出范围，这将很有用。</p><h4 id="The-Frankenobject"><a href="#The-Frankenobject" class="headerlink" title="The Frankenobject"></a>The Frankenobject</h4><p>在上面的示例中，我们看到了由于划分出派生类而导致切片导致错误结果的情况。现在，让我们看一下派生对象仍然存在的另一种危险情况！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">Derived d1&#123;<span class="number">5</span>&#125;;</span><br><span class="line">Derived d2&#123;<span class="number">6</span>&#125;;</span><br><span class="line">Base &amp;b&#123;d2&#125;;</span><br><span class="line"></span><br><span class="line">b = d1;<span class="comment">//this line is problematic</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数的前三行非常简单。创建两个”派生“对象， 并将”base”引用设置为第二个。第四行是误入歧途的地方。</p><p>如果b是派生的话，由于b指向d2，我们将d1分配给b，你可能会认为结果是将d1将被复制到d2中。但b是一个基类对象，默认情况下C++为类提供的<code>operator =</code>不是virtual的。因此，只有d1的基本部分被复制到d2中。</p><p>结果，你将发现d2现在具有d1的基类部分和d2本身的派生部分，创建出一个<code>Frankenobject</code>（它由多个对象的一部分组成）。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常对象、常变量、常成员函数</title>
      <link href="/2022/06/08/%E5%B8%B8%E5%AF%B9%E8%B1%A1%E3%80%81%E5%B8%B8%E5%8F%98%E9%87%8F%E3%80%81%E5%B8%B8%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/"/>
      <url>/2022/06/08/%E5%B8%B8%E5%AF%B9%E8%B1%A1%E3%80%81%E5%B8%B8%E5%8F%98%E9%87%8F%E3%80%81%E5%B8%B8%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>既要使数据能在一定范围内共享，又要保证它不被任意修改，可使用const。</p><ul><li>用const修饰的声明数据成员称为常数据成员</li><li>用const修饰的声明成员函数称为常成员函数</li><li>用const修饰的定义对象称为常对象</li></ul><p>变量或对象被const修饰后其值不能被更新。因此被const修饰的变量过对象必须要进行初始化。</p><h1 id="（一）-用const修饰的声明数据成员称为常数据成员"><a href="#（一）-用const修饰的声明数据成员称为常数据成员" class="headerlink" title="（一） 用const修饰的声明数据成员称为常数据成员"></a>（一） 用const修饰的声明数据成员称为常数据成员</h1><p>有两种声明形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> <span class="type">const</span> a;</span><br></pre></td></tr></table></figure><p>说明：</p><ol><li>任何函数都不能对常数据成员赋值。</li><li>构造函数对常数据成员进行初始化时也只能通过初始化列表进行。（只此一种）</li><li>常数据成员在初始化时都必须赋值或称其必须初始化。</li><li>如果类有多个默认构造函数都必须初始化常数据成员。</li></ol><p><b>指出下面程序的错误：</b></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> w,h;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> num = <span class="number">5</span>;<span class="comment">//错误一</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">A a;<span class="comment">//错误二</span></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;sss&quot;</span>;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>错误一：不能对常数据成员在类中初始化，要通过类的构造函数，只有静态常量才能这样初始化。</p><p>错误二：没有合适的默认构造函数可用。因为有常量num没有初始化。必须初始化所有常量数据成员。</p><p>更正后结果如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> w,h;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> num;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> num2;</span><br><span class="line"><span class="built_in">A</span>():<span class="built_in">num</span>(<span class="number">5</span>),<span class="built_in">num2</span>(<span class="number">8</span>)&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>请指出下面程序的错误：</b></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> w,h;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> num;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> num2;</span><br><span class="line"><span class="built_in">A</span>():<span class="built_in">num</span>(<span class="number">5</span>),<span class="built_in">num2</span>(<span class="number">8</span>)&#123;&#125;;</span><br><span class="line"><span class="built_in">A</span>(<span class="type">int</span> x,<span class="type">int</span> y)&#123;</span><br><span class="line">w=x;h=y;<span class="comment">//错误一</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;；</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">A a;</span><br><span class="line"><span class="function">A <span class="title">b</span><span class="params">(<span class="number">3</span>,<span class="number">8</span>)</span></span>;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;sss&quot;</span>;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>错误一：每个构造函数都要初始化常数据成员，应改为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">A</span>(<span class="type">int</span> x,<span class="type">int</span> y):<span class="built_in">num</span>(<span class="number">5</span>),<span class="built_in">num2</span>(<span class="number">8</span>)&#123;</span><br><span class="line">w=x;h=y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="（二）-用const修饰的声明成员函数称为常成员函数"><a href="#（二）-用const修饰的声明成员函数称为常成员函数" class="headerlink" title="（二） 用const修饰的声明成员函数称为常成员函数"></a>（二） 用const修饰的声明成员函数称为常成员函数</h1><p>声明：&lt;类型标志符&gt;函数名（参数表）const；</p><p>说明：</p><ol><li>const是函数类型的一部分，在实现部分也要带该关键字。</li><li>const关键字可以用于对重载函数的区分。</li><li>常成员函数不能更新任何数据成员，也不能调用该类中没有用const修饰的成员函数，能调用常成员函数和常数据成员。</li><li>const仅用于对象（this指针是const），static members允许修改。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> w,h;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> x,<span class="type">int</span> y)&#123;</span><br><span class="line">        w=x;h=y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">A::getValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> w*h;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">A::getValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="comment">//两种函数const和非const都要进行重载</span></span><br><span class="line">    <span class="keyword">return</span> w+h;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">A <span class="type">const</span> <span class="title">a</span><span class="params">(<span class="number">3</span>,<span class="number">4</span>)</span></span>; <span class="comment">//const对象调用const函数</span></span><br><span class="line">    <span class="function">A <span class="title">c</span><span class="params">(<span class="number">2</span>,<span class="number">6</span>)</span></span>;<span class="comment">//非const对象调用非const函数</span></span><br><span class="line">    cout&lt;&lt;a.<span class="built_in">getValue</span>()&lt;&lt;c.<span class="built_in">getValue</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常成员函数可以被其他成员函数调用，但是不能调用其他非常成员函数，可以调用其他常成员函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> w,h;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> w*h+<span class="built_in">getValue2</span>();<span class="comment">//错误 不能调用其他非常成员函数</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> w+h+<span class="built_in">getValue</span>();<span class="comment">//正确 可以调用常成员函数</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> x,<span class="type">int</span> y)&#123;</span><br><span class="line">        w=x;h=y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>常成员函数中， const修饰的是普通成员函数中this指针指向的内存空间。即：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printT</span><span class="params">(<span class="type">const</span> Test* <span class="type">const</span> <span class="keyword">this</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printT</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><p>上面第二个const是普通成员函数和常成员函数均有的，表示的是指针本身的指向一旦确定不可修改，即指针常量。</p><p>最前面的const是自己添加的，表示的是指针指向的内存空间的值不可被修改，是一个常量指针，从而this指针是一个指向常量的常量指针。</p><h1 id="（三）用const修饰的定义对象称为常对象"><a href="#（三）用const修饰的定义对象称为常对象" class="headerlink" title="（三）用const修饰的定义对象称为常对象"></a>（三）用const修饰的定义对象称为常对象</h1><p>常对象是指对象的数据成员的值在对象调用时不能被改变。常对象必须进行初始化，且不能被更新。不能通过常对象调用普通成员函数，但是可以通过调用普通对象调用常成员函数。常对象只能调用常成员函数。</p><p>常对象的声明：</p><p>​const &lt;类名&gt; &lt;对象名&gt;</p><p>​&lt;类名&gt; const &lt;对象名&gt;</p><p><b>请指出下面程序的错误：</b></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> w,h;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getArea</span><span class="params">()</span><span class="type">const</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> w*h;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getW</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> w;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setWH</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;w=x;h=y;&#125;</span><br><span class="line"><span class="built_in">A</span>(<span class="type">int</span> x,<span class="type">int</span> y)&#123;w=x;h=y;&#125;</span><br><span class="line"><span class="built_in">A</span>()&#123;;&#125;<span class="comment">//本例中不能省略，因为普通对象需要使用</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">A a;<span class="comment">//普通对象可以不初始化</span></span><br><span class="line">a.<span class="built_in">setWH</span>(<span class="number">3</span>,<span class="number">9</span>);</span><br><span class="line">A <span class="type">const</span> b;<span class="comment">//常对象必须声明的同时初始化，正确的时A const b(2,7)</span></span><br><span class="line">b.<span class="built_in">setWH</span>(<span class="number">2</span>,<span class="number">7</span>);<span class="comment">//错误，常对象不能调用非常成员函数，且值不能改变</span></span><br><span class="line">cout&lt;&lt;a.<span class="built_in">getArea</span>()&lt;&lt;endl&lt;&lt;b.<span class="built_in">getArea</span>()&lt;&lt;endl;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS：</p><ul><li>常成员函数可以引用const数据成员，也可以引用非const数据成员</li><li>const数据成员可以被const成员函数引用，也可以被非const的成员函数引用</li><li>常成员函数不能调用另一个非const成员函数</li><li>const int *pa 指的是不能改变pa指向的变量的值</li></ul><p>const指针：</p><ul><li>如果一个变量已经被声明为常变量，只能用指向常量的指针变量指向它，而不能用非常量指针指向它。</li><li>指向常变量的指针除了可以指向常变量外，还可以指向未被声明为const的变量。此时不能通过该指针改变变量的值</li><li>如果函数的形参时指向非const型变量的指针，实参只能用指向非const变量的指针，而不能用指向const变量的指针</li></ul><h1 id="其他关于const位置的小结"><a href="#其他关于const位置的小结" class="headerlink" title="其他关于const位置的小结"></a>其他关于const位置的小结</h1><ol><li><p>当函数是指针返回时，该返回值只能返回给用const修饰的同类型指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span>* <span class="title">getval</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span>* tmp = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* a = <span class="built_in">getVal</span>();<span class="comment">//编译错误</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>*b = <span class="built_in">getVal</span>();<span class="comment">//正确</span></span><br></pre></td></tr></table></figure></li><li><p>const修饰成员变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="type">const</span> a;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> a;<span class="comment">//两者等价，定义常量a</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>* a;</span><br><span class="line"><span class="type">int</span> <span class="type">const</span>* a;<span class="comment">//两者等价，定义了常量指针，即指针指向的值不可改变</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="type">const</span> a;<span class="comment">//定义了一个指针常量，即指针的指向不可改变</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++异常处理</title>
      <link href="/2022/06/01/C++%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
      <url>/2022/06/01/C++%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="C-异常处理关键字"><a href="#C-异常处理关键字" class="headerlink" title="C++异常处理关键字"></a>C++异常处理关键字</h2><p><code>try</code>：定义一个代码块，该代码块在执行时将金鹰异常错误检测。通常后面跟一个或多个<code>catch</code>块</p><p><code>catch</code>：如果<code>try</code>块中发生错误，则该语句允许定义要执行的代码块</p><p><code>throw</code>：可以创建一个自定义错误，可以抛出自定义的异常</p><h2 id="C-throw抛出异常"><a href="#C-throw抛出异常" class="headerlink" title="C++ throw抛出异常"></a>C++ throw抛出异常</h2><p>可以用throw语句在代码块任何地方抛出异常。throw语句的操作数可以是任意的表达式，表达式的结果类型决定了抛出的异常的类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="type">int</span> age = <span class="number">11</span>;</span><br><span class="line"><span class="keyword">if</span>(age &gt; <span class="number">0</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;age &gt; 0&quot;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">throw</span>(age);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span>(<span class="type">int</span> myNum)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;age不是合法值！&quot;</span>;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;age = &quot;</span>&lt;&lt;myNum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-标准异常"><a href="#C-标准异常" class="headerlink" title="C++标准异常"></a>C++标准异常</h2><p>C++提供一些标准的异常，定义在<code>&lt;exception</code>中。</p><table><thead><tr><th>异常</th><th>描述</th></tr></thead><tbody><tr><td>std::exception</td><td>该异常是所有标准 C++ 异常的父类。</td></tr><tr><td>std::bad_alloc</td><td>该异常可以通过 new 抛出。</td></tr><tr><td>std::bad_cast</td><td>该异常可以通过 dynamic_cast 抛出。</td></tr><tr><td>std::bad_exception</td><td>这在处理 C++ 程序中无法预期的异常时非常有用。</td></tr><tr><td>std::bad_typeid</td><td>该异常可以通过 typeid 抛出。</td></tr><tr><td>std::logic_error</td><td>理论上可以通过读取代码来检测到的异常。</td></tr><tr><td>std::domain_error</td><td>当使用了一个无效的数学域时，会抛出该异常。</td></tr><tr><td>std::invalid_argument</td><td>当使用了无效的参数时，会抛出该异常。</td></tr><tr><td>std::length_error</td><td>当创建了太长的 std::string 时，会抛出该异常。</td></tr><tr><td>std::out_of_range</td><td>该异常可以通过方法抛出，例如 std::vector 和 std::bitset&lt;&gt;::operator<a href=""></a>。</td></tr><tr><td>std::runtime_error</td><td>理论上不可以通过读取代码来检测到的异常。</td></tr><tr><td>std::overflow_error</td><td>当发生数学上溢时，会抛出该异常。</td></tr><tr><td>std::range_error</td><td>当尝试存储超出范围的值时，会抛出该异常。</td></tr><tr><td>std::underflow_error</td><td>当发生数学下溢时，会抛出该异常。</td></tr></tbody></table><h2 id="C-自定义异常"><a href="#C-自定义异常" class="headerlink" title="C++自定义异常"></a>C++自定义异常</h2><p>可以通过继承和重载<code>exception</code>类来实现自定义异常类型。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyException</span> : <span class="keyword">public</span> exception</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">what</span><span class="params">()</span> <span class="type">const</span> <span class="title">throw</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;C++ Exception&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">MyException</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span>(MyException&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;MyException caught&quot;</span>&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;e.<span class="built_in">what</span>()&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span>(exception&amp; e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//其他的错误</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>catch从上到下一一匹配，注意子类异常会被父类异常接收，产生对象切片、复制等问题。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>观察者模式</title>
      <link href="/2022/05/31/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/05/31/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>观察者模式（Observer Pattern）有两个角色，观察者和被观察者（也有说法是主题和订阅者）。处于某些状况，在被观察者改变时，观察者需要知道状态。这是一种使用率非常高的模式，在GUI系统中经常被使用。也有许多对于观察者模式的扩展与实现，知名的[ReactiveX]就实现了观察者模式的程序设计思想。</p><p>定义：观察者模式时一种一对多的依赖关系，当物件的状态改变，所有依赖于它的物件都会得到通知并被自动更新。</p><blockquote><p><strong>The Observer pattern defines a one-to-many dependency</strong> between objects so that when <strong>one</strong> object changes state, all of its dependents are notified and updated automatically.<br><em>– from <a href="http://www.sihui.io/design-pattern-observer/">Design Pattern: Observer and Podcasts</a></em></p></blockquote><p><img src="https://ithelp.ithome.com.tw/upload/images/20181023/20112528E2P8dfMVqg.png"></p><p>[<a href="https://ithelp.ithome.com.tw/articles/10204117"> Day 8 ] 初探設計模式 - 觀察者模式 ( Observer Pattern ) - iT 邦幫忙::一起幫忙解決難題，拯救 IT 人的一天 (ithome.com.tw)</a></p><p>（其实就是被观察者中有一个列表，上面记录了所有的观察者，然后更新时就会遍历列表，然后一一调用观察者的函数通知。）</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>装饰模式</title>
      <link href="/2022/05/31/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/05/31/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>装饰模式的角色有元件和装饰，装饰需要构建在被装饰的元件上。装饰模式是一种继承体系的替代方案。装饰物不同但是元件的本质不变。</p><p>装饰模式可以解决属性或者类别特别多的问题，将元件、装饰和组合的逻辑分离开来，因此我们能根据状况动态地获得想要的结果。</p><p>定义：动态地给一个类别添加额外的职责。就增加的功能来说，装饰模式相比产生子类更为灵活。</p><span id="more"></span><p><img src="https://ithelp.ithome.com.tw/upload/images/20181114/20112528fzlaKgAdOc.png"></p><ul><li>Component：被装饰的核心元件</li><li>Decorator：装饰核心的其他元件</li></ul><p>[<a href="https://ithelp.ithome.com.tw/articles/10203738"> Day 7 ] 初探設計模式 - 裝飾模式(Decorator) - iT 邦幫忙::一起幫忙解決難題，拯救 IT 人的一天 (ithome.com.tw)</a></p><p>上面代码很好。</p><blockquote><p>裝飾模式可以把類別中的裝飾功能從類別中搬移去除，這樣可以簡化原有類別。也就是把類別中核心職責和裝飾功能區分開，並去除相關內別中重複的邏輯。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式</title>
      <link href="/2022/05/30/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/05/30/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>单例模式，即只有一个实例，而且自行实例化并向整个系统提供这个实例。</p><p>这个模式涉及到一个单一的类别，它必须要创建自己的实例，并且确保只有一个单一对象被创建。这个类别提供一个方法访问被创建的唯一一个对象。</p><p>存取IO和数据库等资源时，要考虑使用单例模式。</p><span id="more"></span><p>有几种方式可以实现单例模式</p><ul><li>懒汉（Lazy）模式（线程不安全）</li><li>懒汉模式（线程安全）</li><li>积极模式</li><li>双重锁（Double Chock Lock）</li><li>登记式（静态内部类）</li><li>枚举（enumeration）</li></ul><h2 id="积极单例模式"><a href="#积极单例模式" class="headerlink" title="积极单例模式"></a>积极单例模式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleObject</span>&#123;</span><br><span class="line"><span class="comment">//创建一个对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">SingleObject</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingleObject</span>();</span><br><span class="line"><span class="comment">//让构造函数为private，这样该类就不会被实例化</span></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">SingleObject</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"><span class="comment">//获取唯一可用对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> SingleObject <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="懒汉（Lazy）模式"><a href="#懒汉（Lazy）模式" class="headerlink" title="懒汉（Lazy）模式"></a>懒汉（Lazy）模式</h2><p>懒汉模式在呼叫getInstance时才进行初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"><span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这种实现方式每次都要进行同步，效率会很低。</p><p>这是因为，懒汉式创建对象有一个判断的过程，如果有多个线程同时到达了判断语句，然后当前实例为空，所以就会分别进行初始化。（synchronized就是类锁（静态方法锁），这样在一个时间点只有一个线程可以访问这段代码，保证了线程安全。）</p><h2 id="双重锁"><a href="#双重锁" class="headerlink" title="双重锁"></a>双重锁</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;  ①</span><br><span class="line">        <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">            <span class="keyword">if</span>(instance ==<span class="literal">null</span>) ②</span><br><span class="line">                instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以进行二次校验同步（类锁），十分高效。</p><p>具体流程如下，Thread1和Thread2都通过①进入了条件语句，由于Thread1拿到了锁，所以Thread2需要等待锁，此时Thread1实例化了instance，然后释放锁。接着Thread2拿到锁进入②，判断此时是有实例的，所以什么也不做获取实例</p><p>判断两次看起来有点奇怪，但是这样是有原因的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br></pre></td></tr></table></figure><p>上面这段代码看起来只有一段，但其实它不是原子操作，会被编译成多条组合指令，大致上做了三件事：</p><ol><li>给Singleton的实例分配内存</li><li>呼叫Singleton的构造函数，初始化成员变量</li><li>将instance指向分配的内存（此时instance不是null）</li></ol><p>但Java编译器是无法保证2和3的顺序的，如果2还没执行完就切换到线程B，那instance已经不是null，此时B取走instance再使用就会出错。</p><blockquote><p>JDK1.5以後的版本，官方注意到問題，所以調整JMM具體化volatile關鍵字，所以只要把instance寫法改成<code>private volatile static Singleton instance = null;</code>就可以保證都從主記憶體讀取，並且以DCL寫法完成單例模式。</p></blockquote><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticInnerClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">StaticInnerClass</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> StaticInnerClass <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> StaticInnerClassHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态内部类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StaticInnerClassHolder</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">StaticInnerClass</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticInnerClass</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以保证线程安全，保证唯一性，并且延迟实例化，所以推荐使用。</p><h2 id="用枚举实现"><a href="#用枚举实现" class="headerlink" title="用枚举实现"></a>用枚举实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">EnumSingleton</span>&#123;</span><br><span class="line">INSTANCE;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;do do !&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以避免反实例化</p><blockquote><p>前面的单例模式要避免反实例化要加入readResolve()方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Object <span class="title function_">readResolve</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException &#123;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PPP协议</title>
      <link href="/2022/05/29/PPP%E5%8D%8F%E8%AE%AE/"/>
      <url>/2022/05/29/PPP%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>PPP协议是一种点到点（一根链路两端只有两个接口）链路层协议，主要用在全双工的同异步链路上进行点到点的数据传输。</p><span id="more"></span><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>PPP协议（Point-to-Point Protocol）是一种网络协议中最为基础的协议，工作在数据链路层，它是为在同等单元之间传输数据包这样的简单链路而设计的，这种链路提供了全双工操作，并按照顺序传递数据报。</p><p>PPP主要是用来通过拨号或专线方式在两个网络节点之间建立连接、发送数据。PPP是各类型主机、网桥和路由器之间简单连接的一种解决方案。PPP协议是目前广域网上应用最广泛的协议之一，它的优点在于简单、具备用户验证能力、可以解决IP分配等。</p><p>PPP协议包括一下三个部分：</p><ul><li>数据帧封装方法</li><li>链路控制协议LCP（Link Control Protocol），用于对封装格式选项的自动协商、建立和终止连接，探测链路错误和配置错误。</li><li>针对不同网络层协议的一族网络控制协议NCP（Network Control Protocol），PPP协议规定了每一种网络层协议都有相应的网络控制协议，，并用他们来管理各个协议不同的需求。</li></ul><h2 id="PPP的LCP子层和NCP子层"><a href="#PPP的LCP子层和NCP子层" class="headerlink" title="PPP的LCP子层和NCP子层"></a>PPP的LCP子层和NCP子层</h2><p>1） LCP（Link Control Protocol）子层</p><p>LCP子层位于物理层之上，除了用来建立、配置和测试数据链路连接外，还提供下面这些功能：</p><ul><li>身份验证：提供了PAP和CHAP验证</li><li>压缩：将需要传输的数据先压缩再传输。支持Stac、Predictor、MPPC以及TCP头部压缩。</li><li>错误检测：保证链路的质量</li><li>多链路：实现链路的负载均衡</li><li>PPP回拨：可以提高安全性和节约用户拨号费用</li></ul><p>2）NCP（Network Control Protocol）子层</p><p>当LCP将链路建立好后，PPP开始根据不同用户的需要配置上层协议所需环境，NCP被用来为上层服务提供接口，针对不同的上层协议NCP提供不同的服务组件。</p><h2 id="PPP-链路建立状态机"><a href="#PPP-链路建立状态机" class="headerlink" title="PPP 链路建立状态机"></a>PPP 链路建立状态机</h2><p><img src="https://static.getiot.tech/ppp-protocol-link.png" alt="img"></p><ul><li><strong>Dead 阶段</strong>：也称为物理层不可用阶段。当通信双方的两端检测到物理线路激活时，就会从 Dead 阶段迁移至 Establish 阶段，即链路建立阶段。</li><li><strong>Establish 阶段</strong>：PPP 链路进行 LCP 参数协商。协商内容包括最大接收单元 MRU（Maximum Transfer Unit）、认证方式、魔术字（Magic Number）等选项。LCP 参数协商成功后会进入 Opened 状态，表示底层链路已经建立。</li><li><strong>Authenticate 阶段</strong>：多数情况下，链路两端的设备是需要经过认证阶段（Authenticate）后才能够进入到网络层协议阶段。PPP 链路在缺省情况下是不要求进行认证的。如果要求认证，则在链路建立阶段必须指定认证协议。认证方式是在链路建立阶段双方进行协商的。如果在这个阶段再次收到了 Configure-Request 报文，则又会返回到链路建立阶段。</li><li><strong>Network 阶段</strong>：PPP 链路进行 NCP 协商。通过 NCP 协商来选择和配置一个网络层协议并进行网络层参数协商。只有相应的网络层协议协商成功后，该网络层协议才可以通过这条 PPP 链路发送报文。如果在这个阶段收到了 Configure-Request 报文，也会返回到链路建立阶段。NCP 协商成功后，PPP 链路将保持通信状态。</li><li>PPP 运行过程中，可以随时中断连接，例如物理链路断开、认证失败、超时定时器时间、管理员通过配置关闭连接等动作都可能导致链路进入 <strong>Terminate 阶段</strong>。在 Terminate 阶段，如果所有的资源都被释放，通信双方将回到 <strong>Dead 阶段</strong>，直到通信双方重新建立 PPP 连接。</li></ul><h2 id="PPP会话建立过程"><a href="#PPP会话建立过程" class="headerlink" title="PPP会话建立过程"></a>PPP会话建立过程</h2><p>PPP从开始发起呼叫到最终通信完成后释放链路一共要经历下面四个步骤：</p><p>第一步：链路的建立和配置协商，主要由LCP完成，通信的发起方发送LCP帧来配置和检测数据链路。</p><p>第二步：链路质量检测（可选），属于LCP的可选功能，主要是测试链路质量能否满足要求。</p><p>第三步：网络层协议的配置阶段，主要是NCP的功能，通信双方交换一系列NCP分组来配置网络层，NCP配置好后双方的逻辑通信链路就建立完成了。</p><p>第四步：链路终止，当数据传送完成，或者一些外部事件发生的时候，一方会发起断开连接的请求，这时，首先使用NCP来释放网络层的连接，然后使用LCP来关闭数据链路层的连接，最后双方的通信设备关闭物理链路。</p><h2 id="PPP身份验证协议"><a href="#PPP身份验证协议" class="headerlink" title="PPP身份验证协议"></a>PPP身份验证协议</h2><p>PPP有两种可选的身份验证协议PAP和CHAP。</p><h3 id="1-PAP（Password-Authentication-Protocol，密码验证协议）"><a href="#1-PAP（Password-Authentication-Protocol，密码验证协议）" class="headerlink" title="1. PAP（Password Authentication Protocol，密码验证协议）"></a>1. PAP（Password Authentication Protocol，密码验证协议）</h3><p>这是一种两次握手协议，采用明文传输方式传输用户口令，验证步骤如下：</p><p>首先被验证方主动发起验证请求，将本地配置的用户名和密码用明文的方式发送给验证方，验证方接收到验证请求后检查此用户名和密码是否正确（再验证方的数据库中也配置有此用户名和密码），正确就发回接受报文，错误就发送拒绝报文；这种验证方式是采用明文传输，很容易被破解。</p><p><img src="https://www.qingsword.com/qing/images/Cisco-CCNA-PPP-2.jpg"></p><h3 id="2-CHAP（Challenge-Handshake-Authentication-Protocol，挑战握手验证协议）"><a href="#2-CHAP（Challenge-Handshake-Authentication-Protocol，挑战握手验证协议）" class="headerlink" title="2. CHAP（Challenge Handshake Authentication Protocol，挑战握手验证协议）"></a>2. CHAP（Challenge Handshake Authentication Protocol，挑战握手验证协议）</h3><p>这是一种三次握手协议，它只在网络上传输用户名，密码并不在网络上传输，下图为CHAP验证示意图：</p><p><img src="https://www.qingsword.com/qing/images/Cisco-CCNA-PPP-3.jpg"></p><p>CHAP的验证过程如下：</p><p>在PPP链路建立阶段完成之后（R1作为被验证方拨入），验证方R2主动发起验证挑战“Challenge”，挑战报文中“01”是序列号；R2上可能有多个拨入请求，“ID”用来识别是哪个拨入者发起的挑战；“Random”是一个随机数；“R2”是发起挑战路由器的名字。</p><p><img src="https://www.qingsword.com/qing/images/Cisco-CCNA-PPP-4.jpg"></p><p>被验证方收到验证方发来的请求后，根据这个报文中的路由器的名称（R2），在本地数据库中寻找这个名称（R2）对应的密码，如果找到对应的密码，则用验证方送过来的报文的ID和随机数加上本地数据库中找到的密码，以MD5算法生成一个hash值。</p><p><img src="https://www.qingsword.com/qing/images/Cisco-CCNA-PPP-5.jpg"></p><p>生成hash之后，再将这个hash值、验证方R2发送过来的ID号以及本路由器的名称R1，发回给验证方R2。其中报文的序列号是“02”，“ID”是R2发送过来的ID不变，“hash”是R1计算后得到的哈希值。</p><p><img src="https://www.qingsword.com/qing/images/Cisco-CCNA-PPP-6.jpg"></p><p>R2接收到这个报文后，利用报文中的ID值找到储存在本地数据库中的随机数，并且根据发送过来的报文中路由器的名称（R1）找到本地数据库对应这个名称的密码，然后利用ID、随机数、R1对应的密码使用MD5算法生成一个hash值，最后用这个hash值与R1发送过来的hash比较，相同则验证通过，发回序列号是“03”的确认报文，如果不相同则验证失败，发回序号是“04”的验证失败报文。</p><p>从这个步骤可以看出，只要双方配置相同的验证密码，即可完成验证，并且这个密码是不会在链路上传输的，传输的只是一个随机数、一个ID值、路由器的名称和发回的hash值。</p><h2 id="PPP实验"><a href="#PPP实验" class="headerlink" title="PPP实验"></a>PPP实验</h2><p><a href="https://www.qingsword.com/qing/661.html">https://www.qingsword.com/qing/661.html</a></p><p><a href="https://getiot.tech/protocol/ppp.html">https://getiot.tech/protocol/ppp.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据管理基础</title>
      <link href="/2022/05/28/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/05/28/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><h2 id="数据管理技术的产生和发展"><a href="#数据管理技术的产生和发展" class="headerlink" title="数据管理技术的产生和发展"></a>数据管理技术的产生和发展</h2><h3 id="人工管理阶段"><a href="#人工管理阶段" class="headerlink" title="人工管理阶段"></a>人工管理阶段</h3>]]></content>
      
      
      <categories>
          
          <category> 数据管理基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据管理基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ICMP(网络层协议）</title>
      <link href="/2022/05/27/ICMP(%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8D%8F%E8%AE%AE%EF%BC%89/"/>
      <url>/2022/05/27/ICMP(%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8D%8F%E8%AE%AE%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>互联网控制消息协议（Internet Control Message Protocol，ICMP）用于网际协议（IP）中发送控制消息，提供可能发生在通信环境中的各种问题反馈。通过这些消息，使管理者可以对发生的问题做出诊断，然后采取适当的措施解决。</p><p>ICMP依靠IP来完成它的任务，是IP的主要部分。它与传输协议（如TCP和UDP）显著不同：它一般不用在两点间传输数据。它通常不由网络程序直接使用，除了ping和traceroute两个特别的例子。</p><p>ICMP报文作为IP层的数据，加上数据报的首部，组成IP数据发送出去。</p><span id="more"></span><h2 id="为什么要有ICMP"><a href="#为什么要有ICMP" class="headerlink" title="为什么要有ICMP"></a>为什么要有ICMP</h2><p>对于TCP&#x2F;IP协定家族，ICMP恐怕是最容易忽略的协定。对于前面讨论的协定，真正发挥工作的前提是“一切都没有问题”。但是实际网络环境中，设定可能有误、线路可能会断、设备可能会坏、router可能负载太高……这些情况我们是无法保证的。那么，我们<b>需要有一套机制来侦测或者通知各种可能发生的情况</b>。这就是ICMP协议的目的了。</p><h2 id="不应发送ICMP差错报文的几种情况"><a href="#不应发送ICMP差错报文的几种情况" class="headerlink" title="不应发送ICMP差错报文的几种情况"></a>不应发送ICMP差错报文的几种情况</h2><ul><li>对ICMP差错报文不再发送ICMP差错报告</li><li>对第一个分片的数据报片的所有后续数据报片都不发送ICMP差错报告报文</li><li>对具有多播地址的数据报都不发送ICMP差错报告报文</li><li>对具有特殊地址（如127.0.0.0或0.0.0.0）的数据报不发送ICMP差错报告报文</li></ul><h2 id="PING（Packet-InterNet-Groper）"><a href="#PING（Packet-InterNet-Groper）" class="headerlink" title="PING（Packet InterNet Groper）"></a>PING（Packet InterNet Groper）</h2><p>PING是用ICMP的“Echo request”和“Echo reply”消息实现的，用来测试两个主机之间的连通性。PING使用了ICMP回送请求与回送回答报文，是应用层直接使用网络层ICMP的例子，没有通过运输层的TCP或UDP。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++template</title>
      <link href="/2022/05/27/C++template/"/>
      <url>/2022/05/27/C++template/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>template模板在C++中，是将数据类型作为参数传递，这样我们就不需要为不同的类型编写相同的代码。</p><p>C++中添加了两个新关键字来支持模板：<code>template</code>和<code>typename</code>。第二个关键字<code>typename</code>可以替换为关键字<code>class</code>.</p><span id="more"></span><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">myMax</span><span class="params">(T x,T y)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x&gt;y?x:y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout&lt;&lt;<span class="built_in">myMax</span>&lt;<span class="type">int</span>&gt;(<span class="number">3</span>,<span class="number">7</span>)&lt;&lt;endl;<span class="comment">//方括号可以省略</span></span><br><span class="line">cout&lt;&lt;<span class="built_in">myMax</span>&lt;<span class="type">char</span>&gt;(<span class="string">&#x27;g&#x27;</span>,<span class="string">&#x27;e&#x27;</span>)&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模板可以以两种不同的方式使用：</p><ul><li>函数模板</li><li>类模板</li></ul><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>泛型是允许类型（整数、字符串等）作为方法、类和接口的参数的想法。例如：像数组这样的对象可以非常有效地使用泛型。</p><p>泛型编程的优点是：</p><ul><li>代码可重用性</li><li>避免函数重载</li><li>一旦编写泛型，它可以用于多个cpp</li></ul><p>泛型一般结合模板使用。模板是将数据类型作为参数传递，这样我们就不需要为不同的数据类型编写相同的代码。</p><h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2><p>函数模板用于创建一组将相同算法应用于不同数据类型的函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">addition</span><span class="params">(T x,T y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x+y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">addition</span>(<span class="number">3.0</span>,<span class="number">7.1</span>)&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果两个不同类型的数（3+7.0）则会报错，因为泛型函数声明两个参数的数据类型相同。</p><h2 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h2><p>类模板可以轻松地为所有数据类型重用相同的代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Calculator</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T num1,num2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Calculator</span>(T n1,T n2)&#123;</span><br><span class="line">        num1 = n1;</span><br><span class="line">        num2 = n2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">displayResult</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Numbers are &quot;</span>&lt;&lt;num1&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;num2&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Add result: &quot;</span>&lt;&lt;<span class="built_in">add</span>()&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num1+num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Calculator&lt;<span class="type">int</span>&gt; <span class="title">calculator</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">    calculator.<span class="built_in">displayResult</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数模板具体化"><a href="#函数模板具体化" class="headerlink" title="函数模板具体化"></a>函数模板具体化</h2><p>函数模板具体化就是将某一（某几）个要处理的类型单独处理，需要单独写一个实现，形式是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tfunc</span><span class="params">(type&amp; t)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="类模板的继承"><a href="#类模板的继承" class="headerlink" title="类模板的继承"></a>类模板的继承</h2><p>类模板被继承后参数的传递方式主要有两种：一种是在子类继承父类的时候，为父类指定固定的类型；二十通过子类模板参数列表传递。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ====== 测试一 ======</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Y&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(T t, Y y) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> : <span class="keyword">public</span> A&lt;<span class="type">int</span>, <span class="type">double</span>&gt; &#123; <span class="comment">// 父类是类模板，子类是普通类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>() : <span class="built_in">A</span>&lt;<span class="type">int</span>, <span class="type">double</span>&gt;(<span class="number">2</span>, <span class="number">2.1</span>) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Test</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====== 测试二 ======</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Y&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(T t) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> X, <span class="keyword">typename</span> Z, <span class="keyword">typename</span> P&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> : <span class="keyword">public</span> A&lt;X, P&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(X x, Z z, P p) : <span class="built_in">A</span>&lt;X, P&gt;(x) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Test</span>&lt;<span class="type">int</span>, <span class="type">double</span>, <span class="type">char</span>&gt;(<span class="built_in">int</span>(<span class="number">2</span>), <span class="built_in">double</span>(<span class="number">2.1</span>), <span class="built_in">char</span>(<span class="string">&#x27;a&#x27;</span>));</span><br></pre></td></tr></table></figure><h2 id="类模板的多态"><a href="#类模板的多态" class="headerlink" title="类模板的多态"></a>类模板的多态</h2><p>在创建对象时，分为子类没有模板和子类有模板两种。子类和父类的模板参数列表可以不一样，但一定要对应好。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ====== 测试一 ======</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Y&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">tfunc</span><span class="params">(T t, Y y)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> : <span class="keyword">public</span> A&lt;<span class="type">int</span>, <span class="type">double</span>&gt; &#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">tfunc</span><span class="params">(<span class="type">int</span> n, <span class="type">double</span> d)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类是类模板，子类是普通类，在多态情况下父类需要指定模板参数，子类就不用了</span></span><br><span class="line">A&lt;<span class="type">int</span>, <span class="type">double</span>&gt;* a = <span class="keyword">new</span> Test;</span><br><span class="line">a-&gt;<span class="built_in">tfunc</span>(<span class="number">2</span>, <span class="number">2.1</span>);</span><br><span class="line"><span class="comment">// 运行结果：2 2.1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====== 测试二 ======</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Y&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">tfunc</span><span class="params">(T t, Y y)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> X, <span class="keyword">typename</span> Z, <span class="keyword">typename</span> P&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> : <span class="keyword">public</span> A&lt;X, P&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">tfunc</span><span class="params">(X x, P p)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类是类模板，子类是类模板，在多态情况下父类和子类都需要指定模板参数</span></span><br><span class="line">A&lt;<span class="type">int</span>, <span class="type">double</span>&gt;* a = <span class="keyword">new</span> Test&lt;<span class="type">int</span>, <span class="type">char</span>, <span class="type">double</span>&gt;;</span><br><span class="line">a-&gt;<span class="built_in">tfunc</span>(<span class="number">2</span>, <span class="number">2.1</span>);</span><br><span class="line"><span class="comment">// 运行结果：2 2.1</span></span><br></pre></td></tr></table></figure><h2 id="类模板具体化"><a href="#类模板具体化" class="headerlink" title="类模板具体化"></a>类模板具体化</h2><p>按需进行，不会提前生成过多的代码。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ACL</title>
      <link href="/2022/05/25/ACL/"/>
      <url>/2022/05/25/ACL/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="ACL的定义与作用"><a href="#ACL的定义与作用" class="headerlink" title="ACL的定义与作用"></a>ACL的定义与作用</h2><p>路由器为了过滤数据包，需要配置一系列的规则，以决定什么样的数据包能够通过，这些规则就是通过访问控制列表ACL（Access Control List）定义的。访问控制列表是由permit&#x2F;deny语句组成的一系列有顺序的规则，这些规则根据数据包的源地址、目的地址、端口号等来描述。</p><p>当数据包从接口经过时，由于接口启用了ACL，此时路由器会对报文进行检查，然后做出相应的处理。</p><h2 id="访问控制列表的分类"><a href="#访问控制列表的分类" class="headerlink" title="访问控制列表的分类"></a>访问控制列表的分类</h2><ul><li>基本的访问控制列表（basic acl）：<b>只能匹配源IP地址</b></li><li>高级的访问控制列表（advanced acl）：<b>可以匹配源IP地址、目标IP、源端口、目标端口等三层和四层的字段</b></li><li>基于接口的访问控制列表（interface-based acl）</li><li>基于MAC的控制访问列表（MAC-based acl）：根据数据包的源MAC地址、目的MAC地址、802.1q优先级、二层协议类型等二层信息制定规则。</li></ul><h2 id="ACL的应用原则"><a href="#ACL的应用原则" class="headerlink" title="ACL的应用原则"></a>ACL的应用原则</h2><ul><li><b>基本ACL，尽量用在靠近目的点</b></li><li><b>高级ACL，尽量用在靠近源的地方（可以保护带宽和其他资源）</b></li><li>ACL不能过滤本地数据流</li></ul><h2 id="ACL应用规则"><a href="#ACL应用规则" class="headerlink" title="ACL应用规则"></a>ACL应用规则</h2><ul><li>一个接口的同一方向，只能调用一个ACL</li><li>一个ACL里面可以有多个rule规则，按照规则ID从小到大排序，从上往下依次执行</li><li>数据包一旦被某rule匹配，就不再继续往下匹配</li><li>如果没有匹配成功，默认deny</li></ul><h2 id="Access-list-number参数"><a href="#Access-list-number参数" class="headerlink" title="Access-list-number参数"></a>Access-list-number参数</h2><table><thead><tr><th>ACL Type</th><th>ACL Number</th></tr></thead><tbody><tr><td>IP Standard</td><td>1 to 99</td></tr><tr><td>IP Extended</td><td>100 to 199</td></tr><tr><td>AppleTalk</td><td>600 to 699</td></tr><tr><td>IPX Standard</td><td>800 to 899</td></tr><tr><td>IPX Extended</td><td>900 to 999</td></tr><tr><td>IPX SAP</td><td>1000 to 1099</td></tr></tbody></table><h2 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h2><table><thead><tr><th>Port Number</th><th>Description</th></tr></thead><tbody><tr><td>21</td><td>FTP</td></tr><tr><td>23</td><td>Telnet</td></tr><tr><td>25</td><td>SMTP</td></tr><tr><td>53</td><td>DNS</td></tr><tr><td>69</td><td>TFTP</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NAT</title>
      <link href="/2022/05/25/NAT/"/>
      <url>/2022/05/25/NAT/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="私有地址和全局地址"><a href="#私有地址和全局地址" class="headerlink" title="私有地址和全局地址"></a>私有地址和全局地址</h2><p>主机的IP地址是否必须是唯一的？</p><p>1.的确，在一开始的时候，任何一台主机或者路由器都必须配有一个唯一的IP地址。</p><p>2.但随着IP地址不足的问题日益显著，人们对IP地址做了新的处理方式：</p><ul><li>将IP地址分为私有IP地址和全局IP地址</li><li>全局IP地址必须是唯一的</li><li>私有IP地址不需要是唯一的，只要在同一个域里保持唯一便可，在不同域里可以重复</li></ul><p>私有IP地址的范围：（A&#x2F;B&#x2F;C类各有一段，一共三段）</p><p>10.0.0.0~10.255.255.255（10&#x2F;8) A类</p><p>172.16.0.0~172.31.255.255（172.16&#x2F;12）B类</p><p>192.168.0.0~192.168.255.255（192.168&#x2F;16） C类</p><h2 id="什么是NAT？"><a href="#什么是NAT？" class="headerlink" title="什么是NAT？"></a>什么是NAT？</h2><p>NAT（Network Address Translation，网络地址转换），是用于在本地网络中使用私有地址，在连接网络时转而使用全局IP地址的技术。</p><p>这种方法需要在专用网连接到因特网的路由器上安装NAT软件。装有NAT软件的路由器叫做NAT路由器，它至少有一个有效的外部全球IP地址。这样，所有使用本地地址的主机和外界通信时，都要在NAT路由器上将其本地地址转换为全球IP地址，才能和因特网连接。</p><h2 id="NAT的功能"><a href="#NAT的功能" class="headerlink" title="NAT的功能"></a>NAT的功能</h2><p>在NAT路由器内部，有一张自动生成的用于地址转换的表，当发送数据的时候，会按照表中的映射关系进行处理。</p><p>当NAT路由器具有n个全球IP地址时，专用网内最多可以同时有n台主机接入到互联网。这样就可以使专用网内较多数量的主机，轮流使用NAT路由器有限数量的全球IP地址。</p><p>通过NAT路由器的通信必须由专用网内的主机发起。专用网内部的主机不能充当服务器用，因为互联网上的客户无法请求专用网内的服务器提供服务。</p><h2 id="网络地址与端口号转换NAPT"><a href="#网络地址与端口号转换NAPT" class="headerlink" title="网络地址与端口号转换NAPT"></a>网络地址与端口号转换NAPT</h2><ul><li>为了更加有效地利用 NAT 路由器上的全球IP地址，现在常用的 NAT 转换表把运输层的<b>端口号</b>也利用上。这样，就可以使多个拥有本地地址的主机，共用一个 NAT 路由器上的全球 IP 地址，因而可以同时和互联网上的不同主机进行通信。</li><li>使用端口号的 NAT 叫做网络地址与端口号转换<b>NAPT (Network Address and Port Translation)</b>，而不使用端口号的 NAT 就叫做传统的 NAT (traditional NAT)。（也叫<b>PAT，Port Address Translation</b>）</li></ul><p>NAT不仅能<b>解决IP地址不足的问题</b>，而且还能够有效地<b>避免来自网络外部的攻击，隐藏并保护网络内部的主机</b>。把内网的私有地址，转化成外网的公有地址，使得内部网络上的（被设置为私有IP地址的）主机可以访问Internet。</p><h2 id="NAT的分类"><a href="#NAT的分类" class="headerlink" title="NAT的分类"></a>NAT的分类</h2><p>NAT分为Basic NAT和PAT：</p><ul><li>Basic NAT<b>只转化IP，不映射端口</b>。</li><li>PAT除了转化IP，还做端口映射，可以用于多个内部地主映射到少量（甚至一个）外部地址。</li></ul><p>NAT还分为静态NAT和动态NAT：</p><ul><li>静态NAT：将内部网络中的每个主机都永久映射成外部网络中的某个合法的地址，多用于服务器。</li><li>动态NAT：在外部网络中定义了一个或多个合法地址，采用动态分配的方法映射到内部网络。</li></ul><h2 id="NAT的映射方式"><a href="#NAT的映射方式" class="headerlink" title="NAT的映射方式"></a>NAT的映射方式</h2><p>对于第四层是TCP或UDP的数据报，NAT通过更改源端口号，来实现多对少的映射。</p><blockquote><p>例如：内部IP1~IP4，4个地址映射成外部一个地址IP5。</p><p>(IP1，Port1）映射成（IP5，Port1）</p><p>（IP2，Port1）映射成（IP5，Port2）</p><p>（IP3，Port2）映射成（IP5，Port3）</p><p>（IP4，Port2）映射成（IP5，Port4）</p></blockquote><p>对于ICMP包，NAT通过更改ICMP的ID，来实现多对少的映射。</p><h2 id="NAT有什么弊端"><a href="#NAT有什么弊端" class="headerlink" title="NAT有什么弊端"></a>NAT有什么弊端</h2><p>在一个具有NAT功能的路由器下的主机并没有建立真正的端对端连接，并不能参与一些因特网协议。</p><p>一些需要初始化从外部网络建立的TCP连接，和使用无状态协议（比如UDP）的服务将被中断。除非NAT路由器做一些具体的努力，否则送来的数据包将不能到达正确的地址。NAT也会使安全协议变得复杂。</p><h2 id="NAT的局限性"><a href="#NAT的局限性" class="headerlink" title="NAT的局限性"></a>NAT的局限性</h2><p>（1）NAT违反了IP地址构建模型的设计原则。IP地址结构的基础是每个IP地址均标识了一个网络的连接。Internet的软件设计就是建立在这个前提之上，而NAT使得有很多主机可能在使用相同的地址，如10.0.0.1。</p><p>（2）NAT使得IP协议从面向无连接变成面向连接。NAT必须维护专用IP地址与公用IP地址以及端口号的映射关系。在TCP&#x2F;IP协议体系中，如果一个路由器出现故障，不会影响到TCP协议的执行。因为只要几秒收不到应答，发送进程就会进入超时重传处理。而当存在NAT时，最初设计的TCP&#x2F;IP协议过程将发生变化，Internet可能变得非常脆弱。</p><p>（3）NAT违反了基本的网络分层结构模型的设计原则。因为在传统的网络分层结构模型中，第N层是不能修改第N+1层的报头内容的。NAT破坏了这种各层独立的原则。</p><p>（4）有些应用是将IP地址插入到正文的内容中，例如标准的FTP协议与IP Phone协议H.323。如果NAT与这一类协议一起工作，那么NAT协议一定要做适当地修正。同时，网络的传输层也可能使用TCP与UDP协议之外的其他协议，那么NAT协议必须知道并且做相应的修改。由于NAT的存在，使得P2P应用实现出现困难，因为P2P的文件共享与语音共享都是建立在IP协议的基础上的。</p><p>（5）NAT同时存在对高层协议和安全性的影响问题。RFC对NAT存在的问题进行了讨论。NAT的反对者认为这种临时性的缓解IP地址短缺的方案推迟了Ipv6迁移的进程，而并没有解决深层次的问题，他们认为是不可取的。</p><p><a href="https://zhuanlan.zhihu.com/p/26992935">https://zhuanlan.zhihu.com/p/26992935</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软工二设计模式</title>
      <link href="/2022/05/24/%E8%BD%AF%E5%B7%A5%E4%BA%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/05/24/%E8%BD%AF%E5%B7%A5%E4%BA%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>抽象策略（一个类的行为或者其算法）为一个接口，然后有不同的实现。</p><p>[<a href="https://ithelp.ithome.com.tw/articles/10202506"> Day 3 ] 初探設計模式 - 策略模式 (Strategy Pattern) - IT 邦幫忙::一起幫忙解決難題，拯救 IT 人的一天 (ithome.com.tw)</a></p><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>工厂提供对象的创建方法接口，程序调用接口创建对象，并不清楚对象的创建细节。</p><p>[<a href="https://ithelp.ithome.com.tw/articles/10202075"> Day 2 ] 初探設計模式 - 工廠方法模式 (Factory Method Pattern) - IT 邦幫忙::一起幫忙解決難題，拯救 IT 人的一天 (ithome.com.tw)</a></p><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>[<a href="https://ithelp.ithome.com.tw/articles/10203092"> Day 5 ] 初探設計模式 - 單例模式 (Singleton) - iT 邦幫忙::一起幫忙解決難題，拯救 IT 人的一天 (ithome.com.tw)</a></p><h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><p>为了不暴露内部细节，减少其所担负的功能，所以将迭代器独立出来。</p><p>[<a href="https://ithelp.ithome.com.tw/articles/10207704"> Day 20 ] 這樣每個月發薪水就輕鬆啦！迭代器模式 ( Iterator Pattern ) - iT 邦幫忙::一起幫忙解決難題，拯救 IT 人的一天 (ithome.com.tw)</a></p>]]></content>
      
      
      <categories>
          
          <category> 软工二 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>环回接口</title>
      <link href="/2022/05/23/%E7%8E%AF%E5%9B%9E%E6%8E%A5%E5%8F%A3/"/>
      <url>/2022/05/23/%E7%8E%AF%E5%9B%9E%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>大多数产品都支持环回接口（Loopback Interface），<b>以允许运行在同一台主机上的客户端程序和服务器通过TCP&#x2F;IP进行通信</b>。A类网络号127就是为环回接口预留的。根据惯例，大多数系统把127.0.0.1分配给这个接口，子网掩码一般建议为255.255.255.255，并命名为localhost。一个传给环回接口的IP数据包不能再任何网络上出现。（实际上，127开头的所有网络都是环回地址，只是默认会用127.0.0.1，但传给其他127开头的地址的数据最终都会到环回接口，不会进入网络）</p><p>环回接口有一个特性，除非设备瘫痪，否则其状态一直是up。这个特性对于路由协议来说非常重要。环回接口使使用广泛的一种逻辑接口。</p><p>下图为环回接口处理IP数据报的简单过程。</p><p><img src="https://box.kancloud.cn/2016-04-12_570c8933e28da.png"></p><p>图中需要指出的关键点是：</p><p>1）传给环回地址的任何数据均作为IP输入</p><p>2）传给广播地址或多播地址的数据报复制一份传给环回地址，然后送到以太网上。这是因为广播传送和多播传送的定义包含主机本身。</p><p>3）任何传给该主机IP地址的数据均送到环回接口。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>OSPF router-id可以手工指定，只要保证区域内只有一个就行，可以是设备上不存在的地址。环回接口使用可以模拟网段，或者主机地址。环回口还可以用来建立邻居，比如BGP，使邻居更稳定，即使路由器其中一个物理口down了，还可以从其他途径访问到环回口，保证邻居的稳定，以节省资源。</p><h2 id="创建环回接口的原因"><a href="#创建环回接口的原因" class="headerlink" title="创建环回接口的原因"></a>创建环回接口的原因</h2><ol><li><p>用来建立路由邻居</p><p>我们知道路由协议要想正常运行，大多需要先建立邻居关系，邻居关系的稳定是路由计算正确的基石。实际运用中，常常使用环回接口来建立两个路由器之间的邻居关系，例如BGP（Border Gateway Protocol，边界网关协议）协议。比起使用物理接口建立连接，使用环回接口可以使邻居关系更加牢固，因为就算某个物理链路和接口发生了故障，只要能从其他途径访问到该设备，那么邻居关系就不会中断。</p></li><li><p>用来作为Router-ID</p><p>在常用的OSPF、BGP等路由协议中，都有Router-ID的概念，这相当于一台路由器的身份证号，在一个指定的范围（如一个自治系统）内只能标识一台设备，不能有重复。因为环回接口的稳定性，我们常使用一个环回接口地址来作为Router-ID，使整个设备的标识稳定可靠。使用环回接口作为Router-ID还有一个好处就是可以节省地址，因为环回接口的地址一般和业务地址没有关系，是独立规划的。</p></li><li><p>用于虚拟隧道连接</p><p>在建立IPSec或GRE之类的虚拟隧道时，使用loopback接口可以保证整个隧道的稳定性。</p></li><li><p>用于网络连通性测试</p><p>创建并配置好环回接口之后，它的地址是能被ping或telnet的，这就可以被用来测试网络的连通性。</p></li></ol><p>在Cisco路由器中可以使用interface loopback命令来创建它。</p><p>注意：启动OSPF路由选择进程时会选择OSPF的路由器ID。这发生在手动执行了router ospf命令或者在启动过程中加载路由器配置时。因此，如果在启用了OSPF之后再创建环回接口，那么该环回接口将不会被用作路由器ID；然而，如果重新启动路由器，默认将使用环回接口。因此，建议优先创建环回接口并先给它分配IP地址，然后再启用OSPF，这样可以消除关于路由器ID的困惑。 [2] </p><p>以下为配置环回接口的指令：</p><p>Router(config)#interface loopback<em>number</em></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软工二--软件设计基础</title>
      <link href="/2022/05/23/%E8%BD%AF%E5%B7%A5%E4%BA%8C-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/05/23/%E8%BD%AF%E5%B7%A5%E4%BA%8C-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="软件设计基础"><a href="#软件设计基础" class="headerlink" title="软件设计基础"></a>软件设计基础</h1><h2 id="软件设计的核心思想"><a href="#软件设计的核心思想" class="headerlink" title="软件设计的核心思想"></a>软件设计的核心思想</h2><p>软件设计的核心思想是抽象和分解。分解（decomposition）是将系统分割成几个相对简单的子系统以及各子系统之间的关系；抽象（abstraction）是纵向上聚焦各子系统的接口。</p><h2 id="软件设计的演化性"><a href="#软件设计的演化性" class="headerlink" title="软件设计的演化性"></a>软件设计的演化性</h2><p>真正的设计分离了使用和实现，分离了外部表现和内部结构。设计过程总是先根据外部表现进行初步设计，主要目的是保证设计与需求规格相符，所以简称为需求分配。需求分配之后再强调实现的内部结构是否具有坚固性和美感，简称为质量反思。质量反思可能会发现外部表现的设计需要调整，于是两个步骤会反复迭代，知道最后的设计很好地兼顾了功效、坚固和美感三个方面。</p><h2 id="软件设计的分层"><a href="#软件设计的分层" class="headerlink" title="软件设计的分层"></a>软件设计的分层</h2><p>p139图</p><p>在设计过程中，按照抽象和分解的思想，一般先进行高层设计，接着进行中层设计，最后完成低层设计。体系结构设计阶段主要完成高层设计和部分中层设计。相机设计阶段主要完成中层设计和部分低层设计。部分底层设计是在构造阶段完成的。</p><h2 id="软件设计的方法和模型"><a href="#软件设计的方法和模型" class="headerlink" title="软件设计的方法和模型"></a>软件设计的方法和模型</h2><p>结构化设计、面向对象设计、数据结构为中心设计、基于构件的设计、形式化方法设计。</p><p>静态模型和动态模型。静态模型通过快照的方式对系统进行描述，通常描述的是状态，而不是行为。动态模型通常描述的是系统行为和状态转移。</p><p>在结构化设计中，人们通常使用实体关系图、数据流图和结构图来描述软件设计方案，实体关系图描述静态模型，数据流图和结构图描述动态模型。</p><p>在面型对象设计中，人们使用UML来描述软件设计的方案。其中，静态模型通常使用类图、对象图、构件图、部署图；动态模型通常使用交互图（顺序图和通信图）、状态图、活动图等。</p><h2 id="软件设计文档的书写"><a href="#软件设计文档的书写" class="headerlink" title="软件设计文档的书写"></a>软件设计文档的书写</h2><p>lab</p><h1 id="软件体系结构基础"><a href="#软件体系结构基础" class="headerlink" title="软件体系结构基础"></a>软件体系结构基础</h1><p>软件体系结构&#x3D;部件（component），连接件（connector），配置（configuration）</p><ul><li>部件是软件体系结构的基本组成单元之一，承载系统的主要功能，包括处理与数据</li><li>连接件是软件体系结构的另一个基本组成单位，定义了部件间的交互，是连接的抽象表示</li><li>配置是对“形式“的发展，定义了部件以及连接件之间的关联方式，将它们组织成系统的总体结构。</li></ul><p>软件体系结构定义：一个软件系统的体系结构规定了系统的计算部件和部件之间的交互。</p><p>注意：</p><p>1）连接件是一个与部件平等的单位。</p><p>2）部件与连接件是比类、模块等软件单位更高层次的抽象。</p><p>3）配置将部件和连接件整合起来，构成系统的整体结构，达到系统的设计目标</p><h2 id="体系结构风格初步"><a href="#体系结构风格初步" class="headerlink" title="体系结构风格初步"></a>体系结构风格初步</h2><ul><li><p>主程序&#x2F;子程序风格</p></li><li><p>面向对象式风格</p></li><li><p>分层风格</p><p>展示层、逻辑层、数据层</p></li><li><p>MVC风格（Model-View-Control，模型-视图-控制）</p><p>模型封装了系统的数据和状态信息，实现业务逻辑，对外提供数据服务和执行业务逻辑。试图封装了用户交互，提供业务展现，接受用户行为。控制封装了系统的控制逻辑，根据用户行为调用需要执行的业务逻辑和数据更新，并且根据执行后的系统状态决定后续的业务实现。</p></li></ul><h1 id="软件体系结构设计与构建"><a href="#软件体系结构设计与构建" class="headerlink" title="软件体系结构设计与构建"></a>软件体系结构设计与构建</h1><h2 id="体系结构设计过程"><a href="#体系结构设计过程" class="headerlink" title="体系结构设计过程"></a>体系结构设计过程</h2><p>1.分析关键需求和项目约束</p><p>2.选择体系结构风格</p><p>3.渐渐体系结构逻辑设计</p><p>​    3.1.依据概要功能需求与体系结构风格建立初始设计</p><p>​3.2.使用非功能性需求与项目约束评价和改进初始设计</p><p>4.软件体系结构实现</p><p>​4.1.开发包（构件）设计</p><p>​4.2.运行时的进程</p><p>​4.3.物理部署</p><p>5.完善体系结构设计</p><p>6.定义构建接口</p><h2 id="体系结构集成与测试"><a href="#体系结构集成与测试" class="headerlink" title="体系结构集成与测试"></a>体系结构集成与测试</h2><h3 id="集成"><a href="#集成" class="headerlink" title="集成"></a>集成</h3><p>1.大爆炸继承</p><p>2.自顶向下继承</p><p>3.自底向上集成</p><p>4.持续集成</p><h3 id="桩、驱动与集成测试用例"><a href="#桩、驱动与集成测试用例" class="headerlink" title="桩、驱动与集成测试用例"></a>桩、驱动与集成测试用例</h3><p>桩模仿的是下层模块，用来测试上层。而驱动则模仿的是上层模块，用来测试下层。</p><h3 id="软件体系结构设计文档描述"><a href="#软件体系结构设计文档描述" class="headerlink" title="软件体系结构设计文档描述"></a>软件体系结构设计文档描述</h3><p>lab</p><h1 id="人机交互设计"><a href="#人机交互设计" class="headerlink" title="人机交互设计"></a>人机交互设计</h1><p>略</p><h1 id="详细设计的基础"><a href="#详细设计的基础" class="headerlink" title="详细设计的基础"></a>详细设计的基础</h1><h2 id="详细设计出发点"><a href="#详细设计出发点" class="headerlink" title="详细设计出发点"></a>详细设计出发点</h2><p>软件详细设计在软件体系结构设计之后进行，以需求开发的结果（需求规格说明和需求分析的模型）和软件体系结构的结果（软件体系结构设计方案与原型）为出发点。</p><p>需求开发明确了用户的功能性需求和非功能性需求；软件体系结构设计选择了风格和整体的框架性日系结构；详细设计就可以同时利用已有的需求和体系结构，对结构中的具体构建再进一步设计细化。这样做的好处是对于一个复杂系统来说，工程师同一时刻只关注某一层次的细节，从而使得设计的复杂度大大降低。</p><p>在体系结构设计中主要关注的是高层设计，是基于反应软件高层抽象的构建层次，描述系统的高层结构、关注点和设计决策。而在详细设计中一般进行中层设计和低层设计。中层设计更加关注组成模块的内部结构，如数据定义、函数定义、类定义、类结构等。低层设计则深入模块和类的内部，关注具体的数据结构、算法、类型、语句和控制结构等。</p><h2 id="详细设计的上下文"><a href="#详细设计的上下文" class="headerlink" title="详细设计的上下文"></a>详细设计的上下文</h2><p>详细设计的目的是实现所有功能性需求和非功能性需求，所以要以需求作为详细设计的方向指引（即需求驱动），不断细化设计框架的各个构建，使其能够满足各种细节的功能性需求和非功能性需求（而非仅仅是概要功能需求与关键性非功能需求）</p><p>详细设计文档中需要明确定义：</p><ul><li>模块结构及其接口（如果有更细节的模块分解）</li><li>类结构、类的协作、类接口（面向对象分析方法）</li><li>控制结构与函数接口（结构化分析方法）</li><li>重要的数据结构和算法逻辑（如果有必要的话）</li></ul><h2 id="结构化设计"><a href="#结构化设计" class="headerlink" title="结构化设计"></a>结构化设计</h2><p>略</p><h2 id="面向对象设计"><a href="#面向对象设计" class="headerlink" title="面向对象设计"></a>面向对象设计</h2><ul><li><p>抽象对象的职责</p></li><li><p>抽象类之间的关系</p><p>依赖：        A use a B               虚线鱼骨箭头</p><p>普通关联：A has a B               实线鱼骨箭头</p><p>聚合：        A owns B               实线空心方块头</p><p>组合：        B is a part of A     实线实心方块头</p><p>继承：        B is A                     实现空心三角头</p><p>实现：        B implements A   虚线空心三角头</p></li><li><p>添加辅助类</p><p>接口类、记录类、启动类、控制器类、实现数据类型的类、容器类</p></li><li><p>通过协作建立动态模型</p><p>同步消息：实线实心三角箭头（发送者等候直到消息返回）</p><p>异步消息：实线鱼骨箭头（发送者在消息发送后继续执行）</p><p>同步消息返回：虚线鱼骨箭头（接收同步消息者执行结束后，返回消息给发送者）</p><p>（<em><strong>顺序图</strong></em>）</p></li><li><p>为类间协作开发集成测试用例</p></li></ul><h2 id="详细设计文档描述"><a href="#详细设计文档描述" class="headerlink" title="详细设计文档描述"></a>详细设计文档描述</h2><p>略</p><h1 id="详细设计中的模块化与信息隐藏"><a href="#详细设计中的模块化与信息隐藏" class="headerlink" title="详细设计中的模块化与信息隐藏"></a>详细设计中的模块化与信息隐藏</h1><p>略</p><h1 id="详细设计中面向对象方法下的模块化"><a href="#详细设计中面向对象方法下的模块化" class="headerlink" title="详细设计中面向对象方法下的模块化"></a>详细设计中面向对象方法下的模块化</h1><p>lue~</p>]]></content>
      
      
      <categories>
          
          <category> 软工二 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软工二 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DTE和DCT的概念及区别</title>
      <link href="/2022/05/23/DTE%E5%92%8CDCT%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%8C%BA%E5%88%AB/"/>
      <url>/2022/05/23/DTE%E5%92%8CDCT%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>DTE是数据终端设备（Data Terminal Equipment），如终端，是广义的概念，PC也可以是终端。（一般广域网常用DTE设备有：路由器，终端主机）<br>DCE是数据通信设备（Data Circuit Terminating Equipment），如MODEM，连接DTE设备的通信设备。（一般广域网常用DCE设备有：CSU&#x2F;DSU，广域网交换机，MODEM）</p><h2 id="DCE和DTE的区别"><a href="#DCE和DTE的区别" class="headerlink" title="DCE和DTE的区别"></a>DCE和DTE的区别</h2><p>DCE一方提供时钟，DTE不提供时钟，但它依靠DCE提供的时钟工作，比如PC机和MODEM之间。数据传输通常是经过DTE-DCE，再经过DCE-DTE的路径。对于标准的串行端口，通常从外观就能判断是DTE还是DCE：DTE是针头（俗称公头），DCE是孔头（俗称母头），这两种接口才能接在一起。 一般是用于接口的区分，比如一台路由器，它处于网络的边缘，它有一个S0口需要从另一台路由器中学习到一些参数，具体实施时，我们就不需在这个S0口配“时钟速率”，它从对方学到。这时它就是DTE，而对方就是DCE。</p><p>router之间用串口连在一起的时候一般无所谓哪头接DCE，哪头接DTE。一般是核心层做DCE。有的是默认规定好的，比如modem永远是DCE，与其相连的电信程控交换机则为DTE，配的时候DCE不设clock rate的话，无法通信。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DHCP</title>
      <link href="/2022/05/23/DHCP/"/>
      <url>/2022/05/23/DHCP/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>DHCP（Dynamic Host Configuration Protocol，动态主机配置协议）为局域网中的工作站动态分配IP地址，而不需要每个用户去设置静态IP。</p><span id="more"></span><h2 id="DHCP工作原理"><a href="#DHCP工作原理" class="headerlink" title="DHCP工作原理"></a>DHCP工作原理</h2><p>DHCP从一个IP地址池中提供IP地址，该池由DHCP服务器数据库定义。如果客户端接受这一地址，则它可在一个预定义的期限内使用该地址，称为租约。如果客户端无法从DHCP服务器获取IP地址，它就无法正常初始化TCP&#x2F;IP。</p><p>在DHCP为客户端配置TCP&#x2F;IP参数时，DHCP服务器和客户端都要经历四个步骤。很多通讯是通过广播的方式来完成的。</p><p><img src="https://pic1.zhimg.com/v2-22d46706777e40ed44e9c7a4a36e94f4_b.jpg"></p><ul><li>UDP:封装，服务器&#x3D;67，客户端&#x3D;68<ul><li>UDP数据报协议</li></ul></li><li>DHCP欺骗与防范</li></ul><ol><li><p>DHCP Client以<b>广播</b>的方式发出DHCP Discover报文。</p></li><li><p>所有的DHCP Server都能够接收到DHCP Client发送的DHCP Discover报文，所有的DHCP Server都会给出相应，向DHCP Client发送一个DHCP Offer 报文。</p><p>DHCP Server在发出此报文后会存在一个已分配IP地址的记录。</p></li><li><p>DHCP Client只能处理其中一个DHCP Offer报文，一般的原则是DHCP Client处理最先收到的DHCP Offer报文。</p><p>DHCP Client会发出一个<b>广播</b>的DHCP Request报文，在选项字段加入选中的DHCP SERVER的IP地址和需要的IP地址。</p></li><li><p>DHCP Server收到DHCP Request报文后，判断选项字段中的IP地址是否与自己的地址相同。如果不相同，DHCP Server不做任何处理只清除相应IP地址分配记录；如果相同，DHCP Server就会向DHCP Client响应一个DHCP ACK报文，并在选项字段中增加IP地址的使用租期信息。</p></li><li><p>DHCP Client接收到DHCP ACK报文后，检查DHCP Server分配的IP地址是否能够使用。如果可以使用，则DHCP Client成功获得IP地址并根据IP地址使用租期自动启动续延过程；如果DHCP Client发现分配的IP地址已经被使用，则DHCP Client向DHCPServer发出DHCP Decline报文，通知DHCP Server禁用这个IP地址，然后DHCP Client开始新的地址申请过程。</p></li><li><p>DHCP Client在成功获取IP地址后，随时可以通过发送DHCP Release报文释放自己的IP地址，DHCP Server收到DHCP Release报文后，会回收相应的IP地址并重新分配。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详细设计的设计模式</title>
      <link href="/2022/05/22/%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/05/22/%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2>]]></content>
      
      
      <categories>
          
          <category> 软工二 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 软工二 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详细设计中面向对象方法下的信息隐藏</title>
      <link href="/2022/05/22/%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1%E4%B8%AD%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95%E4%B8%8B%E7%9A%84%E4%BF%A1%E6%81%AF%E9%9A%90%E8%97%8F/"/>
      <url>/2022/05/22/%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1%E4%B8%AD%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95%E4%B8%8B%E7%9A%84%E4%BF%A1%E6%81%AF%E9%9A%90%E8%97%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><ul><li>封装类的职责，隐藏职责的实现</li><li>预计将会发生的变更，抽象它的接口，隐藏它的内部机制</li></ul><h2 id="封装类的职责"><a href="#封装类的职责" class="headerlink" title="封装类的职责"></a>封装类的职责</h2><p>封装——分离接口与实现</p><h3 id="封装实现的细节"><a href="#封装实现的细节" class="headerlink" title="封装实现的细节"></a>封装实现的细节</h3><h4 id="封装数据和行为"><a href="#封装数据和行为" class="headerlink" title="封装数据和行为"></a>封装数据和行为</h4><p>使用getter和setter</p><h4 id="封装内部结构"><a href="#封装内部结构" class="headerlink" title="封装内部结构"></a>封装内部结构</h4><p>不能暴露内部数据结构的实现</p><h4 id="封装对其他对象的引用"><a href="#封装对其他对象的引用" class="headerlink" title="封装对其他对象的引用"></a>封装对其他对象的引用</h4><p>如：设计模式中的代理模式、中介模式</p><h4 id="封装类型信息"><a href="#封装类型信息" class="headerlink" title="封装类型信息"></a>封装类型信息</h4><p>隐藏具体子类型的类别，只需要知道其共性类别</p><h4 id="封装潜在变更"><a href="#封装潜在变更" class="headerlink" title="封装潜在变更"></a>封装潜在变更</h4><p>如果预计类的实现中有特定地方会发生变更，就应该将其独立为单独的类或者方法，然后为单独的类或方法抽象建立稳定的接口，并在原类中使用该稳定接口以屏蔽潜在变更的影响。</p><h2 id="为变更而设计"><a href="#为变更而设计" class="headerlink" title="为变更而设计"></a>为变更而设计</h2><h3 id="封装变更-x2F-开闭原则"><a href="#封装变更-x2F-开闭原则" class="headerlink" title="封装变更&#x2F;开闭原则"></a>封装变更&#x2F;开闭原则</h3><p>对扩展开放，对修改关闭</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>不同类型的值能够通过统一的接口来操纵。</p><h3 id="依赖倒置原则（DIP）"><a href="#依赖倒置原则（DIP）" class="headerlink" title="依赖倒置原则（DIP）"></a>依赖倒置原则（DIP）</h3><p>利用DIP减少耦合</p>]]></content>
      
      
      <categories>
          
          <category> 软工二 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面向对象 </tag>
            
            <tag> 软工二 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详细设计中面向对象方法下的模块化</title>
      <link href="/2022/05/22/%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1%E4%B8%AD%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95%E4%B8%8B%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
      <url>/2022/05/22/%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1%E4%B8%AD%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95%E4%B8%8B%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>模块化希望代码片段由两部分组成：接口和实现。同时，也希望各个模块之间尽可能独立（低耦合），希望集中信息与行为（高内聚）。</p><span id="more"></span><h2 id="访问耦合"><a href="#访问耦合" class="headerlink" title="访问耦合"></a>访问耦合</h2><p>类型：隐式访问（连点）、实现中访问、成员变量访问、参数变量访问、无访问</p><h3 id="降低访问耦合的方法"><a href="#降低访问耦合的方法" class="headerlink" title="降低访问耦合的方法"></a>降低访问耦合的方法</h3><p>1.针对接口编程</p><p>2.接口最小化&#x2F;接口分离原则</p><p>3.访问耦合的合理范围&#x2F;迪米特法则</p><h2 id="继承耦合"><a href="#继承耦合" class="headerlink" title="继承耦合"></a>继承耦合</h2><p>类型：修改、精化、扩展、无</p><h3 id="降低继承耦合的方法"><a href="#降低继承耦合的方法" class="headerlink" title="降低继承耦合的方法"></a>降低继承耦合的方法</h3><p>1.Liskov替换原则（里氏替换原则，LSP）</p><p>2.使用组合代替继承</p><h2 id="内聚"><a href="#内聚" class="headerlink" title="内聚"></a>内聚</h2><p>类型：功能内聚、通信内聚、过程内聚、时间内聚、逻辑内聚、偶然内聚</p><p>衡量标准：方法和属性是否一致、属性之间是否体现一个职责、属性之间是否可以抽象</p><h3 id="提高内聚的方法"><a href="#提高内聚的方法" class="headerlink" title="提高内聚的方法"></a>提高内聚的方法</h3><p>1.集中信息与行为</p><p>2.单一职责原则（SRP）</p><h2 id="耦合与内聚的度量"><a href="#耦合与内聚的度量" class="headerlink" title="耦合与内聚的度量"></a>耦合与内聚的度量</h2><h3 id="耦合的度量"><a href="#耦合的度量" class="headerlink" title="耦合的度量"></a>耦合的度量</h3><h4 id="1-方法调用耦合"><a href="#1-方法调用耦合" class="headerlink" title="1.方法调用耦合"></a>1.方法调用耦合</h4><p>CBO（Coupling Between Objects）计算一个类与外界的耦合度，包括两个部分：①该类调用其他类的成员方法的数量；②其他类访问这个类的成员方法的数量。外界的其他类不包括存在继承关系的类。</p><h4 id="2-访问耦合"><a href="#2-访问耦合" class="headerlink" title="2.访问耦合"></a>2.访问耦合</h4><p>DAC（Data Abstraction Coupling）统计一个类包含的其他类的实例的数量，不包括继承关系带来的实例引用。任何抽象数据类型中由其他抽象数据类型作为成员，就构成抽象数据类型的耦合。</p><p>DAC越小越好，如果发现一个类的DAC过大，则需要慎重处理。</p><h4 id="3-继承耦合"><a href="#3-继承耦合" class="headerlink" title="3.继承耦合"></a>3.继承耦合</h4><p>NOC（Number of Children）统计直接所属的子类的数目。当NOC变大的时候，服用增加了，抽象也变弱了。</p><p>理论上说，NOC越大越好。因为NOC越大意味着继承机制减少耦合的小伙越强，服用海马的程度也越高。但NOC越大也意味着父类越难抽象、越脆弱。如果NOC较高（超过3），就要审查继承机制的正确性，保证其能够遵守LSP。</p><p>DIT（Depth of the Inheritance Tree）统计从继承树的根节点到叶节点的长度。DIT同NOC类似，越大越好。实际适中（3以上审查）。</p><h3 id="内聚的度量"><a href="#内聚的度量" class="headerlink" title="内聚的度量"></a>内聚的度量</h3><p>连通图，略。</p>]]></content>
      
      
      <categories>
          
          <category> 软工二 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面向对象 </tag>
            
            <tag> 模块化与信息隐藏 </tag>
            
            <tag> 软工二 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VLAN</title>
      <link href="/2022/05/22/VLAN/"/>
      <url>/2022/05/22/VLAN/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-为什么需要VLAN"><a href="#1-为什么需要VLAN" class="headerlink" title="1. 为什么需要VLAN"></a>1. 为什么需要VLAN</h2><p>需要将网络分割成多个广播域，减少网络带宽和CPU算力的大量无谓消耗。</p><p>在网络中，广播帧回非常频繁地出现，除了ARP之外，还有DHCP、RIP等很多其他类型的广播信息。</p><p>ARP请求：Address Resolution Protocol，地址解析协议，建立IP和MAC地址的映射关系。</p><p>RIP： Routing Information Protocol，路由信息协议，采用距离向量计算。</p><p>DHCP：Dynamic Host Configuration Protocol，动态主机配置协议，用于自动设定IP地址的协议。</p><p>通常情况下，路由器上不会有太多的网络接口，其数目多在1~4个左右。随着宽带连接的普及，宽带路由器（或者叫IP共享器）变得较为常见。但需要注意的是，它们上面虽然带着多个（一般为4个）连接LAN一侧的网络接口，但那其实是路由器内置的交换机，并不能分割广播域。</p><p>况且使用路由器分割广播域的话，所能分割的个数完全取决于路由器的网络接口个数，使得用户无法自由地根据实际需要分割广播域。</p><p>与路由器相比，二层交换机一般带有多个网络接口。因此如果能使用它分割广播域，那么无疑运用上的灵活性会大大提高。</p><p>用于在二层交换机上分割广播域的技术，就是VLAN。通过利用VLAN，我们可以自由设计广播域的构成，提高网络设计的自由度。</p><h2 id="2-实现VLAN的机制"><a href="#2-实现VLAN的机制" class="headerlink" title="2. 实现VLAN的机制"></a>2. 实现VLAN的机制</h2><p>在一台未设置任何VLAN的二层交换机上，任何广播帧都会被转发给除接收端口外的所有其他端口（Flooding）。</p><p>这是如果将端口配置不同的VLAN，这样在转发的时候就只会转发给特定VLAN端口，分割了广播域。在实际使用中，不同VLAN用“VLAN ID”来区分。</p><p>在交换机上设置VLAN，可以看作将一台交换机换做多台虚拟的交换机，这些逻辑上的交换机是互不相通的。因此，在交换机上设置VLAN后，如果未做其他处理，VLAN间是<strong>无法通信</strong>的。</p><p>那么，如果需要在不同的VLAN间通信时又该怎么办呢？</p><p>请注意一下，VLAN是广播域，而通常两个广播域之间由路由器连接，广播域之间来往的数据包都是由路由器中继的。因此，VLAN间的通信也需要路由器提供中继服务，这被称作“VLAN间路由”。VLAN间路由可以使用普通的路由器，也可以使用三层交换机。</p><h2 id="3-VLAN的访问链接（Access-Link）"><a href="#3-VLAN的访问链接（Access-Link）" class="headerlink" title="3. VLAN的访问链接（Access Link）"></a>3. VLAN的访问链接（Access Link）</h2><p>交换机的端口，可以分成一下两种：</p><ul><li>访问链接（Access Link）</li><li>汇聚链接（Trunk Link）</li></ul><h3 id="访问链接"><a href="#访问链接" class="headerlink" title="访问链接"></a>访问链接</h3><p>访问链接，指的是“只属于一个VLAN，且仅向该VLAN转发数据帧”的端口。在大多数情况下，访问链接所连的是客户机。</p><p>通常设置VLAN的顺序是：</p><p>（1）生成VLAN</p><p>（2）设定访问链接（决定各端口属于哪一个VLAN）</p><p>设定</p><p>访问链接的手法，可以是事先固定的，也就是静态VLAN，也可以是根据所连计算机而动态改变设定，也就是动态VLAN。</p><h4 id="静态VLAN–基于端口"><a href="#静态VLAN–基于端口" class="headerlink" title="静态VLAN–基于端口"></a>静态VLAN–基于端口</h4><p>静态VLAN又被称为基于端口的VLAN（PortBased VLAN）。顾名思义，就是明确指定各端口所属的VLAN的设定方法。</p><h4 id="动态VLAN"><a href="#动态VLAN" class="headerlink" title="动态VLAN"></a>动态VLAN</h4><p>动态VLAN是根据每个端口所连的计算机，随时改变端口所属的VLAN。动态VLAN大致分为3类：</p><ul><li>基于MAC地址的VLAN（MAC Based VLAN）（第二层）</li><li>基于子网的VLAN（Subnet Based VLAN）（第三层）</li><li>基于用户的VLAN（User Based VLAN）（第四层以上）</li></ul><p>其间的差异，主要在于根据OSI参照模型哪一层的信息决定端口所属的VLAN。</p><h2 id="4-VLAN的汇聚链接"><a href="#4-VLAN的汇聚链接" class="headerlink" title="4. VLAN的汇聚链接"></a>4. VLAN的汇聚链接</h2><p>当需要设置多台交换机的VLAN时，即每个用户分散在较远的地方，这时候就需要考虑如何跨越多台交换机设置VLAN的问题了。当然，可以在交换机的端口中新开出VLAN端口，将两台交换机的端口相连（类似于串联），但是这个方法从扩展性和管理效率来看都不好，VLAN越多，交换机间所需链接的端口就越多，对端口的利用率下降，布线也可能需要调整，限制了网络的扩展。</p><p>为了避免这种低效率的连接方式，人们想办法让交换机间互联的网线集中到一根上，这时候使用的就是汇聚链接（Trunk Link）。</p><p>汇聚链接（Trunk Link）就是指能够转发多个不同VLAN通信的端口。汇聚链路上流通的数据帧，都被附加了用于识别分别属于哪个VLAN的特殊信息。网线使用普通的UTP线，交换机间互联使用交叉线。</p><p>通过汇聚链路时附加的VLAN识别信息，有可能支持标准的“IEEE 802.1Q”协议，也可能时Cisco独有的协议。在设定汇聚链接时，有一个前提就是必须支持100Mbps以上的传输速度。</p><p>在默认条件下，汇聚链接会转发交换机上存在的所有VLAN数据，为了减轻交换机的负担，同时也为了减少对带宽的浪费，可以通过用户设定限制能够经由汇聚链路互联的VLAN。</p><h2 id="5-VLAN间路由"><a href="#5-VLAN间路由" class="headerlink" title="5. VLAN间路由"></a>5. VLAN间路由</h2><p>两台计算机即使连接在同一台交换机上，只要所属的VLAN不同，就无法通信。这是因为LAN内的通信必须在数据帧头部指定通信目标的MAC地址，而为了获取MAC地址，TCP&#x2F;IP协议下使用的是ARP。ARP解析MAC地址的方法是通过广播，也就是说，如果广播报文无法到达，那么就无从解析MAC地址，亦无法直接通信。</p><p>为了能在VLAN间通信，需要利用OSI参照模型中更高一层——网络层的信息（IP地址）来进行路由。</p><h3 id="使用路由器进行VLAN间路由"><a href="#使用路由器进行VLAN间路由" class="headerlink" title="使用路由器进行VLAN间路由"></a>使用路由器进行VLAN间路由</h3><p>在使用路由器进行VLAN间路由时，与构建横跨多台交换机的VLAN时的情况类似，我们还是会遇到“该如何连接路由器与交换机”这个问题。路由器和交换机的接线方式，大致有以下两种：</p><p>(1)将路由器与交换机上的每个VLAN分别连接</p><p>(2)不论VLAN有多少个，路由器与交换机都只用一条网线连接</p><p>如果将路由器与交换机上的每个VLAN分别连接，将交换机上用于和路由器互联的每个端口设为访问链接（Access Link），然后分别用网线与路由器上的独立端口互联。这样扩展性会有问题。</p><p>当只用一条网线连接时，需要用到汇聚链接（Trunk Link），而路由器上的端口也必须支持汇聚链路，协议必须相同。</p><p>相同VLAN中两台主机的通信可能不经过路由器，进行VLAN间的通信，即使通信双方都连接在同一台交换机上，也必须经过：“发送方–交换机–路由器–交换机–接收方”这样一个流程。</p><p>三层交换机的内容略。</p><h2 id="6-使用VLAN设计局域网"><a href="#6-使用VLAN设计局域网" class="headerlink" title="6.使用VLAN设计局域网"></a>6.使用VLAN设计局域网</h2><p>略。</p><p><a href="https://zhuanlan.zhihu.com/p/35616289">VLAN 基础知识 - 知乎 (zhihu.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计网 </tag>
            
            <tag> 交换机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STP协议</title>
      <link href="/2022/05/22/STP%E5%8D%8F%E8%AE%AE/"/>
      <url>/2022/05/22/STP%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>STP（Spanning Tree Protocol，生成树协议）是数据链路层的管理协议，发送<b>BPDU帧</b>，通过有选择性地阻塞网络冗余链路来达到消除网络环路地目的，同时具有链路冗余备份地功能。</p><span id="more"></span><p><a href="http://www.360doc.com/content/22/0410/08/73220646_1025683071.shtml">http://www.360doc.com/content/22/0410/08/73220646_1025683071.shtml</a><br><a href="https://baijiahao.baidu.com/s?id=1717844500187898757&amp;wfr=spider&amp;for=pc">https://baijiahao.baidu.com/s?id=1717844500187898757&amp;wfr=spider&amp;for=pc</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计网 </tag>
            
            <tag> 交换机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RIP与OSPF</title>
      <link href="/2022/05/21/RIP%E4%B8%8EOSPF/"/>
      <url>/2022/05/21/RIP%E4%B8%8EOSPF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>计算机网络课程总结–RIP与OSPF<a href="https://wulc.me/2016/12/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93--RIP%E4%B8%8EOSPF/">https://wulc.me/2016/12/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93--RIP%E4%B8%8EOSPF/</a></p><span id="more"></span><h1 id="RIP"><a href="#RIP" class="headerlink" title="RIP"></a>RIP</h1><h2 id="RIP协议"><a href="#RIP协议" class="headerlink" title="RIP协议"></a>RIP协议</h2><p>路由信息协议（Routing Information Protocol，RIP）是一种采用距离向量算法的路由协议。</p><p>到目的网络的距离以跳为单位，最大距离为15，距离16表示无穷大，即目的网络不可达。正式这一规定限制了RIP的适用范围，是RIP局限于小型的局域网络中。</p><p>初始时每个RIP路由器只有到直连网的路由，他们的距离为1。每30sRIP路由器把它的整个路由表发送给邻居，具体实现时每个邻居会错开发送，30s的时间也会随机变化一点。当收到邻居发来的路由表（update packet），路由器将更新它的路由表&lt;目的网络，开销，下一跳&gt;：</p><p><b>（1）收到的路由的距离全部加1</b></p><p><b>（2）利用下述规则修改路由表：</b></p><ul><li><b>把路由表中不存在的路由加入路由表。</b></li><li><b>如果比路由表中的路由距离更小，则更新该路由的距离为新距离，并把下一跳改为邻居。</b></li><li><b>如果路由存在，就要重置失效定时器。</b></li></ul><p>RIP路由表中每一项都有TTL（Time-To-Live），用失效定时器（invalid timer）计时，超时则让该路由失效。</p><h2 id="RIP协议的问题"><a href="#RIP协议的问题" class="headerlink" title="RIP协议的问题"></a>RIP协议的问题</h2><p>慢收敛问题（slow convergence）：</p><p><img src="https://img-blog.csdn.net/2018062420065145?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L04xbmVEaW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p><p>慢收敛是RIP相对于OSPF而言的，就是RIP依靠定时器进行30s一次的周期更新路由器的路由表，但当网络拓扑结构发生变化时，它收敛于新拓扑的速度慢，就有可能导致环路的产生，使错误数据重复发送。</p><h2 id="RIP协议的技术"><a href="#RIP协议的技术" class="headerlink" title="RIP协议的技术"></a>RIP协议的技术</h2><p>1.水平分割技术（split horizon）：从一个接口学来的路由不会从该接口发回去。</p><p>2.毒性反转技术（poison reverse）：当一条路由变为无效之后，路由器并不立即将它从路由表中删除，而是将其距离改为16之后广播给邻居，使邻居所拥有的该路由器立即失效，而不是等待TTL到期后删除，以迅速消除路由环路，这种方法称为毒性反转，距离为16的路由称为毒化路由（poisoned route）。</p><p>3.抑制技术（hold down）：距离被改为无穷大的路由在一段时间（180s）内其距离不允许被修改。</p><p>4.触发更新（trigger update）：一旦出现路由变化将立即把增加或更新的路由发送给邻居。原有的30s发一次完整的路由表依然不变。</p><h2 id="RIP计时器"><a href="#RIP计时器" class="headerlink" title="RIP计时器"></a>RIP计时器</h2><ol><li><p>更新定时器（update timer）控制一个路由器如何定期把路由表发送给邻居。默认时间为30s。</p></li><li><p>一个路由的失效定时器（Invalid timer）到期时它将被标记为无效路由（距离改为16）。每次更新该路由时其失效定时器都会被复位。默认值为180s。</p></li><li><p>一个路由的清除定时器（flush timer）到期时将从路由表中删除。默认值为240s。</p></li><li><p>抑制定时器（hold-down timer）是在路由的距离变为无穷大（包括收到毒化路由）时启动并在其到期之前不允许修改该路由的距离。默认值为180s。</p></li></ol><p>RIP协议对清除过时路径的处理是采用了两个定时器：超时(路由无效)计时器和垃圾收集(路由刷新)计时器。</p><p>路由器对表中的每个项目都设置两个计时器，每增加一个新路由条目，就相应的增加两个计时器。当新的路由条目被装入到路由表中时，超时计时器被初始化为<em>0</em>，并开始计数。每当收到包含该路由条目的RIP消息，该条目的超时计时器就被重新设置为0。</p><p>如果在180秒内没有接收到包含该路由条目的RIP消息，该路由的度量就被设置为16，而启动该路由的垃圾收集计时器。如果在接下来的60秒，仍没有收到该路由的RIP消息，该路由就从路由表中删除。如果在垃圾收集计时器到240秒之前，收到了包含路由的消息，路由条目被装入到路由表中，计时器被清0并重新启动超时计时器。</p><p><img src="https://img-blog.csdn.net/20180624204400836?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L04xbmVEaW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p><h2 id="RIP协议的特点："><a href="#RIP协议的特点：" class="headerlink" title="RIP协议的特点："></a>RIP协议的特点：</h2><ul><li>RIP协议简单、容易实现</li><li>网络的直径不能超过16跳</li><li>不允许把一个大网络分成多个区</li><li>开销缺乏灵活性</li><li>存在慢收敛问题和计数到无穷问题</li><li>每30s发送完整路由表会消耗大量的带宽</li><li>实际运行的RIP协议具有以下特征：<ol><li>可以保存多达六个等距离的路由在路由表中，默认为4个</li><li>直连网的开销为0</li><li>发送的路由表会把所有距离加1</li></ol></li></ul><h1 id="OSPF"><a href="#OSPF" class="headerlink" title="OSPF"></a>OSPF</h1><p>OSPF协议（Open Shortest Path First），采用链路状态路由算法（利用最短路径算法，以自己为根，求出源节点到所有其他节点的最短路径），它可能使在大型企业中使用最广泛的内部网关协议（IGP）。</p><h2 id="OSPF区域"><a href="#OSPF区域" class="headerlink" title="OSPF区域"></a>OSPF区域</h2><p>为了适应大型的网络，OSPF在AS（自治系统，Autonomous System）内划分多个区域，每个OSPF路由器只维护所在区域的完整链路状态信息，然后将一个区域的LSA（链路状态通告，Link State Advertisement）简化和汇总后由边界路由（Area Border ROuter，ABR）转发给另一个区域。</p><h2 id="路由器（DR和BDR）"><a href="#路由器（DR和BDR）" class="headerlink" title="路由器（DR和BDR）"></a>路由器（DR和BDR）</h2><ul><li><p>Router ID：OSPF区域内唯一标识路由器的IP地址</p></li><li><p>Router ID选取规则：</p><p>（自动选取）选取路由器loopback接口上数值最高的ip地址。如果没有loopback接口，在物理端口中选取ip地址最高的。</p><p>（手动选取）使用router-id命令指定Router ID</p></li><li><p>DR和BDR</p><p>当多台OSPF路由器连到同一个多路访问网段时，如果每两台路由器之间都相互交换LSA，那么该网段将充满着众多LSA条目，为了能够尽量减少LSA的传播数量，这时候需要一个路由器和所有的路由器互换LSA，减少LSA的数量，那么这个路由器被称为DR（指定路由器，Designated Router）；在选DR的时候，也会选出一个作为备份，称为BDR（备份指定路由器，Backup Designated Router）；最后其他路由器（DRothers）只和DR和BDR形成邻接关系。</p></li><li><p>DR和BDR的选举方法<br><strong>自动选举DR和BDR</strong><br>网段上Router ID最大的路由器将被选举为DR，第二大的将被选举为BDR<br><strong>手工选择DR和BDR</strong><br>优先级范围是0～255，数值越大，优先级越高，默认为1<br>如果优先级相同，则需要比较Router lD<br>如果路由器的优先级被设置为0，它将不参与DR和DBR的选举<br>现实中，很少能有路由器同时开机，所以先上线的是DR，第二上线的是BDR。<br><strong>注：当DR和BDR存在时，除非他俩down了，不然没法强制更换。</strong></p></li><li><p>在OSPF中使用224.0.0.5和224.0.0.6作为组播地址，选举时，大家都是用组播地址224.0.0.5发送Hello包（这个时候路由器都认为自己是DR），当DR和BDR选出来后，DR和BDR使用224.0.0.5发送，其他路由器使用224.0.0.6发送。</p></li></ul><h2 id="OSPF的度量值：COST"><a href="#OSPF的度量值：COST" class="headerlink" title="OSPF的度量值：COST"></a>OSPF的度量值：COST</h2><p>规则：数值越小越优先。</p><h2 id="OSPF数据包"><a href="#OSPF数据包" class="headerlink" title="OSPF数据包"></a>OSPF数据包</h2><p>OSPF数据包承载在lP数据包内，使用协议号89</p><table><thead><tr><th>OSPF的包类型</th><th>描述</th></tr></thead><tbody><tr><td>Hello包</td><td>用于发现和维持邻居关系，选举DR和BDR</td></tr><tr><td>数据库描述包(DBD，Database Description)</td><td>用于向邻居发送摘要信息以同步链路状态数据库</td></tr><tr><td>链路状态请求包(LSR，Link State Request)</td><td>在路由器收到包含新信息的DBD后发送，用于请求更详细的信息</td></tr><tr><td>链路状态更新包(LSU，Link State Update)</td><td>收到LSR后发送链路状态通告(LSA)，一个LSU数据包可能包含几个LSA</td></tr><tr><td>链路状态确认包(LSAck)</td><td>确认已经收到DBD&#x2F; LSU，每个LSA需要被分别确认</td></tr></tbody></table><h2 id="OSPF的7个状态"><a href="#OSPF的7个状态" class="headerlink" title="OSPF的7个状态"></a>OSPF的7个状态</h2><table><thead><tr><th>状态</th><th>作用</th></tr></thead><tbody><tr><td>Down状态</td><td>初始化，没有来自邻居的Hello包</td></tr><tr><td>Init状态</td><td>收到第一个Hello包，但没发出去，建立了自己的邻居表</td></tr><tr><td>2-Way状态</td><td>双向建立会话，邻居表都建立完成</td></tr><tr><td>Exstart状态</td><td>建立主从关系</td></tr><tr><td>Exchange状态</td><td>交换摘要信息，到确认信息收到</td></tr><tr><td>Loading状态</td><td>加载详细信息</td></tr><tr><td>Full状态</td><td>完全连接，计算最短路径，并载入路由表</td></tr></tbody></table><h2 id="OSPF的4个网络类型"><a href="#OSPF的4个网络类型" class="headerlink" title="OSPF的4个网络类型"></a>OSPF的4个网络类型</h2><table><thead><tr><th>网络类型</th><th>说明</th></tr></thead><tbody><tr><td>点到点网络(Point-to-Point)</td><td>自动发现邻居，不需DR&#x2F;BDR、组播224.0.0.5</td></tr><tr><td>广播多路访问网络(Broadcast MultiAccess，BMA)</td><td>自动发现邻居、选DR&#x2F;BDR、组播224.0.0.5、224.0.0.6</td></tr><tr><td>非广播多路访问网络(None Broadcast MultiAccess，NBMA)</td><td>手工指定邻居、选DR&#x2F;BDR、单播（AMT使用）</td></tr><tr><td>点到多点网络(Point-to-Multipoint)</td><td>自动发现邻居，不需DR&#x2F;BDR、组播224.0.0.5</td></tr></tbody></table><h2 id="OSPF的特点"><a href="#OSPF的特点" class="headerlink" title="OSPF的特点"></a>OSPF的特点</h2><ul><li>可适应大规模网络</li><li>路由变化收敛速度快</li><li>无路由环</li><li>支持变长子网掩码VLSM</li><li>支持区域划分</li><li>支持以组播地址发送协议报</li></ul><h2 id="OSPF与RIP的比较"><a href="#OSPF与RIP的比较" class="headerlink" title="OSPF与RIP的比较"></a>OSPF与RIP的比较</h2><table><thead><tr><th>OSPF</th><th>RIP V1</th><th>RIP V2</th></tr></thead><tbody><tr><td>链路状态路由协议</td><td>距离矢量路由协议</td><td>距离矢量路由协议</td></tr><tr><td>没有跳数的限制</td><td>RIP的15跳限制，超过15跳的路由被认为不可达</td><td>RIP的15跳限制，超过15跳的路由被认为不可达</td></tr><tr><td>支持可变长子网掩码(VLSM)</td><td>不支持可变长子网掩码(VLSM)</td><td>支持可变长子网掩码(VLSM)</td></tr><tr><td>收敛速度快</td><td>收敛速度慢</td><td>收敛速度慢</td></tr><tr><td>使用组播发送链路状态更新</td><td>周期性广播更新整个路由表</td><td>周期性组播更新整个路由表</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>直通线和交叉线</title>
      <link href="/2022/05/21/%E7%9B%B4%E9%80%9A%E7%BA%BF%E5%92%8C%E4%BA%A4%E5%8F%89%E7%BA%BF/"/>
      <url>/2022/05/21/%E7%9B%B4%E9%80%9A%E7%BA%BF%E5%92%8C%E4%BA%A4%E5%8F%89%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="什么是交叉-x2F-直通线？"><a href="#什么是交叉-x2F-直通线？" class="headerlink" title="什么是交叉&#x2F;直通线？"></a>什么是交叉&#x2F;直通线？</h2><p>交叉线是两端使用不同的线序标准，一段使用568A线序，另一端为568B线序。主要用于同类网络设备的连接，如交换机–交换机、电脑–电脑、路由器–路由器、<b>PC–路由器</b>、集线器–交换机等。</p><p>直通线是网线两端使用相同的线序标准，两端均使用568A或568B的线序。用于不同类的网络设备连接，如<b>电脑与交换机</b>、<b>交换机与路由器</b>等。</p><h2 id="为什么要用交叉线？"><a href="#为什么要用交叉线？" class="headerlink" title="为什么要用交叉线？"></a>为什么要用交叉线？</h2><p>在双绞线中，一对是发送信号，一对是接收信号，交叉线就是将收发对调，这样a设备发送端连接b设备接收端。这就是网线必须交叉的原因。</p><p>但是连交换机不用交叉线，因为交换机或者集线器的端口本来就是反的（带X的端口，cross-over），这时候就要用直通线连接。</p><h2 id="现在的网络设备"><a href="#现在的网络设备" class="headerlink" title="现在的网络设备"></a>现在的网络设备</h2><p>现在网络设备的网卡接口都有自适应功能，两端设备会自动协商，这样一般使用直通线就可以搞定。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>交换机和路由器的区别</title>
      <link href="/2022/05/21/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%92%8C%E8%B7%AF%E7%94%B1%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2022/05/21/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%92%8C%E8%B7%AF%E7%94%B1%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><ol><li><p>工作层次不同。</p><p>交换机工作在数据链路层（第二层），路由器工作在网络层（第三层）。</p></li><li><p>转发依据不同</p><p>交换机根据MAC地址，路由器根据IP地址。</p></li><li><p>主要功能不同</p><p>交换机主要用于组建局域网，路由器是将交换机组好的局域网连接起来。</p><p>交换机能做的，路由器都能做。</p><p>交换机<b>不能分割广播域</b>，路由器可以。路由器还可以提供<b>防火墙</b>功能。</p></li></ol><p>路由器实现了不同网络之间的数据转发，交换机实现了特定网络内的数据交换。</p><p>交换机的工作原理：</p><p>交换机通过数据帧的源MAC地址进行学习，把MAC地址添加到MAC地址&#x2F;CAM表。然后通过数据帧的目的MAC地址来进行转发数据帧。相对于集线器，交换机可以认为是集线器的替代品，工作是全双工模式，用于隔离冲突域。</p><p>Switch#show mac-address-table       &#x2F;&#x2F;查看交换机MAC地址表</p><p>交换机对比集线器，除了学习功能以外，还有数据帧的过滤，和环路的防止。</p><p>交换机的过滤：</p><p>当收到一个单播帧的时候，集线器会进行泛洪转发，而交换机会进行单播转发，从而过滤掉其他接口的转发。<br>交换机收到一个数据帧的时候，如果这个数据帧的目的MAC，对应的出接口正好是这个接收到数据帧的接口，那么交换机也会把这个数据给过滤掉。<br>交换机的类型：基于转发方式</p><p>直通转发：当交换机检测到目的MAC的时候就立刻进行转发。<br>存储转发：当交换机收到完整的数据帧的时候，并检查无错后才进行转发。<br>片段转发：当交换机收到数据帧后检测到前64个字节后进行转发。<br>｛</p><p>比喻理解：</p><p>寄快递：</p><p>直通转发：看到收件人地址立即寄出去<br>存储转发：将快递拆开检查里面的完整无缺才寄出去<br>片段转发：查看外包装有没有损坏以及一些信息没出错后就寄出去，不拆包装<br>｝</p><p>哪个相对较好？这些转发方式，在交换机出产的时候已经固定好了，没办法通过命令修改。在不同的网络环境下使用不同类型的交换机才是最适合的。</p><p>在以太网中，小于64个字节的数据会被认为无用数据，那么直通转发可以很好的提高网络运作的效率，但是不能确保数据的完整，而存储转发可以很好的确保数据的完整性，但是又相对地牺牲了运作效率，片段转发属于两种转发方式的折中点。</p><p>交换机转发（只看目的MAC）数据帧的时候有以下三种方式：</p><p>单播：当数据帧的目的MAC，存在于MAC地址表的时候，交换机会执行单播。<br>泛洪：当交换机收到未知单播帧（MAC地址表中查不到数据帧中的目的MAC地址）的时候会泛洪，目的MAC为FF-FF-FF-FF-FF-FF或组播地址的时候会泛洪。<br>过滤：当交换机收到的数据帧又从收到的这个接口发出的时候会过滤。<br>交换机总结：</p><p>– 交换机和网桥的MAC地址表存储一个MAC地址到端口映射，以便它能够确定连接的设备的位置</p><p>– 当一个帧要传送到一个已知的目的地址，它仅在连接要接受帧的目的端口进行转发</p><p>– 当一个帧要传送到一个未知的目的地址，它将泛宏该帧</p><p>– 以太网交换机和网桥使用三种操作模式来传输帧：直通转发，存储转发，片段转发<br>————————————————<br>版权声明：本文为CSDN博主「pig_zhuu」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/weixin_42519306/article/details/119429746">https://blog.csdn.net/weixin_42519306/article/details/119429746</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ Tricks</title>
      <link href="/2022/05/18/C++%20Tricks/"/>
      <url>/2022/05/18/C++%20Tricks/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-用-赋值。"><a href="#1-用-赋值。" class="headerlink" title="1.用{}赋值。"></a>1.用{}赋值。</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; p;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">p = <span class="built_in">make_pair</span>(<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">p = &#123;<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">v = &#123;<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">deque&lt;vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; d;</span><br><span class="line">d = &#123;&#123;&#123;<span class="number">3</span>, <span class="number">4</span>&#125;, &#123;<span class="number">5</span>, <span class="number">6</span>&#125;&#125;, &#123;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">3</span>, <span class="number">4</span>&#125;&#125;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i: d) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> j: i)</span><br><span class="line">        cout &lt;&lt; j.first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; j.second &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;-\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">s = &#123;<span class="number">4</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">4</span>&#125;; <span class="comment">//2 4 6 7</span></span><br><span class="line"></span><br><span class="line">list&lt;<span class="type">int</span>&gt; l;</span><br><span class="line">l = &#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">1</span>&#125;;<span class="comment">//5 6 9 1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-可以使用define定义宏指令（macros）"><a href="#2-可以使用define定义宏指令（macros）" class="headerlink" title="2.可以使用define定义宏指令（macros）"></a>2.可以使用define定义宏指令（macros）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> what_is(x) cerr &lt;&lt; #x &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; x &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="type">int</span> a_variable = <span class="number">376</span>;</span><br><span class="line"><span class="built_in">what_is</span>(a_variable);</span><br><span class="line"><span class="comment">// prints &quot;a_variable is 376&quot;</span></span><br><span class="line"><span class="built_in">what_is</span>(a_variable * <span class="number">2</span> + <span class="number">1</span>)</span><br><span class="line"><span class="comment">// prints &quot;a_variable * 2 + 1 is 753&quot;</span></span><br></pre></td></tr></table></figure><h2 id="3-简化includes"><a href="#3-简化includes" class="headerlink" title="3.简化includes"></a>3.简化includes</h2><p>仅仅使用<code>#include &lt;bits/stdc++.h&gt;</code>，这个库包括了<code>algorithm</code>，<code>iostream</code>，<code>vector</code>等等，一般来说不用再调用其他库了。</p><h2 id="4-Hidden-function"><a href="#4-Hidden-function" class="headerlink" title="4.Hidden function"></a>4.Hidden function</h2><p>略</p><h2 id="5-变长参数"><a href="#5-变长参数" class="headerlink" title="5.变长参数"></a>5.变长参数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a, Args... args)</span> </span>&#123; <span class="keyword">return</span> a + <span class="built_in">sum</span>(args...); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="built_in">sum</span>(<span class="number">5</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">2</span>) + <span class="built_in">sum</span>(<span class="number">3</span>, <span class="number">4</span>); <span class="comment">/* prints &quot;23&quot; */</span> &#125;</span><br></pre></td></tr></table></figure><h2 id="C-11新特性"><a href="#C-11新特性" class="headerlink" title="C++11新特性"></a>C++11新特性</h2><ul><li><p>auto关键字（也可以用auto&amp;）</p></li><li><p>tie和emplace_back</p></li><li><p>move</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; w = <span class="built_in">move</span>(v);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v: &quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i: v)</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;\nw: &quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i: w)</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"><span class="comment">//Output:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//v: </span></span><br><span class="line"><span class="comment">//w: 1 2 3 4 </span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象设计（OO Design）几大原则</title>
      <link href="/2022/05/18/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%EF%BC%88OO-Design%EF%BC%89%E5%87%A0%E5%A4%A7%E5%8E%9F%E5%88%99/"/>
      <url>/2022/05/18/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%EF%BC%88OO-Design%EF%BC%89%E5%87%A0%E5%A4%A7%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>本文分享面向对象设计的六个设计原则：</p><table><thead><tr><th>缩写</th><th>英文名称</th><th>中文名称</th></tr></thead><tbody><tr><td>SRP</td><td>Single Responsibility Principle</td><td>单一职责原则</td></tr><tr><td>OCP</td><td>Open Close Principle</td><td>开闭原则</td></tr><tr><td>LSP</td><td>Liskov Substitution Principle</td><td>里氏替换原则</td></tr><tr><td>LoD</td><td>Law of Demeter （ Least Knowledge Principle）</td><td>迪米特法则（最少知道原则）</td></tr><tr><td>ISP</td><td>Interface Segregation Principle</td><td>接口分离原则</td></tr><tr><td>DIP</td><td>Dependency Inversion Principle</td><td>依赖倒置原则</td></tr></tbody></table><p><a href="https://juejin.cn/post/6844903673672237063">https://juejin.cn/post/6844903673672237063</a></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OOD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++类</title>
      <link href="/2022/05/17/C++%E7%B1%BB/"/>
      <url>/2022/05/17/C++%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="C-类（Class）"><a href="#C-类（Class）" class="headerlink" title="C++类（Class）"></a>C++类（Class）</h1><h2 id="类声明与类定义"><a href="#类声明与类定义" class="headerlink" title="类声明与类定义"></a>类声明与类定义</h2><h3 id="类声明（declare）"><a href="#类声明（declare）" class="headerlink" title="类声明（declare）"></a>类声明（declare）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span>;</span><br></pre></td></tr></table></figure><p>在声明之后，定义之前，只知道Screen是一个类名，但不知道包含那些成员。只能以有限方式使用它，不能定义该类型的对象，只能用于定义指向该类型的指针或引用，声明（不是定义）使用该类型作为形参类型或者返回类型的函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test1</span><span class="params">(Screen&amp; a)</span></span>&#123;&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test1</span><span class="params">(Screen* a)</span></span>&#123;&#125;;</span><br></pre></td></tr></table></figure><h3 id="类定义（define）"><a href="#类定义（define）" class="headerlink" title="类定义（define）"></a>类定义（define）</h3><p>在创建类的对象之前，必须完整定义该类，而不只是声明类。所以，类不能具有自身类型的数据成员，但可以包含指向本类的指针或引用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LinkScreen</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Screen window;</span><br><span class="line">LinkScreen* next;</span><br><span class="line">LinkScreen* prev;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//注意，分号不能丢，因为在类定义之后可以接一个对象定义列表，可类比内置类型，定义必须以分号结束。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkScreen</span>&#123;<span class="comment">/**...*/</span>&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkScreen</span>&#123;<span class="comment">/*...*/</span>&#125;scr1,scr2;</span><br></pre></td></tr></table></figure><h2 id="复制构造函数"><a href="#复制构造函数" class="headerlink" title="复制构造函数"></a>复制构造函数</h2><p>复制构造函数是一种特殊构造函数，只有一个形参，该形参（常用const&amp;修饰）是对该类类型的引用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>&#123;</span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line"><span class="built_in">People</span>();<span class="comment">//默认构造函数</span></span><br><span class="line"><span class="built_in">People</span>(<span class="type">const</span> People&amp;);<span class="comment">//复制构造函数</span></span><br><span class="line">~<span class="built_in">People</span>();<span class="comment">//析构函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当定义一个新对象并用一个同类型的对象对它进行初始化时，将显式使用复制构造函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">People a1;</span><br><span class="line">People a2 = a1;</span><br></pre></td></tr></table></figure><p>当将该类型的对象传递给函数或者函数返回该类型的对象时，将隐式使用复制构造函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">People <span class="title">Func</span><span class="params">(People b)</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure><h3 id="复制控制"><a href="#复制控制" class="headerlink" title="复制控制"></a>复制控制</h3><p>复制构造函数、赋值操作符和析构函数总称为复制控制。编译器自动实现这些操作，但类也可以定义自己的版本。</p><h3 id="两种初始化形式"><a href="#两种初始化形式" class="headerlink" title="两种初始化形式"></a>两种初始化形式</h3><p>直接初始化和复制初始化。直接初始化将初始化放在圆括号中，复制初始化使用&#x3D;号。</p><p>对于内置类型，例如int，double等，直接初始化和复制初始化没有区别。</p><p>对于类类型：直接初始化直接调用与实参匹配的构造函数；复制初始化先使用指定构造函数创建一个临时对象，然后用复制构造函数将那个临时对象复制到正在创建的对象。直接初始化比复制初始化更快。</p><h2 id="赋值操作符"><a href="#赋值操作符" class="headerlink" title="赋值操作符"></a>赋值操作符</h2><h3 id="重载赋值操作符"><a href="#重载赋值操作符" class="headerlink" title="重载赋值操作符"></a>重载赋值操作符</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sales_item&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Sales_item &amp;);</span><br></pre></td></tr></table></figure><h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><p>友元机制允许一个类将其非公有成员的访问权授予指定的函数或类。友元可以出现在类定义的内部的任何地方。友元不是授予友元关系的那个类的成员，所以它们不受声明出现部分的访问控制影响。</p><h3 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Husband</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Wife</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">double</span> money;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Wife</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Consume</span><span class="params">(Husband&amp; h)</span></span>&#123;</span><br><span class="line">h.money -=  <span class="number">1000</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Husband h;</span><br><span class="line">Wife w;</span><br><span class="line">w.<span class="built_in">Consume</span>(h);</span><br></pre></td></tr></table></figure><h3 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Husband</span>;<span class="comment">//声明Husband</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Wife</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Consume</span><span class="params">(Husband&amp; h)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Husband</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">Wife::Consume</span><span class="params">(Husband&amp; h)</span></span>;<span class="comment">//声明Consume函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">double</span> money;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Wife::Consume</span><span class="params">(Husband&amp; h)</span></span>&#123;</span><br><span class="line">h.money -= <span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意类和函数的声明和定义的顺序：</p><p>(1)声明类Husband </p><p>(2)定义类Wife，声明Consume函数</p><p>(3)定义类Husband</p><p>(4)定义Consume函数。</p><h2 id="static成员"><a href="#static成员" class="headerlink" title="static成员"></a>static成员</h2><p>static数据成员是与类关联的对象，并不与该类的对象相关联。static成员遵循正常的共有&#x2F;私有访问规则。</p><h3 id="使用static成员而不是全局对象的三个优点："><a href="#使用static成员而不是全局对象的三个优点：" class="headerlink" title="使用static成员而不是全局对象的三个优点："></a>使用static成员而不是全局对象的三个优点：</h3><ul><li>static成员的名字是在类的作用域中，因此可以避免与其他类的成员或全局对象名字冲突。</li><li>可以实施封装。static成员可以是私有成员，而全局对象不可以。</li><li>通过阅读程序容易看出static 成员是与特定类关联的，这种可见性清晰地显示程序员地意图。</li></ul><h3 id="static成员函数"><a href="#static成员函数" class="headerlink" title="static成员函数"></a>static成员函数</h3><p>在类的内部声明函数时需要添加static关键字，但是在类外部定义函数时就不需要了。因为static成员是类的组成部分但不是任何对象的组成部分，所以有以下几个特点：</p><ul><li>static函数没有this指针</li><li>static成员函数不能被声明为const（将成员函数声明为const就是承诺不会修改该函数所属的对象）</li><li>static成员函数也不能被声明为虚函数</li></ul><h3 id="static数据成员"><a href="#static数据成员" class="headerlink" title="static数据成员"></a>static数据成员</h3><p>应该在定义时初始化。</p><p>static成员变量的特点：</p><ul><li>属于类本身，不属于对象</li><li>程序运行过程中只有一个副本</li><li>不能在生成对象时初始化，即不能再构造函数中初始化</li></ul><h4 id="static变量初始化"><a href="#static变量初始化" class="headerlink" title="static变量初始化"></a>static变量初始化</h4><p>类体外进行，变量前不加static限定符；不加访问控制符；使用作用域运算符表明它所属类。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> iCount;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>()&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetCount</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> iCount;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> A::iCount = <span class="number">10</span>; <span class="comment">//在main函数外面初始化！</span></span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>1.static数据成员的类型可以是该成员所属的类的类型。非static成员只能是自身类对象的指针或引用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">static</span> Screen scr1;<span class="comment">//OK</span></span><br><span class="line">Screen *scr2;<span class="comment">//OK</span></span><br><span class="line">Screen scr3;<span class="comment">//Error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.非static数据成员不能用作默认实参，static数据成员可用作默认实参。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">          <span class="function">Screen&amp; <span class="title">clear</span><span class="params">(<span class="type">char</span> = bkground)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">         <span class="type">static</span> <span class="type">const</span> <span class="type">char</span> bkground = <span class="string">&#x27;#&#x27;</span>;<span class="comment">//static const整形变量可以在类内部初始化。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h2><p>嵌套类就是在一个类中定义另一个类。这个被嵌套的类的作用域就只在它的上一级类中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">c1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">c2</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">    &#125; b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">c1::foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> c1::c2::<span class="built_in">foo</span>()</span><br><span class="line">&#123;</span><br><span class="line">    a = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">c1</span> f;</span><br><span class="line">    f.<span class="built_in">foo</span>();</span><br><span class="line">    f.b.<span class="built_in">foo</span>();</span><br><span class="line">    cout &lt;&lt; f.a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; f.b.a &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样，被嵌套的类也可以是匿名的。匿名类的成员函数只能在类的声明中同时定义，因为这个类没有名称，没法再外部指代它。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">c3</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;a = <span class="number">3</span>;&#125;</span><br><span class="line">    <span class="keyword">class</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;a = <span class="number">4</span>;&#125;</span><br><span class="line">    &#125; b;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">c3</span> ff;</span><br><span class="line">    ff.<span class="built_in">foo</span>();</span><br><span class="line">    ff.b.<span class="built_in">foo</span>();</span><br><span class="line">    cout &lt;&lt; ff.a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; ff.b.a &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="局部类"><a href="#局部类" class="headerlink" title="局部类"></a>局部类</h2><p>局部类就是定义在一个函数内部的类。这个类只能在这个函数内部使用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">c4</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;a = <span class="number">4</span>;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">c4</span> ff;<span class="comment">//就是c4 ff</span></span><br><span class="line">    ff.<span class="built_in">foo</span>();</span><br><span class="line">    cout &lt;&lt; ff.a &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常，嵌套类和局部类的所有成员变量都会被声明为共有的。因为这两种类只能在很小的范围内使用，没有必要通过定义接口来隐藏内部的信息。所以，可以把class改换成struct，这样就可以不写public了。</p><p>但是我们可以通过一些变通的方法来模拟出一个局部函数来。具体来说就是通过重载一个类的operator () 方法来模拟一个函数调用，下面给个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">( <span class="type">void</span> )</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;HELLO&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a + b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; foo;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">foo</span>();</span><br><span class="line">    cout &lt;&lt; <span class="built_in">foo</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="成员函数返回引用"><a href="#成员函数返回引用" class="headerlink" title="成员函数返回引用"></a>成员函数返回引用</h2><p><strong>c++封装类经常会有set函数和get函数。当c++成员函数返回值是成员变量的引用，可以同时实现get和set属性的获取与设置， 类似这样的写法：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span>&amp; <span class="title">val</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_val;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    a.<span class="built_in">val</span>() = <span class="number">10</span>;  <span class="comment">// 设置属性</span></span><br><span class="line">    std::cout&lt;&lt; a.<span class="built_in">val</span>() &lt;&lt;std::endl;  <span class="comment">// 获取属性值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSMA/CA与CSMA/CD</title>
      <link href="/2022/05/16/CSMA-CA%E4%B8%8ECSMA-CD/"/>
      <url>/2022/05/16/CSMA-CA%E4%B8%8ECSMA-CD/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>1.CSMA&#x2F;CD媒体访问控制协议</p><p>　　由于以太网（Ethernet）成为现存局域网络结构的绝大多形式，CSMA&#x2F;CD（Carrier Sense Multiple Access&#x2F;Collision Detection，载波监听多路访问&#x2F;冲突检测）载波监测多路访问协议也成为局域网采用最多的MAC协议。CSMA&#x2F;CD适宜于总线型局域网拓扑结构的随机竞争型媒体访问控制。总线型网络允许同一时刻只有一个节点（Node）发送数据，一旦两个或以上节点同时发送数据，则会发生数据碰撞，数据不能正常发送和接收。CSMA&#x2F;CD协议就是尽可能保证网络上同时只有一个节点发送数据，减小数据“碰撞”概率。</p><p>　　CSMA&#x2F;CD工作过程：</p><p>　　当MAC收到LLG发来的数据以后，首先监测网络电缆上是否具有数据，即载波传送。<del>如果网络空闲，即没有载波传送，则将数据装帧，经物理层发送出去。如果网络繁忙，则监测网络直到网络空闲，再将数据装帧发送。</del></p><p>发送数据前 先侦听信道是否空闲 ,若空闲 则立即发送数据.在发送数据时,边发送边继续侦听.若侦听到冲突,则立即停止发送数据.等待一段随机时间,再重新尝试.</p><p>　 先听后发， 边发边听，冲突停发，随即延迟后重发</p><p>　　2.CSMA&#x2F;CA协议</p><p>　　CSMA作为随机竞争类MAC协议，具算法简单而且性能丰富，所以在实际局域网的使用中得到了广泛的应用。但是在无线局域网中，由于无线传输媒体固有的特性及移动性的影响，无线局域网的MAC在差错控制、解决隐藏终端等方面存在应有别于有线局域网。因此WLAN与有线局域网所采用的CSMA备一定的差异。WLAN采用CSMA&#x2F;CA（CSMA&#x2F;Collision　Avoidance）协议，其与CSMA&#x2F;CD最大的不同点在于其采取避免冲突工作方式。</p><p>　　与CSMA&#x2F;CD不同，WLAN媒体访问控制（MAC）层采用的CSMA&#x2F;CA（CSMA&#x2F;Collision Avoidance载波监听多路访问&#x2F;冲突避免）协议，由于在RF传输网络中冲突检测比较困难，所以该协议用避免冲突检测代替802.3协议使用的冲突检测，采用冲突避免机制尽量减小冲突碰撞发生的概率，以提高网络吞吐性能与迟延性能。协议使用信道空闲评估（CCA）算法来决定信道是否空闲，通过测试天线能量和决定接收信号强度RSSI来完成，并且使用RTS、CTS和ACK帧减少冲突。数据加密与普通局域网的等同加密（WEP）算法一样，使用64位密钥和RC4加密算法。</p><p>　　CSMA&#x2F;CA工作过程</p><p>　　当发射端希望发送数据时，首先检测介质是否空闲，若是介质为空闲时，送出RTS（Request To Send请求发送），RTS信号包括发射端的地址、接收端的地址、下一笔数据将持续发送的时间等信息，接收端收到RTS信号后，将响应短信号CTS（Clear To Send），CTS信号上也RTS内记录的持续发送的时间，当发射端收到CTS包后，随即开始发送数据包。接收端收到数据包后，将以包内的CRC（CyClic Redundancy Check，循环冗余校验）的数值来检验包数据是否正确，若是检验结果正确时，接收端将响应ACK包，告知发射端数据己经被成功地接收。当发射端没有收到接收端的ACK包时，将认为包在传输过程中丢失，而一直重新发送包。</p><p>　　3.CSMA&#x2F;CA与CSMA&#x2F;CD的区别</p><p>　　（1）载波检测方式：因传输介质不同，CSMA&#x2F;CD与CSMA&#x2F;CA的检测方式也不同。CSMA&#x2F;CD通过电缆中电压的变化来检测，当数据发生碰撞时，电缆中的电压就会随着发生变化；而CSMA&#x2F;CA采用能量检测（ED）、载波检测（CS）和能量载波混合检测三种检测信道空闲的方式。</p><p>　　（2）信道利用率比较CSMA&#x2F;CA协议信道利用率低于CSMA&#x2F;CD协议信道利用率。但是由于无线传输的特性，在无线局域网不能采用有线局域网的CSMA&#x2F;CD协议。信道利用率受传输距离和空旷程度的影响，当距离远或者有障碍物影响时会存在隐藏终端问题，降低信道利用率。</p><p>　　具体最高的信道利用率与传输速率有关。在IEEE802.11b无线局域网中，在1Mb&#x2F;s速率时最高信道利用率可到90%，而在11Mb&#x2F;s时最高信道利用率只有65%左右。</p><p>区别：</p><p>从名字上就可以看出， 不同就是一个是ca（collision avoidance）, 而另一个是cd（collision detection）。802.3以太网用的是cd，就是冲突检测，发生冲突并且检测到冲突后重传。 802.11无线局域网用的是ca， 就是冲突避免， 也是就是在传输以前先检测信道，然后通过RTS&#x2F;CTS来预约信道，达到冲突避免的目的。<br>csma, 就是carrier sense，也就是说两者都是在发送前检测信道是否繁忙，不同当然就是以上所说。</p><p><a href="https://blog.csdn.net/Esther_Heesch/article/details/51173722">(45条消息) CSMA&#x2F;CA与CSMA&#x2F;CD的区别_王胜飞的博客-CSDN博客_csmaca和csmacd的区别</a></p><p><a href="https://zhuanlan.zhihu.com/p/20731045">802.11协议精读3：CSMA&#x2F;CD与CSMA&#x2F;CA - 知乎 (zhihu.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计网ARP</title>
      <link href="/2022/05/15/%E8%AE%A1%E7%BD%91ARP/"/>
      <url>/2022/05/15/%E8%AE%A1%E7%BD%91ARP/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>我们知道，在浏览器输入网址，DNS服务器会自动解析为IP地址。那么IP地址是如何转换为第二层MAC地址呢？在局域网中，这是用过ARP协议来完成的。</p><span id="more"></span><h2 id="什么是ARP协议"><a href="#什么是ARP协议" class="headerlink" title="什么是ARP协议"></a>什么是ARP协议</h2><p>ARP协议就是“Address Resolution Protocol”（地址解析协议）的缩写。在以太网中，一个主机和另一个主机直接进行通信，必须知道目标主机的MAC地址，而它就是通过ARP协议获得的。所谓“地址解析”就是主机在发送帧前将目标地址转换成目标MAC地址的过程。ARP协议的基本功能就是通过目标设备的IP地址，查询目标设备的MAC地址，以保证通信的顺利进行。</p><h2 id="ARP协议的工作原理"><a href="#ARP协议的工作原理" class="headerlink" title="ARP协议的工作原理"></a>ARP协议的工作原理</h2><p>每台安装有TCP&#x2F;IP协议的电脑里都有一个ARP缓存表，表里的IP地址与MAC地址是一一对应的。在发送数据时，主机A会在自己的ARP缓存表中寻找是否有目标IP地址，如果找到了，也就知道了目标MAC地址，直接把目标MAC地址写入帧中就可以发送。如果ARP缓存表中没有找到对应的MAC地址，主机A就会在网络上发送一个广播，目标MAC地址是“FF.FF.FF.FF.FF.FF”，这表示向同一网段内的所有主机发出询问，目标IP的MAC地址是什么？网络上其他主机并不响应ARP询问，只有主机B接收到这和帧时，才向主机A做出回应其MAC地址。这样主机A就知道了B的MAC地址，就可以向主机B发送消息了。同时它还更新了自己的ARP缓存表，下次再向B发送消息时，直接从ARP缓存表里查找。ARP缓存中如果某一行在一段时间内没有使用，就会被删除。这样可以减少ARP缓存表的长度，加快查询速度。</p><p>ARP攻击就是伪造IP地址和MAC地址实现ARP欺骗，能够在网络中产生大量ARP通信量使网络拥塞，攻击者只要持续不断地发出伪造的ARP相应包就能更改目标主机ARP缓存中的IP-MAC条目，造成网络中断或中间人攻击。</p><p>ARP攻击主要是存在于局域网中，局域网中若有一个人感染ARP木马，则该感染木马的系统将会试图通过“ARP欺骗”手段截获所在网络内其它计算机的通信信息，并因此造成网内其它计算机的通信故障。</p><h2 id="RARP"><a href="#RARP" class="headerlink" title="RARP"></a>RARP</h2><p>RARP是将MAC物理地址转换成IP地址。</p><p>RARP的工作原理：</p><ol><li>发送主机发送一个本地的RARP广播，在此广播包中，声明自己的MAC地址并且请求任何收到此请求的RARP服务器分配一个IP地址； </li><li>本地网段上的RARP服务器收到此请求后，检查其RARP列表，查找该MAC地址对应的IP地址； </li><li>如果存在，RARP服务器就给源主机发送一个响应数据包并将此IP地址提供给对方主机使用； </li><li>如果不存在，RARP服务器对此不做任何的响应； </li><li>源主机收到从RARP服务器的响应信息，就利用得到的IP地址进行通讯；如果一直没有收到RARP服务器的响应信息，表示初始化失败。</li></ol><h2 id="【补充】网络协议中的传输单位"><a href="#【补充】网络协议中的传输单位" class="headerlink" title="【补充】网络协议中的传输单位"></a>【补充】网络协议中的传输单位</h2><ol><li><p>比特流（bit）：物理层&#x2F;一层。</p></li><li><p>数据帧（frame）：数据链路层&#x2F;二层。</p></li><li><p>数据包&#x2F;报文分组（packet）：网络层&#x2F;三层。</p></li><li><p>数据报（datagram）：传输层 UDP&#x2F;四层。</p></li><li><p>数据段（segment）：传输层 TCP&#x2F;四层。</p></li><li><p>消息&#x2F;报文（message）：三层以上，通常指应用层&#x2F;七层。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库ACID</title>
      <link href="/2022/05/15/%E6%95%B0%E6%8D%AE%E5%BA%93ACID/"/>
      <url>/2022/05/15/%E6%95%B0%E6%8D%AE%E5%BA%93ACID/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>ACID，是指数据库管理系统（DBMS）在写入或更新资料的过程中，为保证事务（transaction）的正确可靠的，所必须具有的四个特性：原子性（atomicity）、一致性（consistency）、隔离性（isolation）、持久性（durability）。</p><span id="more"></span><p>原子性：一个事务中的所有操作，要么全部完成，要么全部不完成。如果发生错误就会Rollback，回到事务开始前的状态，就像这个事务从来没有执行过一样。</p><p>一致性：在事务开始之前和事务结束之后，数据库的完整性没有被破坏。</p><p>隔离性：数据库允许多个并发事务同时对数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务的隔离分为不同级别，包括读未提交（Read Uncommitted)、读提交（Read committed）、可重复读（Repeatable read）、和串行化（Serializable）。</p><p>持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> 大二 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ explicit</title>
      <link href="/2022/05/14/C++explicit/"/>
      <url>/2022/05/14/C++explicit/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>C++中有隐式转换（implicit conversion）和显示转换（explicit conversion）。如果要避免隐式转换，就要用到关键字explicit。</p><span id="more"></span><p>看一看下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyInteger</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyInteger</span>(<span class="type">int</span> n) : <span class="built_in">data</span>(n) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;data = &quot;</span> &lt;&lt; data &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyInteger n1 = <span class="number">5</span>;</span><br><span class="line">    <span class="function">MyInteger <span class="title">n2</span><span class="params">(<span class="number">6</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码可以看到，即使是用的等号赋值，也会隐式转换成MyInteger(int n)，调用构造函数，而不是重载的<code>operator=</code>运算符。但是如果在构造函数前面加上explicit关键字，告诉编译器只能显示转换，这样上面的代码就会报错。</p><p>还有一种错误，就是在传递参数时，会触发函数的隐式调用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">int</span> x = <span class="number">0</span>, <span class="type">int</span> y = <span class="number">0</span>)</span><br><span class="line">        : <span class="built_in">x</span>(x), <span class="built_in">y</span>(y) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">displayPoint</span><span class="params">(<span class="type">const</span> Point&amp; p)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; p.x &lt;&lt; <span class="string">&quot;,&quot;</span> </span><br><span class="line">         &lt;&lt; p.y &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">displayPoint</span>(<span class="number">1</span>);</span><br><span class="line">    Point p = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>explicit关键字可能更多用于字符串？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyString</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyString</span>(<span class="type">int</span> n) &#123; <span class="comment">// allocate n bytes to the MyString object</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;MyString(int n)\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyString</span>(<span class="type">const</span> <span class="type">char</span> *p) &#123; <span class="comment">// initializes object with char *p</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;MyString(const char *p)\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyString s1 = <span class="number">10</span>;</span><br><span class="line">    <span class="function">MyString <span class="title">s2</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    MyString s3 = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="function">MyString <span class="title">s4</span><span class="params">(<span class="string">&quot;123456&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++对string的常用操作</title>
      <link href="/2022/05/12/C++%E5%AF%B9string%E7%9A%84%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
      <url>/2022/05/12/C++%E5%AF%B9string%E7%9A%84%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="数字与字符串互相转换"><a href="#数字与字符串互相转换" class="headerlink" title="数字与字符串互相转换"></a>数字与字符串互相转换</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string s = <span class="built_in">to_string</span>(num);</span><br><span class="line"><span class="type">int</span> num = <span class="built_in">stoi</span>(s);</span><br></pre></td></tr></table></figure><h2 id="字符串中的字符按大小排序"><a href="#字符串中的字符按大小排序" class="headerlink" title="字符串中的字符按大小排序"></a>字符串中的字符按大小排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(s.<span class="built_in">begin</span>(),s,<span class="built_in">end</span>(),[](<span class="type">char</span> a,<span class="type">char</span> b)&#123;<span class="keyword">return</span> a&gt;b;&#125;);</span><br></pre></td></tr></table></figure><h2 id="字符串中两个位置的字符交换"><a href="#字符串中两个位置的字符交换" class="headerlink" title="字符串中两个位置的字符交换"></a>字符串中两个位置的字符交换</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">swap</span>(s[i],s[j]);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++枚举类型</title>
      <link href="/2022/05/11/C++%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2022/05/11/C++%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++智能指针</title>
      <link href="/2022/05/11/C++%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
      <url>/2022/05/11/C++%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>智能指针不是一个指针，其实是一个对象，它是通过C++的RAII机制实现的。主要是利用C++中对象在释放的时候，会自动调用析构函数这一特性。所以，当智能指针对象释放的时候，在智能指针对象的析构函数中来释放其管理的内存资源。这样，开发人员就不需要手动区释放已经分配的内存空间。</p><span id="more"></span><h2 id="RAII"><a href="#RAII" class="headerlink" title="RAII"></a>RAII</h2><p>RAII（Resource Acquisition Is Initialization，资源获取即初始化）时一种利用对象生命周期来控制程序资源（如内存资源、文件句柄、网络连接、互斥量等等）的简单技术。</p><p>在对象构造时获取资源，接着控制对资源的访问使之在对象的生命周期内始终保持有效，最后在对象析构的时候释放资源。借此，我们实际上把管理一份资源的责任托管给了一个对象。这种做法有两种好处：</p><ul><li>不需要显式地释放资源</li><li>采用这种方式，对象所需的资源在其生命周期内始终保持有效。</li></ul><h2 id="智能指针的概念"><a href="#智能指针的概念" class="headerlink" title="智能指针的概念"></a>智能指针的概念</h2><blockquote><p>在C++中，动态内存的管理是通过一对运算符来完成的：new，在动态内存中为对象分配空间并返回一个指向该对象的指针，我们可以选择对对象进行初始化；delete，接收一个动态对象的指针，销毁该对象，并释放与之关联的内存。动态内存的使用很容易出现问题，因为确保在正确的时间释放内存是极其困难的，有时候使用完对象后，忘记释放内存，造成内存泄漏的问题。</p></blockquote><p>所谓的智能指针本质就是一个类模板，它可以常见任意类型的指针对象，当只针对想使用完后，对象就会自动调用析构函数去释放指针所指向的空间。</p><p>下面是智能指针的基本框架，所有的智能指针模板中都需要包含一个指针对象，构造函数和析构函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">smartptr</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">smartptr</span>(T* _ptr):<span class="built_in">ptr</span>(_ptr)&#123;&#125;</span><br><span class="line">~<span class="built_in">smartptr</span>()&#123;</span><br><span class="line"><span class="keyword">if</span>(ptr != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;smartptr: delete&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">delete</span> ptr;</span><br><span class="line">ptr = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">T&amp; <span class="keyword">operator</span>*()&#123;<span class="keyword">return</span> *ptr;&#125;</span><br><span class="line">T&amp; <span class="keyword">operator</span>-&gt;()&#123;<span class="keyword">return</span> ptr;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T* ptr;<span class="comment">//指针对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>智能指针的使用和普通指针类似，可以使用运算符<code>*</code>和<code>-&gt;</code>去获得指向的对象。因此，我们就需要在类中重载<code>*</code>和<code>-&gt;</code>函数。</p><p>当程序结束时，对象ptr会自动调用析构函数去释放指向的资源，这就是智能指针的特点。</p><p>（需要定义拷贝构造函数和赋值重载函数）</p><h2 id="C-标准中的智能指针"><a href="#C-标准中的智能指针" class="headerlink" title="C++标准中的智能指针"></a>C++标准中的智能指针</h2><p>C++17标准之后，C++标准中还有三种智能指针：shared_ptr、unique_ptr、weak_ptr。<br>详细见知乎专栏。<br><a href="https://zhuanlan.zhihu.com/p/336293980">https://zhuanlan.zhihu.com/p/336293980</a></p><p><a href="https://blog.csdn.net/sjp11/article/details/123899141"> 【c++复习笔记】——智能指针详细解析(智能指针的使用,原理分析)_努力学习的少年的博客-CSDN博客_智能指针</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++操作符重载</title>
      <link href="/2022/05/11/C++%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
      <url>/2022/05/11/C++%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>操作符重载是为了对自定义类进行运算，本质是一个函数，可以采用友元函数或者成员函数的方式实现。（成员函数默认传递this指针，可以少一个参数；而全局函数如果要访问私有变量，则需要转化为友元函数）</p><span id="more"></span><h2 id="一、操作符重载的格式"><a href="#一、操作符重载的格式" class="headerlink" title="一、操作符重载的格式"></a>一、操作符重载的格式</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#全局函数</span><br><span class="line"><span class="type">int</span> <span class="keyword">operator</span>+(<span class="type">const</span> A&amp; a1, <span class="type">const</span> A&amp; a2)</span><br><span class="line">#成员函数</span><br><span class="line"><span class="type">int</span> <span class="keyword">operator</span>+(<span class="type">const</span> A&amp; obj)</span><br></pre></td></tr></table></figure><p>函数名为operator与运算符的组合，输入为对象，返回值可以为元素、对象或者引用。</p><p><b>拷贝构造函数、赋值操作符重载函数不能被继承。</b></p><h2 id="二、可以重载的运算符"><a href="#二、可以重载的运算符" class="headerlink" title="二、可以重载的运算符"></a>二、可以重载的运算符</h2><p>不能重载的运算符：</p><ul><li>? :</li><li>.</li><li>::</li><li>sizeof</li><li>.*       引用指向类成员的指针</li></ul><table><thead><tr><th>运算符类型</th><th>具体运算符</th></tr></thead><tbody><tr><td>双目算术运算符</td><td><code>+</code> (加)，<code>-</code>(减)，<code>*</code>(乘)，<code>/</code>(除)，<code>%</code> (取模)</td></tr><tr><td>关系运算符</td><td><code>==</code>(等于)，<code>!= </code>(不等于)，<code>&lt;</code> (小于)，<code>&gt;</code> (大于&gt;，<code>&lt;=</code>(小于等于)，<code>&gt;=</code>(大于等于)</td></tr><tr><td>逻辑运算符</td><td>&#96;</td></tr><tr><td>单目运算符</td><td><code>+</code> (正)，<code>-</code>(负)，<code>*</code>(指针)，<code>&amp;</code>(取地址)</td></tr><tr><td>自增自减运算符</td><td><code>++</code>(自增)，<code>--</code>(自减)</td></tr><tr><td>位运算符</td><td>&#96;</td></tr><tr><td>赋值运算符</td><td><code>=</code>，<code>+=</code>，<code>-=</code>，<code>*=</code>，<code>/=</code>，<code>%=</code>，<code>&amp;=</code>，&#96;</td></tr><tr><td>空间申请与释放</td><td><code>new</code>，<code>delete</code>，<code>new[ ]</code> ，<code>delete[]</code></td></tr><tr><td>其他运算符</td><td><code>()</code>(函数调用)，<code>-&gt;</code>(成员访问)，<code>,</code>(逗号)，<code>[]</code>(下标)</td></tr></tbody></table><h2 id="三、实例：实现complex类的±运算符重载（二元运算符）"><a href="#三、实例：实现complex类的±运算符重载（二元运算符）" class="headerlink" title="三、实例：实现complex类的±运算符重载（二元运算符）"></a>三、实例：实现complex类的±运算符重载（二元运算符）</h2><p>注意：使用友元函数需要注意的是，二元运算则传递两个参数，同时添加friend关键字，使用成员函数只需要一个参数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Complex</span>(<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;a = a;</span><br><span class="line"><span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">friend</span> Complex <span class="keyword">operator</span>+(<span class="type">const</span> Complex&amp; x1, <span class="type">const</span> Complex&amp; x2);</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printC</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;a &lt;&lt; <span class="string">&quot;b:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">Complex <span class="keyword">operator</span>-(<span class="type">const</span> Complex&amp; obj)</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">Complex <span class="title">tmp</span><span class="params">(<span class="keyword">this</span>-&gt;a - obj.a, <span class="keyword">this</span>-&gt;b - obj.b)</span></span>;</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//友元函数重载</span></span><br><span class="line">Complex <span class="keyword">operator</span>+(<span class="type">const</span> Complex&amp; x1, <span class="type">const</span> Complex&amp; x2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">Complex <span class="title">tmp</span><span class="params">(x1.a + x2.a, x1.b + x2.b)</span></span>;</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Complex <span class="title">x1</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">Complex <span class="title">x2</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">Complex x3 = x1 + x2;</span><br><span class="line">x3.<span class="built_in">printC</span>();</span><br><span class="line"></span><br><span class="line">Complex x4 = x2 - x1;</span><br><span class="line">x4.<span class="built_in">printC</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;hello,world...&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成员函数可以用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> Rational&amp; <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; r) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Rational</span>(n*r.n,d*r.d)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中最前面地修饰符&amp;的意思是返回值是一个引用，C++编译器会在返回的地方创建对象，并不会调用复制构造函数。</p><h2 id="四、实例：基于3实现complex类的前置-以及后置-（一元运算符）"><a href="#四、实例：基于3实现complex类的前置-以及后置-（一元运算符）" class="headerlink" title="四、实例：基于3实现complex类的前置+以及后置++（一元运算符）"></a>四、实例：基于3实现complex类的前置+以及后置++（一元运算符）</h2><p>注意：</p><p>1）后置++需要在参数列表中增加占位符int，complex operator++（complex&amp;obj，int）</p><p>2）后置++先使用后++，如a++，在具体实现时就要先使用临时变量tmp暂存输入，而后++，最后返回临时变量。</p><p>3）传递的变量最好在引用&amp;前使用const，保持变量的内存空间不能改变</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">friend</span> Complex <span class="keyword">operator</span>+(<span class="type">const</span> Complex&amp; x1, <span class="type">const</span> Complex&amp; x2);</span><br><span class="line"><span class="keyword">friend</span> Complex <span class="keyword">operator</span>++(Complex&amp; obj, <span class="type">int</span>);</span><br><span class="line"><span class="built_in">Complex</span>(<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;a = a;</span><br><span class="line"><span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printC</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;a &lt;&lt; <span class="string">&quot;b:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">Complex <span class="keyword">operator</span>-(<span class="type">const</span> Complex&amp; obj)<span class="comment">//-</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function">Complex <span class="title">tmp</span><span class="params">(<span class="keyword">this</span>-&gt;a - obj.a, <span class="keyword">this</span>-&gt;b - obj.b)</span></span>;</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//成员函数实现前置--，前置不需要占位符</span></span><br><span class="line">Complex&amp; <span class="keyword">operator</span>--()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;a++;</span><br><span class="line"><span class="keyword">this</span>-&gt;b++;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Complex <span class="keyword">operator</span>+(<span class="type">const</span> Complex&amp; x1, <span class="type">const</span> Complex&amp; x2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">Complex <span class="title">tmp</span><span class="params">(x1.a + x2.a, x1.b + x2.b)</span></span>;</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//友元函数实现后置++,后置需要增加占位符</span></span><br><span class="line">Complex <span class="keyword">operator</span>++(Complex&amp; obj, <span class="type">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">Complex tmp = obj;<span class="comment">//其中如果有指针，那么需要注意浅拷贝</span></span><br><span class="line">obj.a++;</span><br><span class="line">obj.b++;</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Complex <span class="title">x1</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">Complex <span class="title">x2</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">Complex x3 = x1 + x2;</span><br><span class="line">x3.<span class="built_in">printC</span>(); <span class="comment">//4,6</span></span><br><span class="line">--x3;</span><br><span class="line">Complex x4 = x2 - x1;</span><br><span class="line">x4.<span class="built_in">printC</span>();<span class="comment">//2,2</span></span><br><span class="line">Complex x5 = x4++;</span><br><span class="line">x4.<span class="built_in">printC</span>();<span class="comment">//3,3</span></span><br><span class="line">x5.<span class="built_in">printC</span>();<span class="comment">//2,2</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;hello,world...&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、实例：实现complex输出-lt-lt-和输入-gt-gt-的重载"><a href="#五、实例：实现complex输出-lt-lt-和输入-gt-gt-的重载" class="headerlink" title="五、实例：实现complex输出&lt;&lt;和输入&gt;&gt;的重载"></a>五、实例：实现complex输出&lt;&lt;和输入&gt;&gt;的重载</h2><p>注意：</p><p>1）类似&lt;&lt;操作符重载，其为二元运算符，两个操作数类型不同，分别为ostream和complex</p><p>2）<b>实现两个操作数类型不同的运算符重载要使用友元函数</b></p><ul><li>原因是，成员函数重载operator+，调用a+1时相当于调用a.operator(1)，只能保证一种参数顺序的运算，两个参数更换位置就失败，即1+a时就会报没有对应的操作符重载。</li><li>友元函数可以通过重载友元函数来实现，只调换参数位置即可实现。</li><li>要实现链式编程，返回引用。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, <span class="type">const</span> Complex&amp; obj);</span><br><span class="line"><span class="keyword">friend</span> Complex <span class="keyword">operator</span>+(<span class="type">const</span> Complex&amp; x1, <span class="type">int</span> i);</span><br><span class="line"><span class="keyword">friend</span> Complex <span class="keyword">operator</span>+(<span class="type">int</span> i, <span class="type">const</span> Complex&amp; x1);</span><br><span class="line"><span class="keyword">friend</span> istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; in, Complex&amp; obj);</span><br><span class="line"><span class="built_in">Complex</span>(<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;a = a;</span><br><span class="line"><span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printC</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;a &lt;&lt; <span class="string">&quot;b:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Complex <span class="keyword">operator</span>-(<span class="type">int</span> i) <span class="comment">//成员函数重载-</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function">Complex <span class="title">tmp</span><span class="params">(<span class="keyword">this</span>-&gt;a - i, <span class="keyword">this</span>-&gt;b - i)</span></span>;</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Complex <span class="keyword">operator</span>+(<span class="type">const</span> Complex&amp; x1, <span class="type">int</span> i) <span class="comment">//友元函数重载+  （1）</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function">Complex <span class="title">tmp</span><span class="params">(x1.a + i, x1.b + i)</span></span>;</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line">Complex <span class="keyword">operator</span>+(<span class="type">int</span> i, <span class="type">const</span> Complex&amp; x1)<span class="comment">//友元函数重载+   （2）</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function">Complex <span class="title">tmp</span><span class="params">(x1.a + i, x1.b + i)</span></span>;</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//友元函数实现重载&lt;&lt;左移操作符，输出，且只能采用友元函数</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, <span class="type">const</span> Complex&amp; obj)<span class="comment">//此处将ostream类型的out变量本身返回，以便后续的连续操作</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; obj.a &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; obj.b &lt;&lt; <span class="string">&quot;i&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#原来自己是这么实现的，但是不支持cin&gt;&gt;x1&gt;&gt;x2的链式编程的情况</span><br><span class="line"><span class="comment">// void operator&gt;&gt;(istream&amp; in, Complex&amp; obj)</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// in &gt;&gt; obj.a;</span></span><br><span class="line"><span class="comment">// in &gt;&gt; obj.b;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; in, Complex&amp; obj)</span><br><span class="line">&#123;</span><br><span class="line">in &gt;&gt; obj.a;</span><br><span class="line">in &gt;&gt; obj.b;</span><br><span class="line"><span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Complex <span class="title">x1</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">Complex <span class="title">x2</span><span class="params">(<span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; x1 + <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="number">1</span> + x1 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; x1 - <span class="number">2</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cin &gt;&gt; x1 &gt;&gt; x2;</span><br><span class="line">cout &lt;&lt; x1 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;hello,world...&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="为什么只能通过友元函数进行重载流运算符？"><a href="#为什么只能通过友元函数进行重载流运算符？" class="headerlink" title="为什么只能通过友元函数进行重载流运算符？"></a>为什么只能通过友元函数进行重载流运算符？</h3><p>因为流操作符左侧必须为cin或cout，即istream类或ostream类，不是我们所能修改的类；或者说因为流操作符具有方向性。这导致我们<b>不能用成员函数重载</b>，只能使用类外的普通函数重载。（要求第一个参数为ostream的引用）</p><p>由于我们将类内部的私有成员进行输入和输出，所以重载函数必须有对内部成员的访问权限。这导致我们<b>不能使用普通的函数重载</b>，只能使用<b>友元函数</b>重载。</p><p>（如果定义为成员函数<code>std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os);</code>，那调用格式就成了<code>obj&lt;&lt;std::cout</code>，与使用惯例不符，而且也不能链式使用。）</p><h3 id="不能使用友元函数重载的运算符"><a href="#不能使用友元函数重载的运算符" class="headerlink" title="不能使用友元函数重载的运算符"></a>不能使用友元函数重载的运算符</h3><p>不能用友元函数重载的运算符有：&#x3D; （） [ ]  -&gt;</p><p>在程序中执行类对象的赋值语句时，程序会出现两种矛盾的选择：</p><ol><li>它认为类中并没有重载赋值运算符的成员函数，根据C++的规则，会去调用相应的构造函数。</li><li>但是在全局里，我们已经重载了参数类型为此类型的赋值运算符，而赋值语句刚好和这函数匹配上了，根据C++的规则，也会去调用这函数。</li></ol><p>对于剩下的三个运算符 -&gt; [ ] () ，为什么不能重载为友元函数，也是跟上面一样的道理。即编译器发现当类中没有定义这三个运算符的重载成员函数时，就会自己加入<b>默认的运算符重载成员函数</b>。</p><h2 id="六、重载等号-x3D-操作符（赋值操作符）"><a href="#六、重载等号-x3D-操作符（赋值操作符）" class="headerlink" title="六、重载等号&#x3D;操作符（赋值操作符）"></a>六、重载等号&#x3D;操作符（赋值操作符）</h2><p>有指针的类定义的对象，在等号&#x3D;赋值时，采用C++的赋值，进行的时浅拷贝，导致两个对象的指针指向同一个内存空间，释放的时候出现问题。</p><p>&#x3D;操作符不能作为全局函数重载。</p><p>如果对象中有指针，要额外注意。因为会出现悬浮指针、内存泄漏等问题。</p><p>先赋值，后释放。</p><p>避免自我赋值。（比较指针是否相等、比较id等等）（先赋值，后释放也行）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Name</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Name</span>(<span class="type">const</span> <span class="type">char</span>* p)<span class="comment">//“asdb”</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_p = <span class="keyword">new</span> <span class="type">char</span>[<span class="keyword">this</span>-&gt;m_len + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;m_p, <span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_len = <span class="built_in">strlen</span>(p);</span><br><span class="line"><span class="keyword">this</span>-&gt;m_p = <span class="keyword">new</span> <span class="type">char</span>[<span class="keyword">this</span>-&gt;m_len + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;m_p, p);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Name</span>(<span class="type">const</span> Name&amp; obj)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_len = obj.m_len;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_p = <span class="keyword">new</span> <span class="type">char</span>[<span class="keyword">this</span>-&gt;m_len + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;m_p, obj.m_p);</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Name</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_len != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;m_p;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_len = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Name&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Name&amp; obj)<span class="comment">//重载等号操作符，实现连等，返回一个引用</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_p!=<span class="literal">NULL</span>) <span class="comment">//先释放旧的指针</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;m_p;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_len = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_len = obj.m_len;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_p = <span class="keyword">new</span> <span class="type">char</span>[<span class="keyword">this</span>-&gt;m_len + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;m_p, obj.m_p);</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">char</span>* m_p;</span><br><span class="line"><span class="type">int</span> m_len;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Name <span class="title">obj</span><span class="params">(<span class="string">&quot;asdf&quot;</span>)</span></span>;<span class="comment">//双引号代表字符串，单引号代表字符，并且其可转化为int的ASCII码</span></span><br><span class="line"><span class="function">Name <span class="title">obj2</span><span class="params">(<span class="string">&quot;sdgf&quot;</span>)</span></span>;</span><br><span class="line">Name obj3 = obj2;</span><br><span class="line">obj2 = obj;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;hello,world...&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="七、重载（）操作符"><a href="#七、重载（）操作符" class="headerlink" title="七、重载（）操作符"></a>七、重载（）操作符</h2><h3 id="作为函数调用操作符"><a href="#作为函数调用操作符" class="headerlink" title="作为函数调用操作符"></a>作为函数调用操作符</h3><p>重载（）操作符，在定义对象后，可以使用f（），类似于f.operator()操作。可以给对象传参数，输出结果。（函数对象）</p><p>（）操作符不能作为全局函数重载。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">F</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">F f;</span><br><span class="line"><span class="built_in">f</span>(<span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;hello,world...&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="作为类型转换操作符"><a href="#作为类型转换操作符" class="headerlink" title="作为类型转换操作符"></a>作为类型转换操作符</h3><p>前面如果有返回类型，那么就是函数调用操作符，如果没有的话就是类型转换操作符。目标类型由函数名指定。</p><p>声明语法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span> 类型名 ();</span><br></pre></td></tr></table></figure><p>注意事项：</p><ol><li>函数没有返回类型</li><li>虽然没有返回类型，但是函数体必须有return语句，其返回类型是由类型名来指定的</li><li>类型缓缓操作符重载函数只能以类的成员函数的形式重载，而不能以友元函数的形式重载。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> (<span class="type">double</span>)n/d;&#125;</span><br></pre></td></tr></table></figure><h2 id="八、重载下标运算符"><a href="#八、重载下标运算符" class="headerlink" title="八、重载下标运算符[]"></a>八、重载下标运算符[]</h2><p>下标操作符通常用于访问数组元素。重载该运算符用于增强操作C++数组的功能。</p><p>[]操作符不能作为全局函数重载。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SIZE = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">safearay</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> arr[SIZE];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">safearay</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">register</span> <span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; SIZE; i++)</span><br><span class="line">&#123;</span><br><span class="line">arr[i] = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span>&amp; <span class="keyword">operator</span>[](<span class="type">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i &gt; SIZE)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;索引超过最大值&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">// 返回第一个元素</span></span><br><span class="line"><span class="keyword">return</span> arr[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arr[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">safearay A;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;A[2] 的值为 : &quot;</span> &lt;&lt; A[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;A[5] 的值为 : &quot;</span> &lt;&lt; A[<span class="number">5</span>] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;A[12] 的值为 : &quot;</span> &lt;&lt; A[<span class="number">12</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">A[2] 的值为 : 2</span></span><br><span class="line"><span class="comment">A[5] 的值为 : 5</span></span><br><span class="line"><span class="comment">索引超过最大值</span></span><br><span class="line"><span class="comment">A[12] 的值为 : 0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="重载二维数组（使用wrapper类）"><a href="#重载二维数组（使用wrapper类）" class="headerlink" title="重载二维数组（使用wrapper类）"></a>重载二维数组（使用wrapper类）</h3><p>重载Array2D时，重载[]操作符，返回Array1D。</p><h2 id="九、重载类成员访问运算符-gt-（指针间接引用操作符）"><a href="#九、重载类成员访问运算符-gt-（指针间接引用操作符）" class="headerlink" title="九、重载类成员访问运算符-&gt;（指针间接引用操作符）"></a>九、重载类成员访问运算符-&gt;（指针间接引用操作符）</h2><p>类成员访问运算符（<code>-&gt;</code>）可以被重载，但它较为麻烦。它被定义用于为一个类赋予 “指针” 行为。运算符<code>-&gt;</code>必须是一个成员函数。如果使用了<code>-&gt;</code>运算符，返回类型必须是指针或者是（定义过-&gt;运算符的）类的对象。</p><p>（把对象等同于封装的指针）</p><p>运算符<code>-&gt;</code>通常与指针引用运算符<code>*</code>结合使用，用于实现”<strong>智能指针</strong>“的 功能。这些指针是行为与正常指针相似的对象，唯一不同的是，当您通过指针访问对象时，它们会执行其他的任务。比如，当指针销毁时，或者当指针指向另一个对象时，会自动删除对象。（防止内存泄漏）</p><p>间接引用运算符<code>-&gt;</code>可被定义为一个一元后缀运算符。也就是说，给出一个类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Ptr</span>&#123;</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">   X * <span class="keyword">operator</span>-&gt;();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>类 <strong>Ptr</strong> 的对象可用于访问类 <strong>X</strong> 的成员，使用方式与指针的用法十分相似。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(Ptr p )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   p-&gt;m = <span class="number">10</span> ; <span class="comment">// (p.operator-&gt;())-&gt;m = 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>语句<code>p-&gt;m</code>被解释为<code>(p.operator-&gt;())-&gt;m</code>。同样地，下面的实例演示了如何重载类成员访问运算符<code>-&gt;</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设一个实际的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Obj</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> i, j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> <span class="type">const</span> </span>&#123; cout &lt;&lt; i++ &lt;&lt; endl; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span> <span class="type">const</span> </span>&#123; cout &lt;&lt; j++ &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态成员定义</span></span><br><span class="line"><span class="type">int</span> Obj::i = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> Obj::j = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为上面的类实现一个容器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ObjContainer</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(Obj* obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">a.<span class="built_in">push_back</span>(obj);  <span class="comment">// 调用向量的标准方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">SmartPointer</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">vector&lt;Obj*&gt; a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现智能指针，用于访问类 Obj 的成员</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmartPointer</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">SmartPointer</span>(ObjContainer&amp; objc)</span><br><span class="line">&#123;</span><br><span class="line">oc = objc;</span><br><span class="line">index = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回值表示列表结束</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>++() <span class="comment">// 前缀版本</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (index &gt;= oc.a.<span class="built_in">size</span>() - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (oc.a[++index] == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>++(<span class="type">int</span>) <span class="comment">// 后缀版本</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">operator</span>++();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 重载运算符 -&gt;</span></span><br><span class="line">Obj* <span class="keyword">operator</span>-&gt;() <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!oc.a[index])</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Zero value&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> (Obj*)<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> oc.a[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">ObjContainer oc;</span><br><span class="line"><span class="type">int</span> index;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> sz = <span class="number">3</span>;</span><br><span class="line">Obj o[sz];</span><br><span class="line">ObjContainer oc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; sz; i++)</span><br><span class="line">&#123;</span><br><span class="line">oc.<span class="built_in">add</span>(&amp;o[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">SmartPointer <span class="title">sp</span><span class="params">(oc)</span></span>; <span class="comment">// 创建一个迭代器</span></span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">&#123;</span><br><span class="line">sp-&gt;<span class="built_in">f</span>(); <span class="comment">// 智能指针调用</span></span><br><span class="line">sp-&gt;<span class="built_in">g</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (sp++);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">12</span></span><br><span class="line"><span class="comment">11</span></span><br><span class="line"><span class="comment">13</span></span><br><span class="line"><span class="comment">12</span></span><br><span class="line"><span class="comment">14</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="十、new、delete重载"><a href="#十、new、delete重载" class="headerlink" title="十、new、delete重载"></a>十、new、delete重载</h2><p>C++中的new和delete操作符，可以全局重载，也可以在特定类中重载。</p><h3 id="为什么要重载new-x2F-delete操作符？"><a href="#为什么要重载new-x2F-delete操作符？" class="headerlink" title="为什么要重载new&#x2F;delete操作符？"></a>为什么要重载new&#x2F;delete操作符？</h3><ol><li>可以在重载新的运算符中添加异常处理流程。</li><li>希望自定义运算符delete，以用0覆盖回收的堆内存块，以提高应用程序数据的安全性。</li><li>重载new操作符可以在其内部定义C版本的malloc或realloc函数进行对象的堆内存分配，然而C++并不建议你这样做，因为这样已经绕过了标准库中默认的内存分配器的内存管理机制。</li><li>同理delete操作也可以在其重载版本中定义C版本的free()函数，同样C++不建议这么做。</li></ol><p><a href="https://zhuanlan.zhihu.com/p/272757178">第22篇:重载C++的new和delete操作符 - 知乎 (zhihu.com)</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>*p,<span class="type">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure><p>使用一整块的内存，反复使用。</p><h2 id="十一、为const类和非const类实现不同的操作符重载"><a href="#十一、为const类和非const类实现不同的操作符重载" class="headerlink" title="十一、为const类和非const类实现不同的操作符重载"></a>十一、为const类和非const类实现不同的操作符重载</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>&amp; <span class="keyword">operator</span> [](<span class="type">int</span> i) &#123;<span class="keyword">return</span> p[i];&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> <span class="keyword">operator</span> [] (<span class="type">int</span> i) <span class="type">const</span> &#123;<span class="keyword">return</span> p[i];&#125;</span><br></pre></td></tr></table></figure><p>下面的后面的const指向this，表明是const类型的变量。</p><h2 id="十二、不要重载-amp-amp-以及"><a href="#十二、不要重载-amp-amp-以及" class="headerlink" title="十二、不要重载&amp;&amp;以及||"></a>十二、不要重载&amp;&amp;以及||</h2><p>作用于基础类型的&amp;&amp;和||有短路规则，但是经过重载后，就没有短路规则了，原因是重载是一种函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Test</span>(<span class="type">int</span> i = <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;i = i;</span><br><span class="line">&#125;</span><br><span class="line">Test&amp;  <span class="keyword">operator</span>+(<span class="type">const</span> Test&amp; obj)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;i = <span class="keyword">this</span>-&gt;i + obj.i;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&amp;&amp;(<span class="type">const</span> Test&amp; obj)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;i &amp;&amp; obj.i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getData</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Test <span class="title">t1</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function">Test <span class="title">t2</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">t1 &amp;&amp; (t1 + t2);<span class="comment">//重载&amp;&amp;</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;hello,world...&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处重载&amp;&amp;，但是仍然先计算+加号重载的操作符，后计算&amp;&amp;重载，而不是先判断t1。</p><h2 id="数组类案例"><a href="#数组类案例" class="headerlink" title="数组类案例"></a>数组类案例</h2><p><a href="https://blog.csdn.net/YJYS_ZHX/article/details/114462206">【C++】数组类案例，实现 ] 、&#x3D;&#x3D;、 !&#x3D;的重载_剑宇2022的博客-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++unordered_map</title>
      <link href="/2022/05/10/C++unordered-map/"/>
      <url>/2022/05/10/C++unordered-map/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="unordered-map-初始化"><a href="#unordered-map-初始化" class="headerlink" title="unordered_map 初始化"></a>unordered_map 初始化</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line">std::unordered_map&lt;std::string,<span class="type">int</span>&gt; umap = &#123;</span><br><span class="line">&#123;<span class="string">&quot;Tom&quot;</span>,<span class="number">1</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;Ann&quot;</span>,<span class="number">4</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;Jack&quot;</span>,<span class="number">2</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="unordered-map-插入元素"><a href="#unordered-map-插入元素" class="headerlink" title="unordered_map 插入元素"></a>unordered_map 插入元素</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">umap[<span class="string">&quot;John&quot;</span>] = <span class="number">3</span>;</span><br><span class="line">umap.<span class="built_in">insert</span>(std::<span class="built_in">pair</span>&lt;std::string,<span class="type">int</span>&gt;(<span class="string">&quot;John&quot;</span>,<span class="number">3</span>));</span><br></pre></td></tr></table></figure><h2 id="unordered-map-根据key值查找元素"><a href="#unordered-map-根据key值查找元素" class="headerlink" title="unordered_map 根据key值查找元素"></a>unordered_map 根据key值查找元素</h2><p>直接用中括号获取，如果map中没有，则不会输出任何结果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="string">&quot;id: &quot;</span> &lt;&lt; umap[<span class="string">&quot;John&quot;</span>] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure><h2 id="unordered-map-移除元素"><a href="#unordered-map-移除元素" class="headerlink" title="unordered_map 移除元素"></a>unordered_map 移除元素</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">umap.<span class="built_in">erase</span>(umap.<span class="built_in">begin</span>());</span><br></pre></td></tr></table></figure><h2 id="遍历unordered-map"><a href="#遍历unordered-map" class="headerlink" title="遍历unordered_map"></a>遍历unordered_map</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; n : umap) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; n.first &lt;&lt; <span class="string">&quot;, id: &quot;</span> &lt;&lt; n.second &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者使用迭代器</span></span><br><span class="line"><span class="keyword">for</span> (std::unordered_map&lt;std::string, <span class="type">int</span>&gt;::iterator it = umap.<span class="built_in">begin</span>(); it != umap.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="comment">// for (auto it = umap.begin(); it != umap.end(); it++) &#123;</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; (*it).first &lt;&lt; <span class="string">&quot;, id: &quot;</span> &lt;&lt; (*it).second &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="清空，判断是否为空"><a href="#清空，判断是否为空" class="headerlink" title="清空，判断是否为空"></a>清空，判断是否为空</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">umap.<span class="built_in">clear</span>();</span><br><span class="line">umap.<span class="built_in">empty</span>();</span><br></pre></td></tr></table></figure><h2 id="根据key查找元素"><a href="#根据key查找元素" class="headerlink" title="根据key查找元素"></a>根据key查找元素</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (um.<span class="built_in">find</span>(<span class="number">23</span>) == um.<span class="built_in">end</span>()) </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Element Not Present\n&quot;</span>; </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Element Present\n&quot;</span>; </span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java对字符串排序</title>
      <link href="/2022/05/02/Java%E5%AF%B9%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8E%92%E5%BA%8F/"/>
      <url>/2022/05/02/Java%E5%AF%B9%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>方法1：冒泡排序 ：<br>思路：先获取字符串数组里的每个字符串，然后使用toCharArray()方法得到这个字符串的char[] 再对char数组里的元素进行对比，冒泡排序前面大的与后面交换顺序，再把得到的char数组重新转换为String，存入到一个新的String数组中，然后在整体对新数组中各个字符串使用冒泡排序从而得到结果)<br>方法2：使用 Arrays.sort(s)；方法进行排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> class 字符排序 &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">String[] str  = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;fcc&quot;</span>,<span class="string">&quot;egfd&quot;</span>,<span class="string">&quot;asd&quot;</span>,<span class="string">&quot;rtgh&quot;</span>,<span class="string">&quot;deghk&quot;</span>,<span class="string">&quot;fcc&quot;</span>&#125;;</span><br><span class="line"><span class="comment">/*方法1：冒泡排序   ：</span></span><br><span class="line"><span class="comment">思路：先获取字符串数组里的每个字符串，然后使用toCharArray()方法得到这个字符串的char[] 再对char数</span></span><br><span class="line"><span class="comment">组里的元素进行对比，冒泡排序前面大的与后面交换顺序，再把得到的char数组重新转换为String，存入到一个新的String</span></span><br><span class="line"><span class="comment">数组中，然后在整体对新数组中各个字符串使用冒泡排序从而得到结果)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">printArr(stringRank(test(str)));</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法2：使用 Arrays.sort(s)；方法进行排序</span></span><br><span class="line">String[] s = sortChar(str);</span><br><span class="line">Arrays.sort(s);</span><br><span class="line">printArr(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//得到一个每个字符串里元素已经进行过排序的新字符串数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String[] test(String[] str)&#123;</span><br><span class="line">String st[] =  st = <span class="keyword">new</span> <span class="title class_">String</span>[str.length];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line"><span class="type">char</span>[] c =  str[i].toCharArray();</span><br><span class="line">charRank(c);</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(c);</span><br><span class="line">st[i]  = s; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> st;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对字符串里元素进行排序</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">charRank</span><span class="params">(<span class="type">char</span>[] c)</span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; c.length; j++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j2</span> <span class="operator">=</span> <span class="number">0</span>; j2 &lt; c.length-j-<span class="number">1</span>; j2++) &#123;</span><br><span class="line"><span class="keyword">if</span>(c[j2]&gt;c[j2+<span class="number">1</span>])&#123;</span><br><span class="line"><span class="type">char</span> <span class="variable">len</span> <span class="operator">=</span> c[j2];</span><br><span class="line">c[j2] = c[j2+<span class="number">1</span>];</span><br><span class="line">c[j2+<span class="number">1</span>] = len;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 对新字符串数组里的字符串进行排序(升序)字符串比较使用compareTo()方法，</span></span><br><span class="line"><span class="comment">String本身并不具备比较大小功能，它的String对象实现了Comparable接口，这个接口是具有比较大小功能的接口，里面定义了比较方法compareTo()方法，</span></span><br><span class="line"><span class="comment">所以如果我们定义了一个类，这个类产生的对象需要比较大小就需要去实现Comparable接口，重写compareTo()方法，这种</span></span><br><span class="line"><span class="comment">排序成为类的自然排序，compareTo()方法称为自然比较方法，因为String类已经实现了compareTo()方法，所以这里可以直接使用</span></span><br><span class="line"><span class="comment">该方法的比较对象与指定对象的顺序。</span></span><br><span class="line"><span class="comment">compareTo(T  o)    返回值：int  返回0(两者相等)，负数(对象小于参数)，正数(对象大于参数)     参数o为要比较的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String[] stringRank(String[] str) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; str.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (str[j].compareTo(str[j + <span class="number">1</span>]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> str[j];</span><br><span class="line">str[j] = str[j + <span class="number">1</span>];</span><br><span class="line">str[j + <span class="number">1</span>] = s;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法2</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String[] sortChar(String[] str) &#123;</span><br><span class="line">String[] s = <span class="keyword">new</span> <span class="title class_">String</span>[str.length];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line"><span class="type">char</span>[] c = str[i].toCharArray();</span><br><span class="line">Arrays.sort(c);</span><br><span class="line">s[i] = String.valueOf(c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印字符串数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printArr</span><span class="params">(String[] str)</span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">System.out.print(str[i]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚函数详解</title>
      <link href="/2022/04/28/%E8%99%9A%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/04/28/%E8%99%9A%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="一、多态与重载"><a href="#一、多态与重载" class="headerlink" title="一、多态与重载"></a>一、多态与重载</h2><h3 id="1、多态的概念"><a href="#1、多态的概念" class="headerlink" title="1、多态的概念"></a>1、多态的概念</h3><p>面向对象的语言有三大特性：封装、继承和多态。虚函数作为多态的实现方式，重要性毋庸置疑。</p><p>多态指给予不同的对象会引发不同的动作（一个接口，多种方法）。其实现更简单地来说，就是“在用父类指针调用函数时，实际调用的是指针指向的实际类型（子类）的成员函数”。多态性使得程序调用的函数是在运行时动态确定，而不是在编译器静态确定。</p><h3 id="2、重载–编译期多态的体现"><a href="#2、重载–编译期多态的体现" class="headerlink" title="2、重载–编译期多态的体现"></a>2、重载–编译期多态的体现</h3><p>重载，是指在一个类中的同名不同参的函数调用，这样的方法调用是在编译器确定的。</p><h3 id="3、虚函数–运行期多态的体现"><a href="#3、虚函数–运行期多态的体现" class="headerlink" title="3、虚函数–运行期多态的体现"></a>3、虚函数–运行期多态的体现</h3><p>运行期多态发生的三个条件：继承关系、虚函数覆盖、父类指针或引用指向子类对象。</p><h2 id="二、虚函数实例"><a href="#二、虚函数实例" class="headerlink" title="二、虚函数实例"></a>二、虚函数实例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">base</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vir_func</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;virtual function, this is class base&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;normal function, this is class base&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">A</span>:<span class="keyword">public</span> base&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vir_func</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;virtual function, this is class A&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;normal function, this is class A&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">B</span>:<span class="keyword">public</span> base&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vir_func</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;virtual function, this is class B&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;normal function, this is class B&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    base *Base = <span class="built_in">new</span>(base);</span><br><span class="line">    base *a = <span class="built_in">new</span>(A);</span><br><span class="line">    base *b = <span class="built_in">new</span>(B);</span><br><span class="line">    Base-&gt;<span class="built_in">func</span>();a-&gt;<span class="built_in">func</span>();b-&gt;<span class="built_in">func</span>();</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;#########################&quot;</span>&lt;&lt;endl;</span><br><span class="line">    Base-&gt;<span class="built_in">vir_func</span>();a-&gt;<span class="built_in">vir_func</span>();b-&gt;<span class="built_in">vir_func</span>();</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;#########################&quot;</span>&lt;&lt;endl;</span><br><span class="line">    ((A *)b)-&gt;<span class="built_in">vir_func</span>();((A *)b)-&gt;<span class="built_in">func</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">normal function, this is class base</span><br><span class="line">normal function, this is class base</span><br><span class="line">normal function, this is class base</span><br><span class="line">#########################</span><br><span class="line">virtual function, this is class base</span><br><span class="line">virtual function, this is class A</span><br><span class="line">virtual function, this is class B</span><br><span class="line">#########################</span><br><span class="line">virtual function, this is class B</span><br><span class="line">normal function, this is class A</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到，当这三个指针调用func函数时，调用的都是基类base的函数。而调用虚函数vir_func时，调用的是指针指向的实际类型的函数。最后对b做强制类型转换，转换为A类型的指针，发现普通函数调用类A的函数，虚函数调用类B的函数。</p><p>以上，我们可以得出结论：<strong>当使用类的指针调用成员函数时，普通函数由指针类型决定，而虚函数由指针指向的实际类型决定</strong></p><p>虚函数的实现过程：通过对象内存中的vptr找到虚函数表vtbl，接着通过vtbl找到对应虚函数的实现区域并进行调用。</p><h2 id="三、虚函数的实现（内存布局）"><a href="#三、虚函数的实现（内存布局）" class="headerlink" title="三、虚函数的实现（内存布局）"></a>三、虚函数的实现（内存布局）</h2><p>虚函数表中只存有一个虚函数的指针地址，不存放普通函数或是构造函数的指针地址。只要有虚函数，C++类都会存在这样的一张虚函数表。不管是普通函数亦或是纯虚函数，亦或是派生类中隐式声明的这些虚函数都会生成这张虚函数表。</p><p>虚函数表创建的时间：在一个类构造的时候，创建这张虚函数表，而这个虚函数表是供整个类所共有的。虚函数表存储在对象最开始的位置。虚函数表其实就是函数指针的地址。函数调用的时候，通过函数指针指向的函数来调用函数。</p><p>虚函数表存储在对象的最开始的位置，按照声明顺序存放在表中，父类的虚函数在子类的虚函数前面。如果有虚函数覆盖，覆盖的f()函数被放在虚表中原来父类虚函数的位置，没有被覆盖的函数依旧在原来的位置。</p><p>如果有多重继承，每个父类都有自己的虚表（有几个基类就有几个虚函数表），子类的成员函数被放到了第一个父类的表中（按声明顺序来判断）。如果有虚函数覆盖，那么所有父类中的f()位置都会被替换成子类的函数指针。</p><h2 id="四、虚函数的相关问题"><a href="#四、虚函数的相关问题" class="headerlink" title="四、虚函数的相关问题"></a>四、虚函数的相关问题</h2><h3 id="1、构造函数为什么不能定义为虚函数？"><a href="#1、构造函数为什么不能定义为虚函数？" class="headerlink" title="1、构造函数为什么不能定义为虚函数？"></a>1、构造函数为什么不能定义为虚函数？</h3><p><strong>构造函数不能是虚函数</strong></p><p>首先，我们已经知道虚函数的实现是通过对象内存中的vptr来实现的。而构造函数是用来实例化一个对象的，通俗来说就是为对象内存中的值做初始化操作。那么在构造函数完成之前，vptr是没有值的，也就无法通过vptr找到作为虚函数的构造函数所在代码区。</p><h3 id="2、析构函数为什么要定义为虚函数？"><a href="#2、析构函数为什么要定义为虚函数？" class="headerlink" title="2、析构函数为什么要定义为虚函数？"></a>2、析构函数为什么要定义为虚函数？</h3><p><strong>析构函数可以是虚函数且推荐最好设置为虚函数。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>() &#123; <span class="built_in">printf</span>(<span class="string">&quot;B()\n&quot;</span>); &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">B</span>() &#123; <span class="built_in">printf</span>(<span class="string">&quot;~B()\n&quot;</span>); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">D</span>() &#123; <span class="built_in">printf</span>(<span class="string">&quot;D()\n&quot;</span>); &#125;</span><br><span class="line">    ~<span class="built_in">D</span>() &#123; <span class="built_in">printf</span>(<span class="string">&quot;~D()\n&quot;</span>); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_d;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    B* pB = <span class="keyword">new</span> <span class="built_in">D</span>();</span><br><span class="line">    <span class="keyword">delete</span> pB;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">B&lt;&gt;</span><br><span class="line">D&lt;&gt;</span><br><span class="line">~D&lt;&gt;</span><br><span class="line">~B&lt;&gt;</span><br></pre></td></tr></table></figure><p>C++中有这样的约束：执行子类构造函数之前一定会执行父类的构造函数；同理，执行子类的析构函数后，一定会执行父类的析构函数，这也是为什么建议析构函数写成虚函数的原因。</p><p>如果析构函数不是虚函数，那么delete(a)时，调用的将是基类base的析构函数。而继承时派生类通常会在基类的基础上定义自己的成员，此时我们当然是希望可以调用派生类的析构函数对新定义的成员也进行析构了。</p><h3 id="3、如何取验证虚函数表的存在？"><a href="#3、如何取验证虚函数表的存在？" class="headerlink" title="3、如何取验证虚函数表的存在？"></a>3、如何取验证虚函数表的存在？</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*Fun)</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="comment">// 取类的一个实例</span></span><br><span class="line">Base b;</span><br><span class="line">Fun pFun = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">// 把&amp;b转成int ，取得虚函数表的地址</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;虚函数表地址：&quot;</span> &lt;&lt; (<span class="type">int</span>*)(&amp;b) &lt;&lt; endl;</span><br><span class="line"><span class="comment">// 再次取址就可以得到第一个虚函数的地址了</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;虚函数表 — 第一个函数地址：&quot;</span> &lt;&lt; (<span class="type">int</span>*)*(<span class="type">int</span>*)(&amp;b) &lt;&lt; endl;</span><br><span class="line">pFun = (Fun)*((<span class="type">int</span>*)*(<span class="type">int</span>*)(&amp;b));</span><br><span class="line"><span class="built_in">pFun</span>();</span><br></pre></td></tr></table></figure><h2 id="4、纯虚函数"><a href="#4、纯虚函数" class="headerlink" title="4、纯虚函数"></a>4、纯虚函数</h2><p>纯虚函数：不能实例化对象，可以做指针和引用，拥有纯虚函数的类是抽象类。</p><p>作用：在基类中为其派生类保留一个函数的名字，以便派生类根据需要对他进行定义。如果在基类中没有保留函数名字，则无法实现多态性。</p><p>声明格式：virtual  类型  函数名(参数列表）&#x3D; 0</p><p>（1）纯虚函数没有函数体；<br>（2）最后面的“&#x3D;0”并不表示函数返回值为0，它只起形式上的作用，告诉编译系统“这是虚函数”；<br>（3）这是一个声明语句，最后有分号。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">bark</span><span class="params">()</span> </span>= <span class="number">0</span>;  <span class="comment">//声明为纯虚函数</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java设计模式</title>
      <link href="/2022/04/25/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/04/25/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java函数式编程</title>
      <link href="/2022/04/25/java%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
      <url>/2022/04/25/java%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>javaJDBC编程</title>
      <link href="/2022/04/25/javaJDBC%E7%BC%96%E7%A8%8B/"/>
      <url>/2022/04/25/javaJDBC%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>javaXML于JSON</title>
      <link href="/2022/04/25/javaXML%E4%BA%8EJSON/"/>
      <url>/2022/04/25/javaXML%E4%BA%8EJSON/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java网络编程</title>
      <link href="/2022/04/25/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
      <url>/2022/04/25/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>javaMaven基础</title>
      <link href="/2022/04/25/javaMaven%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/04/25/javaMaven%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Maven是一个Java项目管理和构建工具，它可以定义项目结构、项目依赖，并使用统一的方式进行自动化构建，是Java项目不可缺少的工具。</p><span id="more"></span><h2 id="Maven介绍"><a href="#Maven介绍" class="headerlink" title="Maven介绍"></a>Maven介绍</h2><p>Maven是专门为Java项目打造的管理和构建工具，目录结构默认如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a-maven-project</span><br><span class="line">├── pom.xml</span><br><span class="line">├── src</span><br><span class="line">│   ├── main</span><br><span class="line">│   │   ├── java</span><br><span class="line">│   │   └── resources</span><br><span class="line">│   └── test</span><br><span class="line">│       ├── java</span><br><span class="line">│       └── resources</span><br><span class="line">└── target</span><br></pre></td></tr></table></figure><p>项目的根目录<code>a-maven-project</code>是项目名，它有一个项目描述文件<code>pom.xml</code>，存放Java源码的目录是<code>src/main/java</code>，存放资源文件的目录是<code>src/main/resources</code>，存放测试源码的目录是<code>src/test/java</code>，存放测试资源的目录是<code>src/test/resources</code>，最后，所有编译、打包生成的文件都放在<code>target</code>目录里。这些就是一个Maven项目的标准目录结构。</p><p><code>pom.xml</code>中，<code>groupId</code>类似于Java的包名，通常是公司或组织名称，<code>artifactId</code>类似于Java的类名，通常是项目名称，再加上<code>version</code>，一个Maven工程就是由<code>groupId</code>，<code>artifactId</code>和<code>version</code>作为唯一标识。我们在引用其他第三方库的时候，也是通过这3个变量确定。例如，依赖<code>commons-logging</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;commons-logging&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>使用<code>&lt;dependency&gt;</code>声明一个依赖后，Maven就会自动下载这个依赖包并把它放到classpath中。</p><h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h2><p>Maven定义了几种依赖关系，分别是<code>compile</code>、<code>test</code>、<code>runtime</code>和<code>provided</code>。</p><p>如果我们要引用一个第三方组件，比如<code>okhttp</code>，如何确切地获得它的<code>groupId</code>、<code>artifactId</code>和<code>version</code>？方法是通过<a href="https://search.maven.org/">search.maven.org</a>搜索关键字，找到对应的组件后，直接复制：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/1322179230695490/l" alt="copy-maven"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java多线程</title>
      <link href="/2022/04/25/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2022/04/25/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="多线程基础"><a href="#多线程基础" class="headerlink" title="多线程基础"></a>多线程基础</h2><p>操作系统轮流让多个任务交替进行，在人开来，cpu就是在同时进行多个任务。即使是多核CPU，通常任务的数量仍远远多于cpu核数，所以任务也是交替进行的。</p><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>在计算机中，我们把一个任务称为一个进程（Process）。例如，浏览器是一个进程，视频播放器是另一个进程。</p><p>某些进程内部还需要同时执行多个子任务，例如，Word可以一边打字一边进行拼写检查。我们把子任务称为线程（Thread）。</p><p>进程和线程的关系就是：一个进程可以包含一个或多个线程，但至少会有一个线程。</p><p>实现多任务的方法有三种：多进程模式（每个进程只有一个线程）、多线程模式、多进程+多线程模式。</p><p>和多线程相比，多进程的缺点在于：</p><ul><li>创建进程比创建线程开销大，尤其是在Windows系统上</li><li>进程间通信比线程间通信要慢，因为线程间通信就是读写同一个变量，速度很快</li></ul><p>而多进程的优点在于：</p><ul><li>多进程稳定性比多线程高，因为在多进程的情况下，一个进程崩溃不会影响其他进程。</li></ul><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>Java语言内置了多线程支持：一个Java程序实际上是一个JVM进程，用一个主线程序来执行main方法，在main方法内部，我们又可以启动多个线程。此外，还有GC等其他工作线程等。</p><p>Java多线程编程的特点又在于：</p><ul><li>多线程模型是Java程序最基本的并发模型；</li><li>后续读写网络、数据库、Web开发等都依赖Java多线程模型。</li></ul><h2 id="创建新线程"><a href="#创建新线程" class="headerlink" title="创建新线程"></a>创建新线程</h2><p>创建一个新线程非常容易，需要实例化一个<code>Thread</code>实例，然后调用它的<code>start()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>();</span><br><span class="line">        t.start(); <span class="comment">// 启动新线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们希望新线程能执行指定的代码，有几种方法：</p><p>方法一：从<code>Thread</code>派生一个自定义类，然后Override<code>run()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        t.start(); <span class="comment">// 启动新线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start new thread!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：创建<code>Thread</code>实例时，传入一个<code>Runnable</code>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">        t.start(); <span class="comment">// 启动新线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start new thread!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者用Java8引入的lambda语法进一步简写为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;start new thread!&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start(); <span class="comment">// 启动新线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h3><p>可以对线程设定优先级，设定优先级的方法是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread.setPriority(<span class="type">int</span> n) <span class="comment">// 1~10, 默认值5</span></span><br></pre></td></tr></table></figure><p>优先级高的线程被操作系统调度的优先级较高，操作系统对高优先级线程可能调度更频繁，但我们决不能通过设置优先级来确保高优先级的线程一定会先执行。</p><h2 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h2><p>Java线程的状态有以下几种：</p><ul><li>New：新创建的线程，尚未执行；</li><li>Runnable：运行中的线程，正在执行<code>run()</code>方法的Java代码；</li><li>Blocked：运行中的线程，因为某些操作被阻塞而挂起；</li><li>Waiting：运行中的线程，因为某些操作在等待中；</li><li>Timed Waiting：运行中的线程，因为执行<code>sleep()</code>方法正在计时等待；</li><li>Terminated：线程已终止，因为<code>run()</code>方法执行完毕。</li></ul><p>一个线程还可以等待另一个线程直到其运行结束。例如，<code>main</code>线程在启动<code>t</code>线程后，可以通过<code>t.join()</code>等待<code>t</code>线程结束后再继续运行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;start&quot;</span>);</span><br><span class="line">        t.start();</span><br><span class="line">        t.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="中断线程"><a href="#中断线程" class="headerlink" title="中断线程"></a>中断线程</h2><p>调用<code>interrupu()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        t.start();</span><br><span class="line">        Thread.sleep(<span class="number">1</span>); <span class="comment">// 暂停1毫秒</span></span><br><span class="line">        t.interrupt(); <span class="comment">// 中断t线程</span></span><br><span class="line">        t.join(); <span class="comment">// 等待t线程结束</span></span><br><span class="line">        System.out.println(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一个常用的中断线程的方法是设置标志位。我们通常会用一个<code>running</code>标志位来标识线程是否应该继续运行，在外部线程中，通过把<code>HelloThread.running</code>置为<code>false</code>，就可以让线程结束：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">HelloThread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloThread</span>();</span><br><span class="line">        t.start();</span><br><span class="line">        Thread.sleep(<span class="number">1</span>);</span><br><span class="line">        t.running = <span class="literal">false</span>; <span class="comment">// 标志位置为false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HelloThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">running</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (running) &#123;</span><br><span class="line">            n ++;</span><br><span class="line">            System.out.println(n + <span class="string">&quot; hello!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;end!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到<code>HelloThread</code>的标志位<code>boolean running</code>是一个线程间共享的变量。线程间共享变量需要使用<code>volatile</code>关键字标记，确保每个线程都能读取到更新后的变量值。</p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java加密于安全</title>
      <link href="/2022/04/25/java%E5%8A%A0%E5%AF%86%E4%B8%8E%E5%AE%89%E5%85%A8/"/>
      <url>/2022/04/25/java%E5%8A%A0%E5%AF%86%E4%B8%8E%E5%AE%89%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="编码算法"><a href="#编码算法" class="headerlink" title="编码算法"></a>编码算法</h2><p>Ascii码，Unicode，UTF-8</p><p>URL编码：如果字符时字母、数字、<code>-</code>，<code>_</code>，<code>.</code>，<code>*</code>。则保持不变。如果URL包含中文等非Ascii字符，先转换为UTF-8编码，然后对每个<b>字节</b>以<code>%xx</code>表示。</p><p>例如：字符<code>中</code>的UTF-8编码是<code>0xe4b8ad</code>，因此，它的URL编码是<code>%E4%B8%AD</code>。URL编码总是大写。</p><p>Java标准库提供了一个<code>URLEncoder</code>类来对任意字符串进行URL编码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.URLEncoder;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">encoded</span> <span class="operator">=</span> URLEncoder.encode(<span class="string">&quot;中文!&quot;</span>, StandardCharsets.UTF_8);</span><br><span class="line">        System.out.println(encoded);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和标准的URL编码稍有不同，URLEncoder把空格字符编码成<code>+</code>，而现在的URL编码标准要求空格被编码为<code>%20</code>，不过，服务器都可以处理这两种情况。</p><p>如果服务器收到URL编码的字符串，就可以对其进行解码，还原成原始字符串。Java标准库的<code>URLDecoder</code>就可以解码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.URLDecoder;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">decoded</span> <span class="operator">=</span> URLDecoder.decode(<span class="string">&quot;%E4%B8%AD%E6%96%87%21&quot;</span>, StandardCharsets.UTF_8);</span><br><span class="line">        System.out.println(decoded);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Base64编码"><a href="#Base64编码" class="headerlink" title="Base64编码"></a>Base64编码</h3><p>URL编码是对字符串进行编码，表示成<code>%xx</code>的形式，而Base64编码是ui二进制数据进行编码，表示成文本格式。</p><p>Base64编码可以把任意长度的二进制数据变为纯文本，且只包含<code>A</code><del><code>Z</code>、<code>a</code></del><code>z</code>、<code>0</code>~&#96;9<code>、</code>+<code>、</code>&#x2F;<code>、</code>&#x3D;&#96;这些字符。它的原理是把3字节的二进制数据按6bit一组，用4个int整数表示，然后查表，把int整数用索引对应到字符，得到编码后的字符串。</p><p>在Java中，二进制数据就是<code>byte[]</code>数组。Java标准库提供了<code>Base64</code>来对<code>byte[]</code>数组进行编解码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">//编码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] input = <span class="keyword">new</span> <span class="title class_">byte</span>[] &#123; (<span class="type">byte</span>) <span class="number">0xe4</span>, (<span class="type">byte</span>) <span class="number">0xb8</span>, (<span class="type">byte</span>) <span class="number">0xad</span> &#125;;</span><br><span class="line">        <span class="type">String</span> <span class="variable">b64encoded</span> <span class="operator">=</span> Base64.getEncoder().encodeToString(input);</span><br><span class="line">        System.out.println(b64encoded);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] output = Base64.getDecoder().decode(<span class="string">&quot;5Lit&quot;</span>);</span><br><span class="line">        System.out.println(Arrays.toString(output)); <span class="comment">// [-28, -72, -83]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Base64编码的目的是把二进制数据变成文本格式，这样在很多文本中就可以处理二进制数据。但是缺点是传输效率会很低，因为它把原始数据的长度增加了1&#x2F;3.</p><h2 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h2><p>常用的哈希算法有：</p><table><thead><tr><th align="left">算法</th><th align="left">输出长度（位）</th><th align="left">输出长度（字节）</th></tr></thead><tbody><tr><td align="left">MD5</td><td align="left">128 bits</td><td align="left">16 bytes</td></tr><tr><td align="left">SHA-1</td><td align="left">160 bits</td><td align="left">20 bytes</td></tr><tr><td align="left">RipeMD-160</td><td align="left">160 bits</td><td align="left">20 bytes</td></tr><tr><td align="left">SHA-256</td><td align="left">256 bits</td><td align="left">32 bytes</td></tr><tr><td align="left">SHA-512</td><td align="left">512 bits</td><td align="left">64 bytes</td></tr></tbody></table><p>Java标准库提供了常用的哈希算法，并且有一套统一的接口。我们以MD5算法为例，看看如何对输入计算哈希：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"><span class="keyword">import</span> java.security.MessageDigest;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建一个MessageDigest实例:</span></span><br><span class="line">        <span class="type">MessageDigest</span> <span class="variable">md</span> <span class="operator">=</span> MessageDigest.getInstance(<span class="string">&quot;MD5&quot;</span>);</span><br><span class="line">        <span class="comment">// 反复调用update输入数据:</span></span><br><span class="line">        md.update(<span class="string">&quot;Hello&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        md.update(<span class="string">&quot;World&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        <span class="type">byte</span>[] result = md.digest(); <span class="comment">// 16 bytes: 68e109f0f40ca72a15e05cc22786f8e6</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="number">1</span>, result).toString(<span class="number">16</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="哈希算法的用途"><a href="#哈希算法的用途" class="headerlink" title="哈希算法的用途"></a>哈希算法的用途</h3><p>因为相同的输入永远会得到相同的输出，因此，如果输入被修改了，得到的输出就会不同。</p><p>如何判断下载到本地的软件是原始的、未经篡改的文件？我们只需要自己计算一下本地文件的哈希值，再与官网公开的哈希值对比，如果相同，说明文件下载正确，否则，说明文件已被篡改。</p><p>哈希算法的另一个重要用途是存储用户口令。如果直接将用户的原始口令存放到数据库中，会产生极大的安全风险：</p><ul><li>数据库管理员能够看到用户明文口令；</li><li>数据库数据一旦泄漏，黑客即可获取用户明文口令。</li></ul><p>不存储用户的原始口令，那么如何对用户进行认证？</p><p>方法是存储用户口令的哈希，例如，MD5。</p><p>在用户输入原始口令后，系统计算用户输入的原始口令的MD5并与数据库存储的MD5对比，如果一致，说明口令正确，否则，口令错误。</p><p>因此，数据库存储用户名和口令的表内容应该像下面这样：</p><table><thead><tr><th align="left">username</th><th align="left">password</th></tr></thead><tbody><tr><td align="left">bob</td><td align="left">f30aa7a662c728b7407c54ae6bfd27d1</td></tr><tr><td align="left">alice</td><td align="left">25d55ad283aa400af464c76d713c07ad</td></tr><tr><td align="left">tim</td><td align="left">bed128365216c019988915ed3add75fb</td></tr></tbody></table><p>但是，如果有一个预先计算好的常用口令和它们的MD5的对照表：</p><table><thead><tr><th align="left">常用口令</th><th align="left">MD5</th></tr></thead><tbody><tr><td align="left">hello123</td><td align="left">f30aa7a662c728b7407c54ae6bfd27d1</td></tr><tr><td align="left">12345678</td><td align="left">25d55ad283aa400af464c76d713c07ad</td></tr><tr><td align="left">passw0rd</td><td align="left">bed128365216c019988915ed3add75fb</td></tr><tr><td align="left">19700101</td><td align="left">570da6d5277a646f6552b8832012f5dc</td></tr><tr><td align="left">…</td><td align="left">…</td></tr><tr><td align="left">20201231</td><td align="left">6879c0ae9117b50074ce0a0d4c843060</td></tr></tbody></table><p>这个表就是彩虹表。如果用户使用了常用口令，黑客从MD5一下就能反查到原始口令：</p><p>bob的MD5：<code>f30aa7a662c728b7407c54ae6bfd27d1</code>，原始口令：<code>hello123</code>；</p><p>alice的MD5：<code>25d55ad283aa400af464c76d713c07ad</code>，原始口令：<code>12345678</code>；</p><p>tim的MD5：<code>bed128365216c019988915ed3add75fb</code>，原始口令：<code>passw0rd</code>。</p><p>这就是为什么不要使用常用密码，以及不要使用生日作为密码的原因。</p><p>即使用户使用了常用口令，我们也可以采取措施来抵御彩虹表攻击，方法是对每个口令额外添加随机数，这个方法称之为加盐（salt）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">digest = md5(salt+inputPassword)</span><br></pre></td></tr></table></figure><p>经过加盐处理的数据库表，内容如下：</p><table><thead><tr><th align="left">username</th><th align="left">salt</th><th align="left">password</th></tr></thead><tbody><tr><td align="left">bob</td><td align="left">H1r0a</td><td align="left">a5022319ff4c56955e22a74abcc2c210</td></tr><tr><td align="left">alice</td><td align="left">7$p2w</td><td align="left">e5de688c99e961ed6e560b972dab8b6a</td></tr><tr><td align="left">tim</td><td align="left">z5Sk9</td><td align="left">1eee304b92dc0d105904e7ab58fd2f64</td></tr></tbody></table><p>加盐的目的在于使黑客的彩虹表失效，即使用户使用常用口令，也无法从MD5反推原始口令。</p><h3 id="SHA-1"><a href="#SHA-1" class="headerlink" title="SHA-1"></a>SHA-1</h3><p>SHA-1也是一种哈希算法，它的输出是160 bits，即20字节。</p><p>在Java中使用SHA-1，和MD5完全一样，只需要把算法名称改为<code>&quot;SHA-1&quot;</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"><span class="keyword">import</span> java.security.MessageDigest;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建一个MessageDigest实例:</span></span><br><span class="line">        <span class="type">MessageDigest</span> <span class="variable">md</span> <span class="operator">=</span> MessageDigest.getInstance(<span class="string">&quot;SHA-1&quot;</span>);</span><br><span class="line">        <span class="comment">// 反复调用update输入数据:</span></span><br><span class="line">        md.update(<span class="string">&quot;Hello&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        md.update(<span class="string">&quot;World&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        <span class="type">byte</span>[] result = md.digest(); <span class="comment">// 20 bytes: db8ac1c259eb89d4a131b253bacfca5f319d54f2</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="number">1</span>, result).toString(<span class="number">16</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BouncyCastle"><a href="#BouncyCastle" class="headerlink" title="BouncyCastle"></a>BouncyCastle</h2><p>BouncyCastle是一个开源的第三方算法提供商；</p><p>BouncyCastle提供了很多Java标准库没有提供的哈希算法和加密算法；</p><p>使用第三方算法前需要通过<code>Security.addProvider()</code>注册。</p><h2 id="Hmac算法"><a href="#Hmac算法" class="headerlink" title="Hmac算法"></a>Hmac算法</h2><p>Hmac算法是一种标准的基于密钥的哈希算法，可以配合MD5、SHA-1等哈希算法，计算的摘要长度和原摘要算法长度相同。</p><h2 id="对称加密算法"><a href="#对称加密算法" class="headerlink" title="对称加密算法"></a>对称加密算法</h2><p>对称加密算法使用同一个密钥进行加密和解密，常用算法有DES、AES和IDEA等；</p><p>密钥长度由算法设计决定，AES的密钥长度是128&#x2F;192&#x2F;256位；</p><p>使用对称加密算法需要指定算法名称、工作模式和填充模式。</p><h2 id="口令加密算法"><a href="#口令加密算法" class="headerlink" title="口令加密算法"></a>口令加密算法</h2><p>PBE算法通过用户口令和安全的随机salt计算出Key，然后再进行加密；</p><p>Key通过口令和安全的随机salt计算得出，大大提高了安全性；</p><p>PBE算法内部使用的仍然是标准对称加密算法（例如AES）。</p><h2 id="密钥交换算法"><a href="#密钥交换算法" class="headerlink" title="密钥交换算法"></a>密钥交换算法</h2><p>DH算法是一种密钥交换协议，通信双方通过不安全的信道协商密钥，然后进行对称加密传输。</p><p>DH算法没有解决中间人攻击。</p><h2 id="非对称加密算法"><a href="#非对称加密算法" class="headerlink" title="非对称加密算法"></a>非对称加密算法</h2><p>非对称加密就是加密和解密使用的不是相同的密钥，只有同一个公钥-私钥对才能正常加解密；</p><p>只使用非对称加密算法不能防止中间人攻击。</p><h2 id="签名算法"><a href="#签名算法" class="headerlink" title="签名算法"></a>签名算法</h2><p>数字签名就是用发送方的私钥对原始数据进行签名，只有用发送方公钥才能通过签名验证。</p><p>数字签名用于：</p><ul><li>防止伪造；</li><li>防止抵赖；</li><li>检测篡改。</li></ul><p>常用的数字签名算法包括：MD5withRSA／SHA1withRSA／SHA256withRSA／SHA1withDSA／SHA256withDSA／SHA512withDSA／ECDSA等。</p><h2 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h2><p>数字证书就是集合了多种密码学算法，用于实现数据加解密、身份认证、签名等多种功能的一种安全标准。</p><p>数字证书采用链式签名管理，顶级的Root CA证书已内置在操作系统中。</p><p>数字证书存储的是公钥，可以安全公开，而私钥必须严格保密。</p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java正则表达式</title>
      <link href="/2022/04/25/java%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2022/04/25/java%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>正则表达式可以用字符串来描述规则，名用来匹配字符串。</p><h2 id="匹配规则"><a href="#匹配规则" class="headerlink" title="匹配规则"></a>匹配规则</h2><p>正则表达式的匹配规则是从左到右按规则匹配。</p><ul><li><p>有特殊字符，那需要用<code>\</code>转义。</p></li><li><p>要匹配非Ascii字符，那就用<code>\u####</code>的十六进制表示，例如<code>\u548cc</code>匹配<code>和</code>。</p></li><li><p>匹配任意一个字符，用<code>.</code></p></li><li><p>匹配任意一个数字，用<code>\d</code></p></li><li><p>匹配任意一个字母，用<code>\w</code></p></li><li><p>匹配一个空格字符，用<code>\s</code>（包括<code>\t</code>字符）</p></li><li><p>匹配一个非数字，用<code>\D</code>（类似，<code>\W</code>，<code>\S</code>）</p></li><li><p>修饰符<code>*</code>可以匹配任意个字符。例如，用<code>A\d*</code>匹配A后面跟任意个数字</p></li><li><p>修饰符<code>+</code>可以匹配至少一个字符</p></li><li><p>修饰符<code>？</code>可以匹配0个或1个字符</p></li><li><p>修饰符<code>&#123;n&#125;</code>可以精确匹配n个字符，<code>n,m</code>匹配n~m个字符，<code>&#123;n,&#125;</code>匹配至少n个字符</p></li></ul><h2 id="复杂匹配规则"><a href="#复杂匹配规则" class="headerlink" title="复杂匹配规则"></a>复杂匹配规则</h2><h3 id="匹配开头或结尾"><a href="#匹配开头或结尾" class="headerlink" title="匹配开头或结尾"></a>匹配开头或结尾</h3><p>在用正则表达式进行多行匹配时，我们用<code>^</code>表示开头，<code>$</code>表示结尾。例如：<code>^A\d&#123;3&#125;$</code></p><h3 id="匹配指定范围"><a href="#匹配指定范围" class="headerlink" title="匹配指定范围"></a>匹配指定范围</h3><p>用<code>[...]</code>匹配范围内的字符串。例如：<code>[123456789]\d&#123;6,7&#125;</code>匹配非0开头的电话号码</p><p>字符全列出来太麻烦，<code>[...]</code>也可以写为<code>[1-9]</code></p><p>要六位匹配大小写不限的十六进制数，我们可以这样写：<code>[0-9a-fA-f]&#123;6&#125;</code></p><p><code>[...]</code>还有一种排除写法，例如：<code>[^1-9]&#123;3&#125;</code>表示不包含1-9的三位字符</p><h3 id="或匹配规则"><a href="#或匹配规则" class="headerlink" title="或匹配规则"></a>或匹配规则</h3><p><code>|</code>表示或，例如：<code>AB|CD</code>匹配<code>AB</code>或者<code>CD</code></p><h3 id="使用括号"><a href="#使用括号" class="headerlink" title="使用括号"></a>使用括号</h3><p><code>learn\\s(java|php|go)</code></p><h2 id="分组匹配"><a href="#分组匹配" class="headerlink" title="分组匹配"></a>分组匹配</h2><p>例如，用正则匹配<code>区号-电话号</code>码这个规则，可以用<code>(...)</code>先把要提取的规则分组，把上述正则表达式变为<code>(\d&#123;3,4&#125;)\-(\d&#123;6,8&#125;)</code>。引入<code>java.util.regex</code>包，用<code>Pattern</code>对象匹配，匹配后获得一个<code>Matcher</code>对象，如果匹配成功，就可以直接从<code>Matcher.group(index)</code>返回子串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">p</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;(\\d&#123;3,4&#125;)\\-(\\d&#123;7,8&#125;)&quot;</span>);</span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">m</span> <span class="operator">=</span> p.matcher(<span class="string">&quot;010-12345678&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (m.matches()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">g1</span> <span class="operator">=</span> m.group(<span class="number">1</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">g2</span> <span class="operator">=</span> m.group(<span class="number">2</span>);</span><br><span class="line">            System.out.println(g1);</span><br><span class="line">            System.out.println(g2);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;匹配失败!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要特别注意，<code>Matcher.group(index)</code>方法的参数用1表示第一个子串，2表示第二个子串。如果我们传入0会得到什么呢？答案是<code>010-12345678</code>，即整个正则匹配到的字符串。</p><h3 id="Pattern"><a href="#Pattern" class="headerlink" title="Pattern"></a>Pattern</h3><p>我们在前面的代码中用到的正则表达式代码是<code>String.matches()</code>方法，而我们在分组提取的代码中用的是<code>java.util.regex</code>包里面的<code>Pattern</code>类和<code>Matcher</code>类。实际上这两种代码本质上是一样的，因为<code>String.matches()</code>方法内部调用的就是<code>Pattern</code>和<code>Matcher</code>类的方法。</p><p>但是反复使用<code>String.matches()</code>对同一个正则表达式进行多次匹配效率较低，因为每次都会创建出一样的<code>Pattern</code>对象。完全可以先创建出一个<code>Pattern</code>对象，然后反复使用，就可以实现编译一次，多次匹配：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;(\\d&#123;3,4&#125;)\\-(\\d&#123;7,8&#125;)&quot;</span>);</span><br><span class="line">        pattern.matcher(<span class="string">&quot;010-12345678&quot;</span>).matches(); <span class="comment">// true</span></span><br><span class="line">        pattern.matcher(<span class="string">&quot;021-123456&quot;</span>).matches(); <span class="comment">// false</span></span><br><span class="line">        pattern.matcher(<span class="string">&quot;022#1234567&quot;</span>).matches(); <span class="comment">// false</span></span><br><span class="line">        <span class="comment">// 获得Matcher对象:</span></span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(<span class="string">&quot;010-12345678&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (matcher.matches()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">whole</span> <span class="operator">=</span> matcher.group(<span class="number">0</span>); <span class="comment">// &quot;010-12345678&quot;, 0表示匹配的整个字符串</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">area</span> <span class="operator">=</span> matcher.group(<span class="number">1</span>); <span class="comment">// &quot;010&quot;, 1表示匹配的第1个子串</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">tel</span> <span class="operator">=</span> matcher.group(<span class="number">2</span>); <span class="comment">// &quot;12345678&quot;, 2表示匹配的第2个子串</span></span><br><span class="line">            System.out.println(area);</span><br><span class="line">            System.out.println(tel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>Matcher</code>时，必须首先调用<code>matches()</code>判断是否匹配成功，匹配成功后，才能调用<code>group()</code>提取子串。</p><h2 id="非贪婪匹配"><a href="#非贪婪匹配" class="headerlink" title="非贪婪匹配"></a>非贪婪匹配</h2><p>正则表达式默认使用贪婪匹配，任何一个规则，它总是尽可能多地向后匹配。</p><p>在规则后面加个<code>?</code>即可表示非贪婪匹配。例如：<code>(\d+?)(0*)</code>就会用非贪婪地规则匹配<code>\d+</code></p><h2 id="搜索和替换"><a href="#搜索和替换" class="headerlink" title="搜索和替换"></a>搜索和替换</h2><h3 id="分割字符串"><a href="#分割字符串" class="headerlink" title="分割字符串"></a>分割字符串</h3><p><code>String.split()</code>方法传入的正是正则表达式。我们来看下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;a b c&quot;</span>.split(<span class="string">&quot;\\s&quot;</span>); <span class="comment">// &#123; &quot;a&quot;, &quot;b&quot;, &quot;c&quot; &#125;</span></span><br><span class="line"><span class="string">&quot;a b  c&quot;</span>.split(<span class="string">&quot;\\s&quot;</span>); <span class="comment">// &#123; &quot;a&quot;, &quot;b&quot;, &quot;&quot;, &quot;c&quot; &#125;</span></span><br><span class="line"><span class="string">&quot;a, b ;; c&quot;</span>.split(<span class="string">&quot;[\\,\\;\\s]+&quot;</span>); <span class="comment">// &#123; &quot;a&quot;, &quot;b&quot;, &quot;c&quot; &#125;</span></span><br></pre></td></tr></table></figure><h3 id="搜索字符串"><a href="#搜索字符串" class="headerlink" title="搜索字符串"></a>搜索字符串</h3><p>看个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;the quick brown fox jumps over the lazy dog.&quot;</span>;</span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">p</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;\\wo\\w&quot;</span>);</span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">m</span> <span class="operator">=</span> p.matcher(s);</span><br><span class="line">        <span class="keyword">while</span> (m.find()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">sub</span> <span class="operator">=</span> s.substring(m.start(), m.end());</span><br><span class="line">            System.out.println(sub);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="替换字符串"><a href="#替换字符串" class="headerlink" title="替换字符串"></a>替换字符串</h3><p>使用正则表达式替换字符串可以直接调用<code>String.replaceAll()</code>，它的第一个参数是正则表达式，第二个参数是待替换的字符串。我们还是来看例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;The     quick\t\t brown   fox  jumps   over the  lazy dog.&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">r</span> <span class="operator">=</span> s.replaceAll(<span class="string">&quot;\\s+&quot;</span>, <span class="string">&quot; &quot;</span>);</span><br><span class="line">        System.out.println(r); <span class="comment">// &quot;The quick brown fox jumps over the lazy dog.&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码把不规范的连续空格分隔的句子变成了规范的句子。可见，灵活使用正则表达式可以大大降低代码量。</p><h3 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h3><p>如果我们要把搜索到的指定字符串按规则匹配，比如前后各加一个<code>&lt;b&gt;xxxx&lt;/b&gt;</code>，这时候，使用<code>replaceAll()</code>的时候，我们传入的第二个参数可以使用<code>$1</code>、<code>$2</code>来反向引用匹配到的字串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;the quick brown fox jumps over the lazy dog.&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">r</span> <span class="operator">=</span> s.replaceAll(<span class="string">&quot;\\s([a-z]&#123;4&#125;)\\s&quot;</span>, <span class="string">&quot; &lt;b&gt;$1&lt;/b&gt; &quot;</span>);</span><br><span class="line">        System.out.println(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java单元测试</title>
      <link href="/2022/04/25/java%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
      <url>/2022/04/25/java%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="编写Junit测试"><a href="#编写Junit测试" class="headerlink" title="编写Junit测试"></a>编写Junit测试</h2><p>单元测试就是针对最小的功能单元编写测试代码。Java程序最小的功能单元是方法，因此，对Java程序进行单元测试就是针对整个Java方法的测试。</p><p>测试驱动开发（Test-Driven Development）：是指先编写接口，紧接着编写测试，编写玩测试后，才开始真正编写实现代码。在编写实现代码的过程中，一边写，一边测，什么时候测试全部通过了，那就表示编写的实现完成了。</p><p>如果使用main方法，不能把测试代码分离；不能打印出测试结果和期望结果；很难编写一组通用的测试代码。</p><p>因此，我们需要一种测试框架，帮助我们编写测试。</p><h3 id="JUnit"><a href="#JUnit" class="headerlink" title="JUnit"></a>JUnit</h3><p>JUnit是一个开源的Java语言的单元测试框架，专门针对Java设计。使用JUnit编写单元测试的好处在于，我们可以非常简单的组织测试代码，并随时运行它们。JUnit会给出成功的测试和失败的测试，还可以生成测试报告，不仅包含测试的成功率，还可以统计测试的代码覆盖率。对高质量的代码来说，测试覆盖率应该在80%以上。</p><p>此外，几乎所有的IDE工具都继承了JUnit，这样我们就可以直接在IDE中编写并运行JUnit测试。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itranswarp.learnjava;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.jupiter.api.Assertions.*;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FactorialTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testFact</span><span class="params">()</span> &#123;</span><br><span class="line">        assertEquals(<span class="number">1</span>, Factorial.fact(<span class="number">1</span>));</span><br><span class="line">        assertEquals(<span class="number">2</span>, Factorial.fact(<span class="number">2</span>));</span><br><span class="line">        assertEquals(<span class="number">6</span>, Factorial.fact(<span class="number">3</span>));</span><br><span class="line">        assertEquals(<span class="number">3628800</span>, Factorial.fact(<span class="number">10</span>));</span><br><span class="line">        assertEquals(<span class="number">2432902008176640000L</span>, Factorial.fact(<span class="number">20</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>assertTrue()</code>: 期待结果为<code>true</code></li><li><code>assertFalse()</code>: 期待结果为<code>false</code></li><li><code>assertNotNull()</code>: 期待结果为非<code>null</code></li><li><code>assertArrayEquals()</code>: 期待结果为数组并与期望数组每个元素的值均相等</li><li>…</li></ul><h3 id="单元测试的好处"><a href="#单元测试的好处" class="headerlink" title="单元测试的好处"></a>单元测试的好处</h3><ul><li>确保单个方法正确按预期运行</li><li>作为示例代码，演示如何调用该方法</li></ul><h2 id="使用Fixture"><a href="#使用Fixture" class="headerlink" title="使用Fixture"></a>使用Fixture</h2><p>在测试的时候，我们经常遇到一个对象需要初始化，测试完可能还需要清理的情况。如果每个<code>@Test</code>方法都写一遍这样的重复代码，显然比较麻烦。</p><p>JUnit提供了编写测试前准备、测试后清理的固定代码，我们称之为Fixture。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BeforeEach</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>.calculator = <span class="keyword">new</span> <span class="title class_">Calculator</span>();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@AfterEach</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tearDown</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>.calculator = <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><code>@BeforeEach</code>和<code>@AfterEach</code>的方法会在运行每个@Test方法前后自动运行。</p><p>JUnit还提供了<code>@BeforeAll</code>和<code>@AfterAll</code>，它们在运行所有@Test前后运行，并且仅运行一次。因此，它们只能初始化静态变量。事实上，它们也只能标注在静态方法上。</p><h2 id="异常测试"><a href="#异常测试" class="headerlink" title="异常测试"></a>异常测试</h2><p>在编写JUnit测试的时候，除了正常的输入输出，我们还要特别针对可能导致异常的情况进行测试。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testNegative</span><span class="params">()</span> &#123;</span><br><span class="line">    assertThrows(IllegalArgumentException.class, <span class="keyword">new</span> <span class="title class_">Executable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">            Factorial.fact(-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JUnit提供<code>assertThrows()</code>来期望捕获一个指定的异常。第二个参数<code>Executable</code>封装了我们要执行的会产生异常的代码。当我们执行<code>Factorial.fact(-1)</code>时，必定抛出<code>IllegalArgumentException</code>。<code>assertThrows()</code>在捕获到指定异常时表示通过测试，未捕获到异常，或者捕获到的异常类型不对，均表示测试失败。</p><p>有些童鞋会觉得编写一个<code>Executable</code>的匿名类太繁琐了。实际上，Java 8开始引入了函数式编程，所有单方法接口都可以简写如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testNegative</span><span class="params">()</span> &#123;</span><br><span class="line">    assertThrows(IllegalArgumentException.class, () -&gt; &#123;</span><br><span class="line">        Factorial.fact(-<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述奇怪的<code>-&gt;</code>语法就是函数式接口的实现代码，我们会在后面详细介绍。现在，我们只需要通过这种固定的代码编写能抛出异常的语句即可。</p><h2 id="条件测试"><a href="#条件测试" class="headerlink" title="条件测试"></a>条件测试</h2><p>可以在测试前面加注解，满足某个条件才进行的测试。</p><h2 id="参数化测试"><a href="#参数化测试" class="headerlink" title="参数化测试"></a>参数化测试</h2><p>参数化测试和普通测试稍微不同的地方在于，一个测试方法需要接收至少一个参数，然后，传入一组参数反复运行。</p><p>JUnit提供了一个<code>@ParameterizedTest</code>注解，用来进行参数化测试。</p><p>假设我们想对<code>Math.abs()</code>进行测试，先用一组正数进行测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="meta">@ValueSource(ints = &#123; 0, 1, 5, 100 &#125;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testAbs</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    assertEquals(x, Math.abs(x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再用一组负数进行测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="meta">@ValueSource(ints = &#123; -1, -5, -100 &#125;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testAbsNegative</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    assertEquals(-x, Math.abs(x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数如何传入？</p><p>最简单的方法是通过<code>@MethodSource</code>注解，它允许我们编写一个同名的静态方法来提供测试参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="meta">@MethodSource</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testCapitalize</span><span class="params">(String input, String result)</span> &#123;</span><br><span class="line">    assertEquals(result, StringUtils.capitalize(input));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> List&lt;Arguments&gt; <span class="title function_">testCapitalize</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> List.of( <span class="comment">// arguments:</span></span><br><span class="line">            Arguments.arguments(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;Abc&quot;</span>), <span class="comment">//</span></span><br><span class="line">            Arguments.arguments(<span class="string">&quot;APPLE&quot;</span>, <span class="string">&quot;Apple&quot;</span>), <span class="comment">//</span></span><br><span class="line">            Arguments.arguments(<span class="string">&quot;gooD&quot;</span>, <span class="string">&quot;Good&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码很容易理解：静态方法<code>testCapitalize()</code>返回了一组测试参数，每个参数都包含两个<code>String</code>，正好作为测试方法的两个参数传入。</p><p>如果静态方法和测试方法的名称不同，@MethodSource也允许指定方法名。但使用默认同名方法最方便。</p><p>另一种传入测试参数的方法是使用<code>@CsvSource</code>，它的每一个字符串表示一行，一行包含的若干参数用<code>,</code>分隔，因此，上述测试又可以改写如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="meta">@CsvSource(&#123; &quot;abc, Abc&quot;, &quot;APPLE, Apple&quot;, &quot;gooD, Good&quot; &#125;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testCapitalize</span><span class="params">(String input, String result)</span> &#123;</span><br><span class="line">    assertEquals(result, StringUtils.capitalize(input));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果有成百上千的测试输入，那么，直接写<code>@CsvSource</code>就很不方便。这个时候，我们可以把测试数据提到一个独立的CSV文件中，然后标注上<code>@CsvFileSource</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="meta">@CsvFileSource(resources = &#123; &quot;/test-capitalize.csv&quot; &#125;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testCapitalizeUsingCsvFile</span><span class="params">(String input, String result)</span> &#123;</span><br><span class="line">    assertEquals(result, StringUtils.capitalize(input));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JUnit只在classpath中查找指定的CSV文件，因此，<code>test-capitalize.csv</code>这个文件要放到<code>test</code>目录下，内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">apple, Apple</span><br><span class="line">HELLO, Hello</span><br><span class="line">JUnit, Junit</span><br><span class="line">reSource, Resource</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java时间与日期</title>
      <link href="/2022/04/25/java%E6%97%B6%E9%97%B4%E4%B8%8E%E6%97%A5%E6%9C%9F/"/>
      <url>/2022/04/25/java%E6%97%B6%E9%97%B4%E4%B8%8E%E6%97%A5%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="Date和Calendar"><a href="#Date和Calendar" class="headerlink" title="Date和Calendar"></a>Date和Calendar</h2><p>要获取当前时间戳，可以使用<code>System.currentTimeMillis()</code>，这是Java程序获取时间戳最常用的方法。</p><h3 id="标准库API"><a href="#标准库API" class="headerlink" title="标准库API"></a>标准库API</h3><p>我们再来看一下Java标准库提供的API。Java标准库有两套处理日期和时间的API：</p><ul><li>一套定义在<code>java.util</code>这个包里面，主要包括<code>Date</code>、<code>Calendar</code>和<code>TimeZone</code>这几个类；</li><li>一套新的API是在Java 8引入的，定义在<code>java.time</code>这个包里面，主要包括<code>LocalDateTime</code>、<code>ZonedDateTime</code>、<code>ZoneId</code>等。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javaIO</title>
      <link href="/2022/04/25/javaIO/"/>
      <url>/2022/04/25/javaIO/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OperateCSVfile</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">inFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C://in.csv&quot;</span>); <span class="comment">// 读取的CSV文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">outFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C://out.csv&quot;</span>);<span class="comment">//写出的CSV文件</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">inString</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(inFile));</span><br><span class="line">            <span class="type">BufferedWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(outFile));</span><br><span class="line">            <span class="keyword">while</span>((inString = reader.readLine())!= <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//处理操作</span></span><br><span class="line">               writer.write(inString);</span><br><span class="line">               writer.newLine();</span><br><span class="line">            &#125;</span><br><span class="line">            reader.close();</span><br><span class="line">            writer.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException ex) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没找到文件！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;读写文件出错！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="File对象（略）"><a href="#File对象（略）" class="headerlink" title="File对象（略）"></a>File对象（略）</h2><h2 id="InputStream"><a href="#InputStream" class="headerlink" title="InputStream"></a>InputStream</h2><p>InputStream是Java标准库提供的最基本的输入流，它位于java.io这个包里。</p><p>注意，InputStream并不是一个接口，而是一个抽象类，它是所有输入流的超类。这个抽象类定义的一个最重要的方法就是int read()，签名如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure><p>这个方法会读取输入流的下一个字节，并返回字节表示的int值（0~255）。如果已经读到末尾，则返回-1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src/readme.txt&quot;</span>)) &#123;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        <span class="keyword">while</span> ((n = input.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// 编译器在此自动为我们写入finally并调用close()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="缓冲"><a href="#缓冲" class="headerlink" title="缓冲"></a>缓冲</h3><p><code>InputStream</code>提供了两个重载方法来支持读取多个字节：</p><ul><li><code>int read(byte[] b)</code>：读取若干字节并填充到<code>byte[]</code>数组，返回读取的字节数</li><li><code>int read(byte[] b, int off, int len)</code>：指定<code>byte[]</code>数组的偏移量和最大填充数</li></ul><p>这时read()方法的返回值是实际读取了多少个字节。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src/readme.txt&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">// 定义1000个字节大小的缓冲区:</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1000</span>];</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        <span class="keyword">while</span> ((n = input.read(buffer)) != -<span class="number">1</span>) &#123; <span class="comment">// 读取到缓冲区</span></span><br><span class="line">            System.out.println(<span class="string">&quot;read &quot;</span> + n + <span class="string">&quot; bytes.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h2><p>在调用<code>InputStream</code>的<code>read()</code>方法读取数据时，我们说<code>read()</code>方法是阻塞（Blocking）的。它的意思是，对于下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line">n = input.read(); <span class="comment">// 必须等待read()方法返回才能执行下一行代码</span></span><br><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> n;</span><br></pre></td></tr></table></figure><p>执行到第二行代码时，必须等<code>read()</code>方法返回后才能继续。因为读取IO流相比执行普通代码，速度会慢很多，因此，无法确定<code>read()</code>方法调用到底要花费多长时间。</p><h2 id="InputStream实现类"><a href="#InputStream实现类" class="headerlink" title="InputStream实现类"></a>InputStream实现类</h2><p>用<code>FileInputStream</code>可以从文件获取输入流，这是<code>InputStream</code>常用的一个实现类。此外，<code>ByteArrayInputStream</code>可以在内存中模拟一个<code>InputStream</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">byte</span>[] data = &#123; <span class="number">72</span>, <span class="number">101</span>, <span class="number">108</span>, <span class="number">108</span>, <span class="number">111</span>, <span class="number">33</span> &#125;;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(data)) &#123;</span><br><span class="line">            <span class="type">int</span> n;</span><br><span class="line">            <span class="keyword">while</span> ((n = input.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println((<span class="type">char</span>)n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是面向抽象编程原则的应用：接受<code>InputStream</code>抽象类型，而不是具体的<code>FileInputStream</code>类型，从而使得代码可以处理<code>InputStream</code>的任意实现类。</p><h2 id="OutputStream"><a href="#OutputStream" class="headerlink" title="OutputStream"></a>OutputStream</h2><p>和<code>InputStream</code>类似，<code>OutputStream</code>也是抽象类，它是所有输出流的超类。这个抽象类定义的一个最重要的方法就是<code>void write(int b)</code>，签名如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> b)</span> <span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure><p>这个方法会写入一个字节到输出流。要注意的是，虽然传入的是<code>int</code>参数，但只会写入一个字节，即只写入<code>int</code>最低8位表示字节的部分（相当于<code>b &amp; 0xff</code>）。</p><p>和<code>InputStream</code>类似，<code>OutputStream</code>也提供了<code>close()</code>方法关闭输出流，以便释放系统资源。要特别注意：<code>OutputStream</code>还提供了一个<code>flush()</code>方法，它的目的是将缓冲区的内容真正输出到目的地。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">OutputStream</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;out/readme.txt&quot;</span>);</span><br><span class="line">    output.write(<span class="number">72</span>); <span class="comment">// H</span></span><br><span class="line">    output.write(<span class="number">101</span>); <span class="comment">// e</span></span><br><span class="line">    output.write(<span class="number">108</span>); <span class="comment">// l</span></span><br><span class="line">    output.write(<span class="number">108</span>); <span class="comment">// l</span></span><br><span class="line">    output.write(<span class="number">111</span>); <span class="comment">// o</span></span><br><span class="line">    output.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是每次写入一个字节十分麻烦，可以用<code>OutputStream</code>提供的重载方法<code>void write(byte[])</code>来实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">OutputStream</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;out/readme.txt&quot;</span>);</span><br><span class="line">    output.write(<span class="string">&quot;Hello&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>)); <span class="comment">// Hello</span></span><br><span class="line">    output.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ByteArrayOutputStream</code>可以在内存中模拟一个<code>OutputStream</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">byte</span>[] data;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ByteArrayOutputStream</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>()) &#123;</span><br><span class="line">            output.write(<span class="string">&quot;Hello &quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            output.write(<span class="string">&quot;world!&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            data = output.toByteArray();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(data, <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Filter模式"><a href="#Filter模式" class="headerlink" title="Filter模式"></a>Filter模式</h2><p>Java的IO标准库使用Filter模式为<code>InputStream</code>和<code>OutputStream</code>增加功能：</p><ul><li>可以把一个<code>InputStream</code>和任意个<code>FilterInputStream</code>组合；</li><li>可以把一个<code>OutputStream</code>和任意个<code>FilterOutputStream</code>组合。</li></ul><p>Filter模式可以在运行期动态增加功能（又称Decorator模式）。</p><h2 id="操作Zip"><a href="#操作Zip" class="headerlink" title="操作Zip"></a>操作Zip</h2><p><code>ZipInputStream</code>可以读取zip格式的流，<code>ZipOutputStream</code>可以把多份数据写入zip包；</p><p>配合<code>FileInputStream</code>和<code>FileOutputStream</code>就可以读写zip文件。</p><h2 id="读取classpath资源"><a href="#读取classpath资源" class="headerlink" title="读取classpath资源"></a>读取classpath资源</h2><p>把资源存储在classpath中可以避免文件路径依赖；</p><p><code>Class</code>对象的<code>getResourceAsStream()</code>可以从classpath中读取指定资源；</p><p>根据classpath读取资源时，需要检查返回的<code>InputStream</code>是否为<code>null</code>。</p><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>序列化是指把一个Java对象变成二进制内容，本质上就是一个byte[]数组。</p><p>序列化后可以把byte[]保存到文件中，或者把byte[]通过网络传输，然后经过反序列化就可以变回Java对象。</p><p>一个Java对象要能序列化，必须实现一个特殊的java.io.Serializable接口。Serializable接口没有定义任何方法，是一个空接口，这样的接口称为“标记接口”（Marker Interface），实现标记接口的类仅仅是给自身贴了个标记，并没有增加任何方法。</p><h3 id="序列化-1"><a href="#序列化-1" class="headerlink" title="序列化"></a>序列化</h3><p>把一个Java对象变为<code>byte[]</code>数组，需要使用<code>ObjectOutputStream</code>。它负责把一个Java对象写入一个字节流：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">buffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ObjectOutputStream</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(buffer)) &#123;</span><br><span class="line">            <span class="comment">// 写入int:</span></span><br><span class="line">            output.writeInt(<span class="number">12345</span>);</span><br><span class="line">            <span class="comment">// 写入String:</span></span><br><span class="line">            output.writeUTF(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">            <span class="comment">// 写入Object:</span></span><br><span class="line">            output.writeObject(Double.valueOf(<span class="number">123.456</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(buffer.toByteArray()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ObjectOutputStream</code>既可以写入基本类型，如<code>int</code>，<code>boolean</code>，也可以写入<code>String</code>（以UTF-8编码），还可以写入实现了<code>Serializable</code>接口的<code>Object</code>。</p><h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h3><p>和<code>ObjectOutputStream</code>相反，<code>ObjectInputStream</code>负责从一个字节流读取Java对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try (ObjectInputStream input = new ObjectInputStream(...)) &#123;</span><br><span class="line">    int n = input.readInt();</span><br><span class="line">    String s = input.readUTF();</span><br><span class="line">    Double d = (Double) input.readObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了能读取基本类型和<code>String</code>类型外，调用<code>readObject()</code>可以直接返回一个<code>Object</code>对象。要把它变成一个特定类型，必须强制转型。</p><p><code>readObject()</code>可能抛出的异常有：</p><ul><li><code>ClassNotFoundException</code>：没有找到对应的Class；</li><li><code>InvalidClassException</code>：Class不匹配。</li></ul><p>对于<code>ClassNotFoundException</code>，这种情况常见于一台电脑上的Java程序把一个Java对象，例如，<code>Person</code>对象序列化以后，通过网络传给另一台电脑上的另一个Java程序，但是这台电脑的Java程序并没有定义<code>Person</code>类，所以无法反序列化。</p><p>对于<code>InvalidClassException</code>，这种情况常见于序列化的<code>Person</code>对象定义了一个<code>int</code>类型的<code>age</code>字段，但是反序列化时，<code>Person</code>类定义的<code>age</code>字段被改成了<code>long</code>类型，所以导致class不兼容。</p><p>为了避免这种class定义变动导致的不兼容，Java的序列化允许class定义一个特殊的<code>serialVersionUID</code>静态变量，用于标识Java类的序列化“版本”，通常可以由IDE自动生成。如果增加或修改了字段，可以改变<code>serialVersionUID</code>的值，这样就能自动阻止不匹配的class版本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class Person implements Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID = 2709425275741743919L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要特别注意反序列化的几个重要特点：</p><p>反序列化时，由JVM直接构造出Java对象，不调用构造方法，构造方法内部的代码，在反序列化时根本不可能执行。</p><h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><p>Java的序列化机制仅适用于Java，如果需要与其它语言交换数据，必须使用通用的序列化方法，例如JSON。</p><h2 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h2><p><code>Reader</code>是Java的IO库提供的另一个输入流接口。和<code>InputStream</code>的区别是，<code>InputStream</code>是一个字节流，即以<code>byte</code>为单位读取，而<code>Reader</code>是一个字符流，即以<code>char</code>为单位读取：</p><table><thead><tr><th align="left">InputStream</th><th align="left">Reader</th></tr></thead><tbody><tr><td align="left">字节流，以<code>byte</code>为单位</td><td align="left">字符流，以<code>char</code>为单位</td></tr><tr><td align="left">读取字节（-1，0~255）：<code>int read()</code></td><td align="left">读取字符（-1，0~65535）：<code>int read()</code></td></tr><tr><td align="left">读到字节数组：<code>int read(byte[] b)</code></td><td align="left">读到字符数组：<code>int read(char[] c)</code></td></tr></tbody></table><h3 id="FileReader"><a href="#FileReader" class="headerlink" title="FileReader"></a>FileReader</h3><p><code>FileReader</code>是<code>Reader</code>的一个子类，它可以打开文件并获取<code>Reader</code>。下面的代码演示了如何完整地读取一个<code>FileReader</code>的所有字符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 创建一个FileReader对象:</span></span><br><span class="line">    <span class="type">Reader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;src/readme.txt&quot;</span>); <span class="comment">// 字符编码是???</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> reader.read(); <span class="comment">// 反复调用read()方法，直到返回-1</span></span><br><span class="line">        <span class="keyword">if</span> (n == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println((<span class="type">char</span>)n); <span class="comment">// 打印char</span></span><br><span class="line">    &#125;</span><br><span class="line">    reader.close(); <span class="comment">// 关闭流</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要避免乱码问题，我们需要在创建<code>FileReader</code>时指定编码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Reader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;src/readme.txt&quot;</span>, StandardCharsets.UTF_8);</span><br></pre></td></tr></table></figure><p>Reader类也有缓冲区：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">Reader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;src/readme.txt&quot;</span>, StandardCharsets.UTF_8)) &#123;</span><br><span class="line">        <span class="type">char</span>[] buffer = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1000</span>];</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        <span class="keyword">while</span> ((n = reader.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;read &quot;</span> + n + <span class="string">&quot; chars.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CharArrayReader"><a href="#CharArrayReader" class="headerlink" title="CharArrayReader"></a>CharArrayReader</h3><p><code>CharArrayReader</code>可以在内存中模拟一个<code>Reader</code>，它的作用实际上是把一个<code>char[]</code>数组变成一个<code>Reader</code>，这和<code>ByteArrayInputStream</code>非常类似：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">Reader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CharArrayReader</span>(<span class="string">&quot;Hello&quot;</span>.toCharArray())) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="StringReader"><a href="#StringReader" class="headerlink" title="StringReader"></a>StringReader</h3><p><code>StringReader</code>可以直接把<code>String</code>作为数据源，它和<code>CharArrayReader</code>几乎一样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">Reader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringReader</span>(<span class="string">&quot;Hello&quot;</span>)) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Reader</code>是基于<code>InputStream</code>构造的：可以通过<code>InputStreamReader</code>在指定编码的同时将任何<code>InputStream</code>转换为<code>Reader</code>。</p><h2 id="Writer"><a href="#Writer" class="headerlink" title="Writer"></a>Writer</h2><p>同Reader</p><h2 id="PrintWriter"><a href="#PrintWriter" class="headerlink" title="PrintWriter"></a>PrintWriter</h2><p><code>PrintStream</code>是一种能接收各种数据类型的输出，打印数据时比较方便：</p><ul><li><code>System.out</code>是标准输出；</li><li><code>System.err</code>是标准错误输出。</li></ul><p><code>PrintWriter</code>是基于<code>Writer</code>的输出。</p><h2 id="使用Files"><a href="#使用Files" class="headerlink" title="使用Files"></a>使用Files</h2><p>从Java 7开始，提供了<code>Files</code>这个工具类，能极大地方便我们读写文件。</p><p>虽然<code>Files</code>是<code>java.nio</code>包里面的类，但他俩封装了很多读写文件的简单方法，例如，我们要把一个文件的全部内容读取为一个<code>byte[]</code>，可以这么写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span>[] data = Files.readAllBytes(Path.of(<span class="string">&quot;/path/to/file.txt&quot;</span>));</span><br></pre></td></tr></table></figure><p>如果是文本文件，可以把一个文件的全部内容读取为<code>String</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认使用UTF-8编码读取:</span></span><br><span class="line"><span class="type">String</span> <span class="variable">content1</span> <span class="operator">=</span> Files.readString(Path.of(<span class="string">&quot;/path/to/file.txt&quot;</span>));</span><br><span class="line"><span class="comment">// 可指定编码:</span></span><br><span class="line"><span class="type">String</span> <span class="variable">content2</span> <span class="operator">=</span> Files.readString(Path.of(<span class="string">&quot;/path&quot;</span>, <span class="string">&quot;to&quot;</span>, <span class="string">&quot;file.txt&quot;</span>), StandardCharsets.ISO_8859_1);</span><br><span class="line"><span class="comment">// 按行读取并返回每行内容:</span></span><br><span class="line">List&lt;String&gt; lines = Files.readAllLines(Path.of(<span class="string">&quot;/path/to/file.txt&quot;</span>));</span><br></pre></td></tr></table></figure><p>写入文件也非常方便：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写入二进制文件:</span></span><br><span class="line"><span class="type">byte</span>[] data = ...</span><br><span class="line">Files.write(Path.of(<span class="string">&quot;/path/to/file.txt&quot;</span>), data);</span><br><span class="line"><span class="comment">// 写入文本并指定编码:</span></span><br><span class="line">Files.writeString(Path.of(<span class="string">&quot;/path/to/file.txt&quot;</span>), <span class="string">&quot;文本内容...&quot;</span>, StandardCharsets.ISO_8859_1);</span><br><span class="line"><span class="comment">// 按行写入文本:</span></span><br><span class="line">List&lt;String&gt; lines = ...</span><br><span class="line">Files.write(Path.of(<span class="string">&quot;/path/to/file.txt&quot;</span>), lines);</span><br></pre></td></tr></table></figure><p>此外，<code>Files</code>工具类还有<code>copy()</code>、<code>delete()</code>、<code>exists()</code>、<code>move()</code>等快捷方法操作文件和目录。</p><p>最后需要特别注意的是，<code>Files</code>提供的读写方法，受内存限制，只能读写小文件，例如配置文件等，不可一次读入几个G的大文件。读写大型文件仍然要使用文件流，每次只读写一部分文件内容。</p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java集合</title>
      <link href="/2022/04/25/java%E9%9B%86%E5%90%88/"/>
      <url>/2022/04/25/java%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>List, equals方法, Map, hashCode, EnumMap, TreeMap, Properties, Set, Queue, PriorityQueue, Deque, Stack, Iterator, Collections</p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java泛型</title>
      <link href="/2022/04/25/java%E6%B3%9B%E5%9E%8B/"/>
      <url>/2022/04/25/java%E6%B3%9B%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>泛型是一种“代码模板”，可以用一套代码套用各种类型。</p><span id="more"></span><p>例如，ArrayList就是一种模板<code>ArrayList&lt;T&gt;</code>，可以处理多种类型的数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(T e)</span> &#123;...&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;...&#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>T可以是任何class。这样一来，我们编写一次模板，就可以创建任意类型的ArrayList。</p><h2 id="使用泛型"><a href="#使用泛型" class="headerlink" title="使用泛型"></a>使用泛型</h2><p>使用泛型时，把泛型参数<code>&lt;T&gt;</code>替换为需要的class类型，例如：<code>ArrayList&lt;String&gt;</code>，<code>ArrayList&lt;Number&gt;</code>等；</p><p>可以省略编译器能自动推断出的类型，例如：<code>List&lt;String&gt; list = new ArrayList&lt;&gt;();</code>；</p><p>不指定泛型参数类型时，编译器会给出警告，且只能将<code>&lt;T&gt;</code>视为<code>Object</code>类型；</p><p>可以在接口中定义泛型类型，实现此接口的类必须实现正确的泛型类型。</p><h2 id="编写泛型"><a href="#编写泛型" class="headerlink" title="编写泛型"></a>编写泛型</h2><p>编写泛型时，需要定义泛型类型<code>&lt;T&gt;</code>；</p><p>静态方法不能引用泛型类型<code>&lt;T&gt;</code>，必须定义其他类型（例如<code>&lt;K&gt;</code>）来实现静态泛型方法；</p><p>泛型可以同时定义多种类型，例如<code>Map&lt;K, V&gt;</code>。</p><h2 id="擦拭法"><a href="#擦拭法" class="headerlink" title="擦拭法"></a>擦拭法</h2><p>泛型是一种类似“模板代码”的技术，不同语言的泛型实现方式不一定相同。Java语言的泛型实现方式是擦拭法（Type Erasure）。</p><p>所谓擦拭法是指，虚拟机对泛型其实一无所知，所有的工作都是编译器做的。</p><p>因此，Java使用擦拭法实现泛型，导致了：</p><ul><li>编译器把类型<code>&lt;T&gt;</code>视为<code>object</code>；</li><li>编译器根据<code>T</code>实现安全地强制转型。</li></ul><p>使用泛型的时候，我们编写的代码也是编译器看到的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;String&gt; p = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">first</span> <span class="operator">=</span> p.getFirst();</span><br><span class="line"><span class="type">String</span> <span class="variable">last</span> <span class="operator">=</span> p.getLast();</span><br></pre></td></tr></table></figure><p>而虚拟机执行的代码并没有泛型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Pair</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pair</span>(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">first</span> <span class="operator">=</span> (String) p.getFirst();</span><br><span class="line"><span class="type">String</span> <span class="variable">last</span> <span class="operator">=</span> (String) p.getLast();</span><br></pre></td></tr></table></figure><p>所以，Java的泛型是由编译器在编译时实行的，编译器内部永远把所有类型<code>T</code>视为<code>Object</code>处理，但是，在需要转型的时候，编译器会根据<code>T</code>的类型自动为我们实行安全地强制转型。</p><p>了解了Java泛型的实现方式——擦拭法，我们就知道了Java泛型的局限：</p><p>局限一：<code>&lt;T&gt;</code>不能是基本类型，例如<code>int</code>，因为实际类型是<code>Object</code>，<code>Object</code>类型无法持有基本类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;<span class="type">int</span>&gt; p = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// compile error!</span></span><br></pre></td></tr></table></figure><p>局限二：无法取得带泛型的<code>Class</code>。观察以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Pair&lt;String&gt; p1 = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">        Pair&lt;Integer&gt; p2 = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="number">123</span>, <span class="number">456</span>);</span><br><span class="line">        <span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> p1.getClass();</span><br><span class="line">        <span class="type">Class</span> <span class="variable">c2</span> <span class="operator">=</span> p2.getClass();</span><br><span class="line">        System.out.println(c1==c2); <span class="comment">// true</span></span><br><span class="line">        System.out.println(c1==Pair.class); <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">(T first, T last)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.first = first;</span><br><span class="line">        <span class="built_in">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getFirst</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getLast</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>局限三：无法判断带泛型的类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;Integer&gt; p = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="number">123</span>, <span class="number">456</span>);</span><br><span class="line"><span class="comment">// Compile error:</span></span><br><span class="line"><span class="keyword">if</span> (p <span class="keyword">instanceof</span> Pair&lt;String&gt;) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原因和前面一样，并不存在<code>Pair&lt;String&gt;.class</code>，而是只有唯一的<code>Pair.class</code>。</p><p>局限四：不能实例化<code>T</code>类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// Compile error:</span></span><br><span class="line">        first = <span class="keyword">new</span> <span class="title class_">T</span>();</span><br><span class="line">        last = <span class="keyword">new</span> <span class="title class_">T</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码无法通过编译，因为构造方法的两行语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">first = <span class="keyword">new</span> <span class="title class_">T</span>();</span><br><span class="line">last = <span class="keyword">new</span> <span class="title class_">T</span>();</span><br></pre></td></tr></table></figure><p>擦拭后实际上变成了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">first = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">last = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure><p>这样一来，创建<code>new Pair&lt;String&gt;()</code>和创建<code>new Pair&lt;Integer&gt;()</code>就全部成了<code>Object</code>，显然编译器要阻止这种类型不对的代码。</p><p>要实例化<code>T</code>类型，我们必须借助额外的<code>Class&lt;T&gt;</code>参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">(Class&lt;T&gt; clazz)</span> &#123;</span><br><span class="line">        first = clazz.newInstance();</span><br><span class="line">        last = clazz.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码借助<code>Class&lt;T&gt;</code>参数并通过反射来实例化<code>T</code>类型，使用的时候，也必须传入<code>Class&lt;T&gt;</code>。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;String&gt; pair = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(String.class);</span><br></pre></td></tr></table></figure><p>因为传入了<code>Class&lt;String&gt;</code>的实例，所以我们借助<code>String.class</code>就可以实例化<code>String</code>类型。</p><p>Java的泛型是采用擦拭法实现的；</p><p>擦拭法决定了泛型<code>&lt;T&gt;</code>：</p><ul><li>不能是基本类型，例如：<code>int</code>；</li><li>不能获取带泛型类型的<code>Class</code>，例如：<code>Pair&lt;String&gt;.class</code>；</li><li>不能判断带泛型类型的类型，例如：<code>x instanceof Pair&lt;String&gt;</code>；</li><li>不能实例化<code>T</code>类型，例如：<code>new T()</code>。</li></ul><p>泛型方法要防止重复定义方法，例如：<code>public boolean equals(T obj)</code>；</p><p>子类可以获取父类的泛型类型<code>&lt;T&gt;</code>。</p><h3 id="extends通配符"><a href="#extends通配符" class="headerlink" title="extends通配符"></a>extends通配符</h3><p>使用类似<code>&lt;? extends Number&gt;</code>通配符作为方法参数时表示：</p><ul><li>方法内部可以调用获取<code>Number</code>引用的方法，例如：<code>Number n = obj.getFirst();</code>；</li><li>方法内部无法调用传入<code>Number</code>引用的方法（<code>null</code>除外），例如：<code>obj.setFirst(Number n);</code>。</li></ul><p>即一句话总结：使用<code>extends</code>通配符表示可以读，不能写。</p><p>使用类似<code>&lt;T extends Number&gt;</code>定义泛型类时表示：</p><ul><li>泛型类型限定为<code>Number</code>以及<code>Number</code>的子类。</li></ul><h3 id="super通配符"><a href="#super通配符" class="headerlink" title="super通配符"></a>super通配符</h3><p>使用类似<code>&lt;? super Integer&gt;</code>通配符作为方法参数时表示：</p><ul><li>方法内部可以调用传入<code>Integer</code>引用的方法，例如：<code>obj.setFirst(Integer n);</code>；</li><li>方法内部无法调用获取<code>Integer</code>引用的方法（<code>Object</code>除外），例如：<code>Integer n = obj.getFirst();</code>。</li></ul><p>即使用<code>super</code>通配符表示只能写不能读。</p><p>使用<code>extends</code>和<code>super</code>通配符要遵循PECS原则。</p><p>无限定通配符<code>&lt;?&gt;</code>很少使用，可以用<code>&lt;T&gt;</code>替换，同时它是所有<code>&lt;T&gt;</code>类型的超类。</p><h3 id="泛型和反射"><a href="#泛型和反射" class="headerlink" title="泛型和反射"></a>泛型和反射</h3><p>部分反射API是泛型，例如：<code>Class&lt;T&gt;</code>，<code>Constructor&lt;T&gt;</code>；</p><p>可以声明带泛型的数组，但不能直接创建带泛型的数组，必须强制转型；</p><p>可以通过<code>Array.newInstance(Class&lt;T&gt;, int)</code>创建<code>T[]</code>数组，需要强制转型；</p><p>同时使用泛型和可变参数时需要特别小心。</p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java注解</title>
      <link href="/2022/04/25/java%E6%B3%A8%E8%A7%A3/"/>
      <url>/2022/04/25/java%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>注解（Annotation）时放在Java源码的类、方法、字段、参数前的一种特殊“注释”。<br>注解可以被编译器打包进入class文件。因此，注解是一种用作标注的“元数据”。</p><span id="more"></span><h3 id="注解的作用"><a href="#注解的作用" class="headerlink" title="注解的作用"></a>注解的作用</h3><p>Java的注解可以分为三类：</p><p>第一类是由编译器使用的注解，例如：</p><ul><li><code>@Override</code>：让编译器检查该方法是否正确地实现了覆写；</li><li><code>@SuppressWarnings</code>：告诉编译器忽略此处代码产生的警告。</li></ul><p>这类注解不会被编译进入<code>.class</code>文件，它们在编译后就被编译器扔掉了。</p><p>第二类是由工具处理<code>.class</code>文件使用的注解，比如有些工具会在加载class的时候，对class做动态修改，实现一些特殊的功能。这类注解会被编译进入<code>.class</code>文件，但加载结束后并不会存在于内存中。这类注解只被一些底层库使用，一般我们不必自己处理。</p><p>第三类是在程序运行期能够读取的注解，它们在加载后一直存在于JVM中，这也是最常用的注解。例如，一个配置了<code>@PostConstruct</code>的方法会在调用构造方法后自动被调用（这是Java代码读取该注解实现的功能，JVM并不会识别该注解）。</p><p>注解的配置参数可以有默认值，缺少某个配置参数时将使用默认值。</p><p>此外，大部分注解会有一个名为<code>value</code>的配置参数，对此参数赋值，可以只写常量，相当于省略了value参数。</p><p>如果只写注解，相当于全部使用默认值。</p><h3 id="定义注解"><a href="#定义注解" class="headerlink" title="定义注解"></a>定义注解</h3><p>有一些注解可以修饰其他注解，这些注解就称为元注解（meta annotation）</p><p>Java使用<code>@interface</code>定义注解：</p><p>可定义多个参数和默认值，核心参数使用<code>value</code>名称；</p><p>必须设置<code>@Target</code>来指定<code>Annotation</code>可以应用的范围；</p><p>应当设置<code>@Retention(RetentionPolicy.RUNTIME)</code>便于运行期读取该<code>Annotation</code>。</p><h3 id="使用注解"><a href="#使用注解" class="headerlink" title="使用注解"></a>使用注解</h3><p>可以通过程序处理注解来实现相应的功能：</p><ul><li>对JavaBean的属性值按规则进行检查；</li><li>JUnit会自动运行<code>@Test</code>标记的测试方法。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java反射</title>
      <link href="/2022/04/25/java%E5%8F%8D%E5%B0%84/"/>
      <url>/2022/04/25/java%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>反射就是Reflection，Java的反射是指程序在运行期可以拿到一个对象的所有信息。<br>正常情况下，如果我们要调用一个对象的方法，或者访问一个对象的字段，通常会传入对象实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Main.java</span></span><br><span class="line"><span class="keyword">import</span> com.itranswarp.learnjava.Person;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    String <span class="title function_">getFullName</span><span class="params">(Person p)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> p.getFirstName() + <span class="string">&quot; &quot;</span> + p.getLastName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，如果不能获得Person类，只有一个Object实例，比如这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String <span class="title function_">getFullName</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ???</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>怎么办？有童鞋会说：强制转型啊！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String <span class="title function_">getFullName</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> (Person) obj;</span><br><span class="line">    <span class="keyword">return</span> p.getFirstName() + <span class="string">&quot; &quot;</span> + p.getLastName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>强制转型的时候，你会发现一个问题：编译上面的代码，仍然需要引用Person类。不然，去掉import语句，你看能不能编译通过？</p><p>所以，反射是为了解决在运行期，对某个实例一无所知的情况下，如何调用其方法。</p><h2 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h2><p>class是由JVM在执行过程中动态加载的。JVM在第一次读取到一种class类型时，将其加载进内存。</p><p>每加载一种class，JVM就为其创建一个Class类型的实例。</p><p>以<code>String</code>类为例，当JVM加载<code>String</code>类时，它首先读取<code>String.class</code>文件到内存，然后，为<code>String</code>类创建一个<code>Class</code>实例并关联起来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Class</span>(String);</span><br></pre></td></tr></table></figure><p>一个Class实例包含了该class的所有完整信息。</p><p>由于JVM为每个加载的<code>class</code>创建了对应的<code>Class</code>实例，并在实例中保存了该<code>class</code>的所有信息，包括类名、包名、父类、实现的接口、所有方法、字段等，因此，如果获取了某个<code>Class</code>实例，我们就可以通过这个<code>Class</code>实例获取到该实例对应的<code>class</code>的所有信息。</p><p>这种通过<code>Class</code>实例获取<code>class</code>信息的方法称为反射（Reflection）。</p><p>如何获取一个<code>class</code>的<code>Class</code>实例？有三个方法：</p><p>方法一：直接通过一个<code>class</code>的静态变量<code>class</code>获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> String.class;</span><br></pre></td></tr></table></figure><p>方法二：如果我们有一个实例变量，可以通过该实例变量提供的<code>getClass()</code>方法获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> s.getClass();</span><br></pre></td></tr></table></figure><p>方法三：如果知道一个<code>class</code>的完整类名，可以通过静态方法<code>Class.forName()</code>获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.String&quot;</span>);</span><br></pre></td></tr></table></figure><p>因为<code>Class</code>实例在JVM中是唯一的，所以，上述方法获取的<code>Class</code>实例是同一个实例。</p><p>因为反射的目的是为了获得某个实例的信息。因此，当我们拿到某个<code>Object</code>实例时，我们可以通过反射获取该<code>Object</code>的<code>class</code>信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">printObjectInfo</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> obj.getClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态加载"><a href="#动态加载" class="headerlink" title="动态加载"></a>动态加载</h3><p>JVM在执行Java程序的时候，并不是一次性把所有用到的class全部加载到内存，而是第一次需要用到class时才加载。</p><h2 id="访问字段"><a href="#访问字段" class="headerlink" title="访问字段"></a>访问字段</h2><p><code>Class</code>类提供了以下几个方法来获取字段：</p><ul><li>Field getField(name)：根据字段名获取某个public的field（包括父类）</li><li>Field getDeclaredField(name)：根据字段名获取当前类的某个field（不包括父类）</li><li>Field[] getFields()：获取所有public的field（包括父类）</li><li>Field[] getDeclaredFields()：获取当前类的所有field（不包括父类）</li></ul><h3 id="设置字段值"><a href="#设置字段值" class="headerlink" title="设置字段值"></a>设置字段值</h3><p>略</p><h2 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h2><p>我们已经能通过<code>Class</code>实例获取所有<code>Field</code>对象，同样的，可以通过<code>Class</code>实例获取所有<code>Method</code>信息。<code>Class</code>类提供了以下几个方法来获取<code>Method</code>：</p><ul><li><code>Method getMethod(name, Class...)</code>：获取某个<code>public</code>的<code>Method</code>（包括父类）</li><li><code>Method getDeclaredMethod(name, Class...)</code>：获取当前类的某个<code>Method</code>（不包括父类）</li><li><code>Method[] getMethods()</code>：获取所有<code>public</code>的<code>Method</code>（包括父类）</li><li><code>Method[] getDeclaredMethods()</code>：获取当前类的所有<code>Method</code>（不包括父类）</li></ul><h2 id="调用构造方法"><a href="#调用构造方法" class="headerlink" title="调用构造方法"></a>调用构造方法</h2><p>我们通常使用<code>new</code>操作符创建新的实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person p = new Person();</span><br></pre></td></tr></table></figure><p>如果通过反射来创建新的实例，可以调用Class提供的newInstance()方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person p = Person.class.newInstance();</span><br></pre></td></tr></table></figure><p>调用Class.newInstance()的局限是，它只能调用该类的public无参数构造方法。如果构造方法带有参数，或者不是public，就无法直接通过Class.newInstance()来调用。</p><p>为了调用任意的构造方法，Java的反射API提供了Constructor对象，它包含一个构造方法的所有信息，可以创建一个实例。Constructor对象和Method非常类似，不同之处仅在于它是一个构造方法，并且，调用结果总是返回实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 获取构造方法Integer(int):</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">cons1</span> <span class="operator">=</span> Integer.class.getConstructor(<span class="type">int</span>.class);</span><br><span class="line">        <span class="comment">// 调用构造方法:</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">n1</span> <span class="operator">=</span> (Integer) cons1.newInstance(<span class="number">123</span>);</span><br><span class="line">        System.out.println(n1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取构造方法Integer(String)</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">cons2</span> <span class="operator">=</span> Integer.class.getConstructor(String.class);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">n2</span> <span class="operator">=</span> (Integer) cons2.newInstance(<span class="string">&quot;456&quot;</span>);</span><br><span class="line">        System.out.println(n2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="获取继承关系"><a href="#获取继承关系" class="headerlink" title="获取继承关系"></a>获取继承关系</h2><p>略</p><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>有没有可能不编写实现类，直接在运行期创建某个interface的实例呢？</p><p>这是可能的，因为Java标准库提供了一种动态代理（Dynamic Proxy）的机制：可以在运行期动态创建某个<code>interface</code>的实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                System.out.println(method);</span><br><span class="line">                <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;morning&quot;</span>)) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Good morning, &quot;</span> + args[<span class="number">0</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Hello</span> <span class="variable">hello</span> <span class="operator">=</span> (Hello) Proxy.newProxyInstance(</span><br><span class="line">            Hello.class.getClassLoader(), <span class="comment">// 传入ClassLoader</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; Hello.class &#125;, <span class="comment">// 传入要实现的接口</span></span><br><span class="line">            handler); <span class="comment">// 传入处理调用方法的InvocationHandler</span></span><br><span class="line">        hello.morning(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">morning</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在运行期动态创建一个<code>interface</code>实例的方法如下：</p><ol><li>定义一个<code>InvocationHandler</code>实例，它负责实现接口的方法调用；</li><li>通过<code>Proxy.newProxyInstance()</code>创建<code>interface</code>实例，它需要3个参数：<ol><li>使用的<code>ClassLoader</code>，通常就是接口类的<code>ClassLoader</code>；</li><li>需要实现的接口数组，至少需要传入一个接口进去；</li><li>用来处理接口方法调用的<code>InvocationHandler</code>实例。</li></ol></li><li>将返回的<code>Object</code>强制转型为接口。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java异常处理</title>
      <link href="/2022/04/25/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
      <url>/2022/04/25/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="Java异常"><a href="#Java异常" class="headerlink" title="Java异常"></a>Java异常</h2><p>在计算机运行的过程中，会有各种错误。Java内置了一套异常处理机制，总是使用异常来表示错误。异常是一种class，本身带有类型信息。异常可以在任何地方抛出，但只需要在上层捕获，这样就和方法调用分离了。</p><p>因为Java的异常是class，它的继承关系如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">                     ┌───────────┐</span><br><span class="line">                     │  Object   │</span><br><span class="line">                     └───────────┘</span><br><span class="line">                           ▲</span><br><span class="line">                           │</span><br><span class="line">                     ┌───────────┐</span><br><span class="line">                     │ Throwable │</span><br><span class="line">                     └───────────┘</span><br><span class="line">                           ▲</span><br><span class="line">                 ┌─────────┴─────────┐</span><br><span class="line">                 │                   │</span><br><span class="line">           ┌───────────┐       ┌───────────┐</span><br><span class="line">           │   Error   │       │ Exception │</span><br><span class="line">           └───────────┘       └───────────┘</span><br><span class="line">                 ▲                   ▲</span><br><span class="line">         ┌───────┘              ┌────┴──────────┐</span><br><span class="line">         │                      │               │</span><br><span class="line">┌─────────────────┐    ┌─────────────────┐┌───────────┐</span><br><span class="line">│OutOfMemoryError │... │RuntimeException ││IOException│...</span><br><span class="line">└─────────────────┘    └─────────────────┘└───────────┘</span><br><span class="line">                                ▲</span><br><span class="line">                    ┌───────────┴─────────────┐</span><br><span class="line">                    │                         │</span><br><span class="line">         ┌─────────────────────┐ ┌─────────────────────────┐</span><br><span class="line">         │NullPointerException │ │IllegalArgumentException │...</span><br><span class="line">         └─────────────────────┘ └─────────────────────────┘</span><br></pre></td></tr></table></figure><p>Error表示很严重的错误，程序一般对此无能为力。Exception是运行时的错误，它可以被捕获并处理。</p><p>Java规定：</p><ul><li>必须捕获的异常，包括Exception及其子类，但不包括RuntimeException及其子类，这种类型的异常陈伟Checked Exception。</li><li>不需要捕获的异常，包括Error及其子类，RuntimeException及其子类。</li></ul><h3 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h3><p>使用<code>try...catch</code>语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] bs = toGBK(<span class="string">&quot;中文&quot;</span>);</span><br><span class="line">        System.out.println(Arrays.toString(bs));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">byte</span>[] toGBK(String s) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 用指定编码转换String为byte[]:</span></span><br><span class="line">            <span class="keyword">return</span> s.getBytes(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            <span class="comment">// 如果系统不支持GBK编码，会捕获到UnsupportedEncodingException:</span></span><br><span class="line">            System.out.println(e); <span class="comment">// 打印异常信息</span></span><br><span class="line">            <span class="keyword">return</span> s.getBytes(); <span class="comment">// 尝试使用用默认编码</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>toGBK()</code>方法中，因为调用了<code>String.getBytes(String)</code>方法，就必须捕获<code>UnsupportedEncodingException</code>。我们也可以不捕获它，而是在方法定义处用throws表示<code>toGBK()</code>方法可能会抛出<code>UnsupportedEncodingException</code>，就可以让<code>toGBK()</code>方法通过编译器检查：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] bs = toGBK(<span class="string">&quot;中文&quot;</span>);</span><br><span class="line">        System.out.println(Arrays.toString(bs));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">byte</span>[] toGBK(String s) <span class="keyword">throws</span> UnsupportedEncodingException &#123;</span><br><span class="line">        <span class="keyword">return</span> s.getBytes(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码仍然会得到编译错误，但这一次，编译器提示的不是调用<code>return s.getBytes(&quot;GBK&quot;);</code>的问题，而是<code>byte[] bs = toGBK(&quot;中文&quot;);</code>。因为在<code>main()</code>方法中，调用<code>toGBK()</code>，没有捕获它声明的可能抛出的<code>UnsupportedEncodingException</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">byte</span>[] bs = toGBK(<span class="string">&quot;中文&quot;</span>);</span><br><span class="line">            System.out.println(Arrays.toString(bs));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">byte</span>[] toGBK(String s) <span class="keyword">throws</span> UnsupportedEncodingException &#123;</span><br><span class="line">        <span class="comment">// 用指定编码转换String为byte[]:</span></span><br><span class="line">        <span class="keyword">return</span> s.getBytes(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多catch语句"><a href="#多catch语句" class="headerlink" title="多catch语句"></a>多catch语句</h2><p>可以使用多个<code>catch</code>语句，每个<code>catch</code>分别捕获对应的<code>Exception</code>及其子类。JVM在捕获到异常后，会从上到下匹配<code>catch</code>语句，匹配到某个<code>catch</code>后，执行<code>catch</code>代码块，然后<em>不再</em>继续匹配。</p><p>存在多个<code>catch</code>的时候，<code>catch</code>的顺序非常重要：子类必须写在前面。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        process1();</span><br><span class="line">        process2();</span><br><span class="line">        process3();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;IO error&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123; <span class="comment">// 永远捕获不到</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Bad encoding&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以用或者<code>|</code>来选择多种异常</p><h2 id="finally语句"><a href="#finally语句" class="headerlink" title="finally语句"></a>finally语句</h2><p>无论代码是否发生异常，都会执行finally语句。</p><ul><li>finally语句不是必须的，可写可不写。</li><li>finally语句总是最后执行。</li></ul><h2 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h2><p>如果一个方法捕获了某个异常后，又在<code>catch</code>子句中抛出新的异常，就相当于把抛出的异常类型“转换”了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">process1</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        process2();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">process2</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s==<span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>捕获到异常并再次抛出时，一定要留住原始异常，否则很难定位第一案发现场！</strong></p><h2 id="异常屏蔽"><a href="#异常屏蔽" class="headerlink" title="异常屏蔽"></a>异常屏蔽</h2><p>如果在finally语句时抛出异常，那么，catch语句中的异常不能正确抛出。</p><p>需要通过Throwable.getSuppressed()获取所有的Suppressed Exception。</p><h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><p>Java标准库定义的常用异常包括：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Exception</span><br><span class="line">│</span><br><span class="line">├─ RuntimeException</span><br><span class="line">│  │</span><br><span class="line">│  ├─ NullPointerException</span><br><span class="line">│  │</span><br><span class="line">│  ├─ IndexOutOfBoundsException</span><br><span class="line">│  │</span><br><span class="line">│  ├─ SecurityException</span><br><span class="line">│  │</span><br><span class="line">│  └─ IllegalArgumentException</span><br><span class="line">│     │</span><br><span class="line">│     └─ NumberFormatException</span><br><span class="line">│</span><br><span class="line">├─ IOException</span><br><span class="line">│  │</span><br><span class="line">│  ├─ UnsupportedCharsetException</span><br><span class="line">│  │</span><br><span class="line">│  ├─ FileNotFoundException</span><br><span class="line">│  │</span><br><span class="line">│  └─ SocketException</span><br><span class="line">│</span><br><span class="line">├─ ParseException</span><br><span class="line">│</span><br><span class="line">├─ GeneralSecurityException</span><br><span class="line">│</span><br><span class="line">├─ SQLException</span><br><span class="line">│</span><br><span class="line">└─ TimeoutException</span><br></pre></td></tr></table></figure><p>可以自定异常。</p><h2 id="使用断言"><a href="#使用断言" class="headerlink" title="使用断言"></a>使用断言</h2><p>断言（Assertion）是一种调试程序的方式。在Java中，使用<code>assert</code>关键字来实现断言。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> Math.abs(-<span class="number">123.45</span>);</span><br><span class="line">    <span class="keyword">assert</span> x &gt;= <span class="number">0</span>;</span><br><span class="line">    System.out.println(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果断言失败，则抛出<code>AssertionError</code>。</p><p>使用<code>assert</code>语句时，还可以添加一个可选的断言消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> x &gt;= <span class="number">0</span> : <span class="string">&quot;x must &gt;= 0&quot;</span>;</span><br></pre></td></tr></table></figure><p>这样，断言失败的时候，<code>AssertionError</code>会带上消息<code>x must &gt;= 0</code>，更加便于调试。</p><h2 id="使用JDK-Logging"><a href="#使用JDK-Logging" class="headerlink" title="使用JDK Logging"></a>使用JDK Logging</h2><p>日志包<code>java.util.logging</code></p><h2 id="使用Commons-Logging"><a href="#使用Commons-Logging" class="headerlink" title="使用Commons Logging"></a>使用Commons Logging</h2><h2 id="使用Log4j"><a href="#使用Log4j" class="headerlink" title="使用Log4j"></a>使用Log4j</h2><h2 id="使用SLF4J和Logback"><a href="#使用SLF4J和Logback" class="headerlink" title="使用SLF4J和Logback"></a>使用SLF4J和Logback</h2>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/2022/04/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/04/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java核心类</title>
      <link href="/2022/04/24/Java%E6%A0%B8%E5%BF%83%E7%B1%BB/"/>
      <url>/2022/04/24/Java%E6%A0%B8%E5%BF%83%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;Hello!&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="keyword">new</span> <span class="title class_">char</span>[]&#123;<span class="string">&#x27;H&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;!&#x27;</span>&#125;);</span><br></pre></td></tr></table></figure><p>字符串是不可变的，存储来常量池中。</p><h3 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">s1.equals(s2);</span><br><span class="line">s1.equalsIgnoreCase(s2);</span><br><span class="line"><span class="string">&quot;Hello&quot;</span>.contains(<span class="string">&quot;ll&quot;</span>);<span class="comment">//true</span></span><br><span class="line"><span class="string">&quot;Hello&quot;</span>.indexOf(<span class="string">&quot;l&quot;</span>); <span class="comment">// 2</span></span><br><span class="line"><span class="string">&quot;Hello&quot;</span>.lastIndexOf(<span class="string">&quot;l&quot;</span>); <span class="comment">// 3</span></span><br><span class="line"><span class="string">&quot;Hello&quot;</span>.startsWith(<span class="string">&quot;He&quot;</span>); <span class="comment">// true</span></span><br><span class="line"><span class="string">&quot;Hello&quot;</span>.endsWith(<span class="string">&quot;lo&quot;</span>); <span class="comment">// true</span></span><br><span class="line"><span class="string">&quot;Hello&quot;</span>.substring(<span class="number">2</span>); <span class="comment">// &quot;llo&quot;</span></span><br><span class="line"><span class="string">&quot;Hello&quot;</span>.substring(<span class="number">2</span>, <span class="number">4</span>); <span class="string">&quot;ll&quot;</span></span><br><span class="line"><span class="string">&quot;  \tHello\r\n &quot;</span>.trim(); <span class="comment">// &quot;Hello&quot;,移除首尾空格、换行符、制表符</span></span><br></pre></td></tr></table></figure><p>注意：<code>trim()</code>并没有改变字符串的内容，而是返回了一个新字符串。</p><p>另一个<code>strip()</code>方法也可以移除字符串首尾空白字符。它和<code>trim()</code>不同的是，类似中文的空格字符<code>\u3000</code>也会被移除：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;\u3000Hello\u3000&quot;</span>.strip(); <span class="comment">// &quot;Hello&quot;</span></span><br><span class="line"><span class="string">&quot; Hello &quot;</span>.stripLeading(); <span class="comment">// &quot;Hello &quot;</span></span><br><span class="line"><span class="string">&quot; Hello &quot;</span>.stripTrailing(); <span class="comment">// &quot; Hello&quot;</span></span><br><span class="line"><span class="string">&quot;&quot;</span>.isEmpty(); <span class="comment">// true，因为字符串长度为0</span></span><br><span class="line"><span class="string">&quot;  &quot;</span>.isEmpty(); <span class="comment">// false，因为字符串长度不为0</span></span><br><span class="line"><span class="string">&quot;  \n&quot;</span>.isBlank(); <span class="comment">// true，因为只包含空白字符</span></span><br><span class="line"><span class="string">&quot; Hello &quot;</span>.isBlank(); <span class="comment">// false，因为包含非空白字符</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">s.replace(<span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;w&#x27;</span>); <span class="comment">// &quot;hewwo&quot;，所有字符&#x27;l&#x27;被替换为&#x27;w&#x27;</span></span><br><span class="line">s.replace(<span class="string">&quot;ll&quot;</span>, <span class="string">&quot;~~&quot;</span>); <span class="comment">// &quot;he~~o&quot;，所有子串&quot;ll&quot;被替换为&quot;~~&quot;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;A,,B;C ,D&quot;</span>;</span><br><span class="line">s.replaceAll(<span class="string">&quot;[\\,\\;\\s]+&quot;</span>, <span class="string">&quot;,&quot;</span>); <span class="comment">// &quot;A,B,C,D&quot;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;A,B,C,D&quot;</span>;</span><br><span class="line">String[] ss = s.split(<span class="string">&quot;\\,&quot;</span>); <span class="comment">// &#123;&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;&#125;</span></span><br><span class="line">String[] arr = &#123;<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>&#125;;</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> String.join(<span class="string">&quot;***&quot;</span>, arr); <span class="comment">// &quot;A***B***C&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Hi %s, your score is %d!&quot;</span>;</span><br><span class="line">        System.out.println(s.formatted(<span class="string">&quot;Alice&quot;</span>, <span class="number">80</span>));</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;Hi %s, your score is %.2f!&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="number">59.5</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">String.valueOf(<span class="number">123</span>); <span class="comment">// &quot;123&quot;</span></span><br><span class="line">String.valueOf(<span class="number">45.67</span>); <span class="comment">// &quot;45.67&quot;</span></span><br><span class="line">String.valueOf(<span class="literal">true</span>); <span class="comment">// &quot;true&quot;</span></span><br><span class="line">String.valueOf(<span class="keyword">new</span> <span class="title class_">Object</span>()); <span class="comment">// 类似java.lang.Object@636be97c</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> Integer.parseInt(<span class="string">&quot;123&quot;</span>); <span class="comment">// 123</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> Integer.parseInt(<span class="string">&quot;ff&quot;</span>, <span class="number">16</span>); <span class="comment">// 按十六进制转换，255</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b1</span> <span class="operator">=</span> Boolean.parseBoolean(<span class="string">&quot;true&quot;</span>); <span class="comment">// true</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b2</span> <span class="operator">=</span> Boolean.parseBoolean(<span class="string">&quot;FALSE&quot;</span>); <span class="comment">// false</span></span><br><span class="line">Integer.getInteger(<span class="string">&quot;java.version&quot;</span>); <span class="comment">// 版本号，11</span></span><br><span class="line"><span class="type">char</span>[] cs = <span class="string">&quot;Hello&quot;</span>.toCharArray(); <span class="comment">// String -&gt; char[]</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(cs); <span class="comment">// char[] -&gt; String</span></span><br><span class="line"></span><br><span class="line"><span class="type">byte</span>[] b1 = <span class="string">&quot;Hello&quot;</span>.getBytes(); <span class="comment">// 按系统默认编码转换，不推荐</span></span><br><span class="line"><span class="type">byte</span>[] b2 = <span class="string">&quot;Hello&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>); <span class="comment">// 按UTF-8编码转换</span></span><br><span class="line"><span class="type">byte</span>[] b2 = <span class="string">&quot;Hello&quot;</span>.getBytes(<span class="string">&quot;GBK&quot;</span>); <span class="comment">// 按GBK编码转换</span></span><br><span class="line"><span class="type">byte</span>[] b3 = <span class="string">&quot;Hello&quot;</span>.getBytes(StandardCharsets.UTF_8); <span class="comment">// 按UTF-8编码转换</span></span><br></pre></td></tr></table></figure><h2 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="number">1024</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    sb.append(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">    sb.append(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> sb.toString();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123; <span class="comment">//链式操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="number">1024</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;Mr &quot;</span>)</span><br><span class="line">          .append(<span class="string">&quot;Bob&quot;</span>)</span><br><span class="line">          .append(<span class="string">&quot;!&quot;</span>)</span><br><span class="line">          .insert(<span class="number">0</span>, <span class="string">&quot;Hello, &quot;</span>);</span><br><span class="line">        System.out.println(sb.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一个链式操作的类（方法返回this）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Adder</span> <span class="variable">adder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Adder</span>();</span><br><span class="line">        adder.add(<span class="number">3</span>)</span><br><span class="line">             .add(<span class="number">5</span>)</span><br><span class="line">             .inc()</span><br><span class="line">             .add(<span class="number">10</span>);</span><br><span class="line">        System.out.println(adder.value());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Adder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Adder <span class="title function_">add</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        sum += n;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Adder <span class="title function_">inc</span><span class="params">()</span> &#123;</span><br><span class="line">        sum ++;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">value</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="StringJoiner"><a href="#StringJoiner" class="headerlink" title="StringJoiner"></a>StringJoiner</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] names = &#123;<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Grace&quot;</span>&#125;;</span><br><span class="line"><span class="type">var</span> <span class="variable">s</span> <span class="operator">=</span> String.join(<span class="string">&quot;, &quot;</span>, names);</span><br></pre></td></tr></table></figure><h2 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h2><p>我们已经知道，java的数据类型分为两种：</p><ul><li>基本类型：byte，short，int，long，boolean，float，double，char</li><li>引用类型：所有的class和interface类型</li></ul><p>引用类型可以赋值为null，表示空，但基本类型不能赋值为null。</p><p>那么，如何把一个基本类型视为对象（引用类型）？</p><p>比如，想把int变为引用类型，我们可以定义一个Integer类，它只包含一个实例字段int，这样Integer类就可以视为int的包装类（Wrapper Class）</p><p>Java核心库为每种类型都提供了对应的包装类型：</p><table><thead><tr><th align="left">基本类型</th><th align="left">对应的引用类型</th></tr></thead><tbody><tr><td align="left">boolean</td><td align="left">java.lang.Boolean</td></tr><tr><td align="left">byte</td><td align="left">java.lang.Byte</td></tr><tr><td align="left">short</td><td align="left">java.lang.Short</td></tr><tr><td align="left">int</td><td align="left">java.lang.Integer</td></tr><tr><td align="left">long</td><td align="left">java.lang.Long</td></tr><tr><td align="left">float</td><td align="left">java.lang.Float</td></tr><tr><td align="left">double</td><td align="left">java.lang.Double</td></tr><tr><td align="left">char</td><td align="left">java.lang.Character</td></tr></tbody></table><h3 id="Auto-Boxing"><a href="#Auto-Boxing" class="headerlink" title="Auto Boxing"></a>Auto Boxing</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">100</span>; <span class="comment">// 编译器自动使用Integer.valueOf(int)</span></span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> n; <span class="comment">// 编译器自动使用Integer.intValue()</span></span><br></pre></td></tr></table></figure><p>这种直接把<code>int</code>变为<code>Integer</code>的赋值写法，称为自动装箱（Auto Boxing），反过来，把<code>Integer</code>变为<code>int</code>的赋值写法，称为自动拆箱（Auto Unboxing）。</p><h3 id="不变类"><a href="#不变类" class="headerlink" title="不变类"></a>不变类</h3><p>所有的包装都是不变类，一旦创建该对象就是不变的。用equals()比较。</p><p>因为<code>Integer.valueOf()</code>可能始终返回同一个<code>Integer</code>实例，因此，在我们自己创建<code>Integer</code>的时候，以下两种方法：</p><ul><li>方法1：<code>Integer n = new Integer(100);</code></li><li>方法2：<code>Integer n = Integer.valueOf(100);</code></li></ul><p>方法2更好，因为方法1总是创建新的<code>Integer</code>实例，方法2把内部优化留给<code>Integer</code>的实现者去做，即使在当前版本没有优化，也有可能在下一个版本进行优化。</p><p>我们把能创建“新”对象的静态方法称为静态工厂方法。<code>Integer.valueOf()</code>就是静态工厂方法，它尽可能地返回缓存的实例以节省内存。</p><p><strong>创建新对象时，优先选用静态工厂方法而不是new操作符。</strong></p><h3 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x2</span> <span class="operator">=</span> Integer.parseInt(<span class="string">&quot;100&quot;</span>, <span class="number">16</span>); <span class="comment">// 256,因为按16进制解析</span></span><br></pre></td></tr></table></figure><h2 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a>JavaBean</h2><p>在Java中，有很多class的定义都符合这样的规范：</p><ul><li>若干private实例字段</li><li>通过public方法来读写实例字段（get，set方法）</li></ul><p>如果读写方法符合这样的规范，那么这种class就称为JavaBean</p><h3 id="JavaBean的作用"><a href="#JavaBean的作用" class="headerlink" title="JavaBean的作用"></a>JavaBean的作用</h3><p>JavaBean主要用来传递数据，即把一组数据组合成一个JavaBean便于传输。此外，JavaBean可以方便地被IDE工具分析，生成读写属性的代码，主要用在图形界面的可视化设计中。通过IDE，可以快速生成getter和setter。</p><h2 id="枚举类enum"><a href="#枚举类enum" class="headerlink" title="枚举类enum"></a>枚举类enum</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Weekday</span> <span class="variable">day</span> <span class="operator">=</span> Weekday.SUN;</span><br><span class="line">        <span class="keyword">if</span> (day == Weekday.SAT || day == Weekday.SUN) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Work at home!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Work at office!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Weekday</span> &#123;</span><br><span class="line">    SUN, MON, TUE, WED, THU, FRI, SAT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为枚举类的比较和赋值要符合相同类型，这样就使得编译器可以在编译期自动检查除可能的潜在错误。</p><h3 id="enum的比较"><a href="#enum的比较" class="headerlink" title="enum的比较"></a>enum的比较</h3><p>使用enum定义的枚举类是一种引用类型，引用类型的比较需要使用equals()方法，如果使用&#x3D;&#x3D;比较，会比较两个引用类型的变量是否指向同一对象。但是，<strong>enum类型可以例外</strong>。</p><p>这是因为enum类型的每个变量在JVM中只有一个唯一实例，所以可以直接用&#x3D;&#x3D;比较。</p><h3 id="enum类型"><a href="#enum类型" class="headerlink" title="enum类型"></a>enum类型</h3><p>enum枚举类和其他的class有什么区别？</p><p>答案是没有区别。enum定义的类型就是class，只不过有一下几个特点：</p><ul><li>定义的<code>enum</code>类型总是继承自<code>java.lang.Enum</code>，且无法被继承；</li><li>只能定义出<code>enum</code>的实例，而无法通过<code>new</code>操作符创建<code>enum</code>的实例；</li><li>定义的每个实例都是引用类型的唯一实例；</li><li>可以将<code>enum</code>类型用于<code>switch</code>语句。</li></ul><h3 id="name"><a href="#name" class="headerlink" title="name()"></a>name()</h3><p>返回常量名，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> Weekday.SUN.name(); <span class="comment">// &quot;SUN&quot;</span></span><br></pre></td></tr></table></figure><h3 id="ordinal"><a href="#ordinal" class="headerlink" title="ordinal()"></a>ordinal()</h3><p>返回定义的常量的顺序，从0开始计数。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> Weekday.MON.ordinal(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>改变枚举常量的顺序会导致变化。</p><p>可以定义private构造方法，并且给每个枚举常量添加字段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Weekday</span> <span class="variable">day</span> <span class="operator">=</span> Weekday.SUN;</span><br><span class="line">        <span class="keyword">if</span> (day.dayValue == <span class="number">6</span> || day.dayValue == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Work at home!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Work at office!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Weekday</span> &#123;</span><br><span class="line">    MON(<span class="number">1</span>), TUE(<span class="number">2</span>), WED(<span class="number">3</span>), THU(<span class="number">4</span>), FRI(<span class="number">5</span>), SAT(<span class="number">6</span>), SUN(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> dayValue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Weekday</span><span class="params">(<span class="type">int</span> dayValue)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.dayValue = dayValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这样就无需担心顺序的变化。</p><p>可以给enum类型添加toString方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Weekday</span> <span class="variable">day</span> <span class="operator">=</span> Weekday.SUN;</span><br><span class="line">        <span class="keyword">if</span> (day.dayValue == <span class="number">6</span> || day.dayValue == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Today is &quot;</span> + day + <span class="string">&quot;. Work at home!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Today is &quot;</span> + day + <span class="string">&quot;. Work at office!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Weekday</span> &#123;</span><br><span class="line">    MON(<span class="number">1</span>, <span class="string">&quot;星期一&quot;</span>), TUE(<span class="number">2</span>, <span class="string">&quot;星期二&quot;</span>), WED(<span class="number">3</span>, <span class="string">&quot;星期三&quot;</span>), THU(<span class="number">4</span>, <span class="string">&quot;星期四&quot;</span>), FRI(<span class="number">5</span>, <span class="string">&quot;星期五&quot;</span>), SAT(<span class="number">6</span>, <span class="string">&quot;星期六&quot;</span>), SUN(<span class="number">0</span>, <span class="string">&quot;星期日&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> dayValue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String chinese;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Weekday</span><span class="params">(<span class="type">int</span> dayValue, String chinese)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.dayValue = dayValue;</span><br><span class="line">        <span class="built_in">this</span>.chinese = chinese;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.chinese;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这样输出时更有可读性。</p><p><strong>判断枚举常量的名字，要始终使用name()方法，绝不能调用toString()！</strong></p><h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p>枚举类可以应用在switch语句中。因为枚举类天生具有类型信息和有限个枚举常量，因此更适合用在switch中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Weekday</span> <span class="variable">day</span> <span class="operator">=</span> Weekday.SUN;</span><br><span class="line">        <span class="keyword">switch</span>(day) &#123;</span><br><span class="line">        <span class="keyword">case</span> MON:</span><br><span class="line">        <span class="keyword">case</span> TUE:</span><br><span class="line">        <span class="keyword">case</span> WED:</span><br><span class="line">        <span class="keyword">case</span> THU:</span><br><span class="line">        <span class="keyword">case</span> FRI:</span><br><span class="line">            System.out.println(<span class="string">&quot;Today is &quot;</span> + day + <span class="string">&quot;. Work at office!&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SAT:</span><br><span class="line">        <span class="keyword">case</span> SUN:</span><br><span class="line">            System.out.println(<span class="string">&quot;Today is &quot;</span> + day + <span class="string">&quot;. Work at home!&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;cannot process &quot;</span> + day);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Weekday</span> &#123;</span><br><span class="line">    MON, TUE, WED, THU, FRI, SAT, SUN;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>加上default语句，可以在漏写，某个枚举常量时自动报错，从而及时发现错误。</p><h2 id="纪录类"><a href="#纪录类" class="headerlink" title="纪录类"></a>纪录类</h2><p>使用String，Integer等类型的时候，这些类型都是不变类，一个不变类具有以下特点：</p><ul><li>定义class时使用final，无法派生子类</li><li>每个字段使用final，保证创建实例后无法修改任何字段</li></ul><p>如果我们需要定义一个不变类point，除了要将变量改为final外，还需要正确覆写equals()和hashCode()方法，这样才能在集合类中正常使用。这些代码写起来都非常简单，但是很繁琐。</p><h3 id="record"><a href="#record" class="headerlink" title="record"></a>record</h3><p>从Java14开始，引入了新的Record类。我们定义Record类时，使用关键字record。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Point</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">123</span>, <span class="number">456</span>);</span><br><span class="line">        System.out.println(p.x());</span><br><span class="line">        System.out.println(p.y());</span><br><span class="line">        System.out.println(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">record</span> <span class="title class_">Point</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>point的定义如果改为class，相当于一下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Point</span> <span class="keyword">extends</span> <span class="title class_">Record</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Point</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">x</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">y</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">&quot;Point[x=%s, y=%s]&quot;</span>, x, y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了用final修饰class以及每个字段外，编译器还自动为我们创建了构造方法，和字段名同名的方法，以及覆写toString(), equals()和hashCode()方法。</p><p>换句话说，使用record关键字，可以一行写出一个不变类。</p><p>和enum类似，我们自己不能直接从Record派生，只能通过record关键字由编译器实现继承。</p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>编译器默认按照record声明的变量顺序自动创建一个构造方法，并在方法内给字段赋值。那么如果我们要检查参数，应该怎么办？</p><p>比如x,y不允许负数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">record</span> <span class="title class_">Point</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Point &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到方法public Point{…}被称为Compact Constructor，它的目的时让我们编写检查逻辑，编译器最终生成的构造方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Point</span> <span class="keyword">extends</span> <span class="title class_">Record</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Point</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="comment">// 这是我们编写的Compact Constructor:</span></span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这是编译器继续生成的赋值代码:</span></span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作为record的Point仍然可以添加静态方法。一种常用的静态方法时of()方法，用来创建Point：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">record</span> <span class="title class_">Point</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Point <span class="title function_">of</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Point <span class="title function_">of</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Point</span>(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们可以写出更简洁的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">z</span> <span class="operator">=</span> Point.of();</span><br><span class="line"><span class="type">var</span> <span class="variable">p</span> <span class="operator">=</span> Point.of(<span class="number">123</span>, <span class="number">456</span>);</span><br></pre></td></tr></table></figure><h2 id="BigInteger"><a href="#BigInteger" class="headerlink" title="BigInteger"></a>BigInteger</h2><p><code>java.math.BigInteger</code>用来表示任意大小的整数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BigInteger</span> <span class="variable">bi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;1234567890&quot;</span>);</span><br><span class="line">System.out.println(bi.pow(<span class="number">5</span>)); <span class="comment">// 2867971860299718107233761438093672048294900000</span></span><br></pre></td></tr></table></figure><p>对<code>BigInteger</code>做运算的时候，只能使用实例方法，例如，加法运算：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BigInteger</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;1234567890&quot;</span>);</span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;12345678901234567890&quot;</span>);</span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">sum</span> <span class="operator">=</span> i1.add(i2); <span class="comment">// 12345678902469135780</span></span><br></pre></td></tr></table></figure><p>和<code>long</code>型整数运算比，<code>BigInteger</code>不会有范围限制，但缺点是速度比较慢。</p><p>也可以把<code>BigInteger</code>转换成<code>long</code>型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BigInteger</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;123456789000&quot;</span>);</span><br><span class="line">System.out.println(i.longValue()); <span class="comment">// 123456789000</span></span><br><span class="line">System.out.println(i.multiply(i).longValueExact()); <span class="comment">// java.lang.ArithmeticException: BigInteger out of long range</span></span><br></pre></td></tr></table></figure><p>使用<code>longValueExact()</code>方法时，如果超出了<code>long</code>型的范围，会抛出<code>ArithmeticException</code>。</p><p><code>BigInteger</code>和<code>Integer</code>、<code>Long</code>一样，也是不可变类，并且也继承自<code>Number</code>类。因为<code>Number</code>定义了转换为基本类型的几个方法：</p><ul><li>转换为<code>byte</code>：<code>byteValue()</code></li><li>转换为<code>short</code>：<code>shortValue()</code></li><li>转换为<code>int</code>：<code>intValue()</code></li><li>转换为<code>long</code>：<code>longValue()</code></li><li>转换为<code>float</code>：<code>floatValue()</code></li><li>转换为<code>double</code>：<code>doubleValue()</code></li></ul><p>因此，通过上述方法，可以把<code>BigInteger</code>转换成基本类型。如果<code>BigInteger</code>表示的范围超过了基本类型的范围，转换时将丢失高位信息，即结果不一定是准确的。如果需要准确地转换成基本类型，可以使用<code>intValueExact()</code>、<code>longValueExact()</code>等方法，在转换时如果超出范围，将直接抛出<code>ArithmeticException</code>异常。</p><h2 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h2><p>可以表示一个任意大小且精度完全准确的浮点数。</p><p><strong>用compareTo()比较两个BigDecimal的值，不要使用equals()！</strong></p><h2 id="常用工具类"><a href="#常用工具类" class="headerlink" title="常用工具类"></a>常用工具类</h2><ul><li>Math</li><li>Random</li><li>SecureRandom</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解java-Class.forname()</title>
      <link href="/2022/04/23/%E7%90%86%E8%A7%A3java-Class-forname/"/>
      <url>/2022/04/23/%E7%90%86%E8%A7%A3java-Class-forname/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong>Class 类概念</strong></p><p>Class 也是一个 Java 类，保存的是与之对应 Java 类的 meta信息（元信息），用来描述这个类的结构，比如描述一个类有哪些成员，有哪些方法等，一般在反射中使用。</p><span id="more"></span><p><strong>详细解释：</strong>Java 源程序（.java 文件）在经过 Java 编译器编译之后就被转换成 Java 字节代码（.class 文件）。类加载器负责读取 Java 字节代码，并转换成 java.lang.Class类的一个实例（Class 对象）。也就是说，在 Java 中，每个 java 类都有一个相应的 Class 对象，用于表示这个 java 类的类型信息。</p><p><strong>类加载概念</strong></p><p>当使用一个类的时候（比如 new 一个类的实例），会检查此类是否被加载到内存，如果没有，则会执行加载操作。</p><p>读取类对应的 class 文件数据，解析此数据，构造一个此类对应的 Class 类的实例。此时JVM就可以使用该类了，比如实例化此类，或者调用此类的静态方法。</p><p>Java 也提供了手动加载类的接口，class.forName()方法就是其中之一。（说来说去，其实就是生成这个类的 Class）</p><p><strong>类加载器的概念</strong></p><p>顾名思义，类加载器（class loader）用来加载 Java 类到 Java 虚拟机中。一般来说，Java 虚拟机使用 Java 类的方式如下：Java 源程序（.java 文件）在经过 Java 编译器编译之后就被转换成 Java 字节代码（.class 文件）。类加载器负责读取 Java 字节代码，并转换成 java.lang.Class 类的一个实例。每个这样的实例用来表示一个 Java 类。通过此实例的 newInstance() 方法就可以创建出该类的一个对象。 基本上所有的类加载器都是 java.lang.ClassLoader 类的一个实例。</p><p><strong>类初始化概念</strong></p><p>类被加载之后，jvm 已经获得了一个描述类结构的 Class 实例。但是还需要进行类初始化操作之后才能正常使用此类，类初始化操作就是执行一遍类的静态语句，包括静态变量的声明还有静态代码块。</p><p><strong>Class.forName() 方法</strong></p><p>此方法含义是：加载参数指定的类，并且初始化它。</p><p>在 jdbc 连接数据库中的应用</p><p>到这里，不用解释，读者也会明白，在使用 jdbc 方式连接数据库时，为什么要执行 <strong>Class.forName(‘驱动类名’)</strong> 方法了：将驱动类的 class 文件装载到内存中，并且形成一个描述此驱动类结构的 Class 类实例，并且初始化此驱动类，这样 jvm 就可以使用它了，这就是 Class.forName() 方法的含义。</p><p>有数据库开发经验朋友会发现，为什么在我们加载数据库驱动包的时候有的却没有调用 newInstance() 方法呢？即有的 jdbc 连接数据库的写法里是 Class.forName(xxx.xx.xx);而有一 些：Class.forName(xxx.xx.xx).newInstance()，为什么会有这两种写法呢？</p><p>刚才提到，<strong>Class.forName(“”);</strong> 的作用是要求 JVM 查找并加载指定的类，如果在类中有静态初始化器的话，JVM 必然会执行该类的静态代码 段。而在 JDBC 规范中明确要求这个 Driver 类必须向 DriverManager 注册自己，即任何一个 JDBC Driver 的 Driver 类的代码都必须类似如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyJDBCDriver</span> <span class="keyword">implements</span> <span class="title class_">Driver</span> &#123; </span><br><span class="line">    <span class="keyword">static</span> &#123; </span><br><span class="line">        DriverManager.registerDriver(<span class="keyword">new</span> <span class="title class_">MyJDBCDriver</span>()); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>既然在静态初始化器的中已经进行了注册，所以我们在使用 JDBC 时只需要 <strong>Class.forName(XXX.XXX);</strong> 就可以了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring教程 Day4</title>
      <link href="/2022/04/22/Spring%E6%95%99%E7%A8%8B-Day4/"/>
      <url>/2022/04/22/Spring%E6%95%99%E7%A8%8B-Day4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>本文为spring教程笔记4，视频资源为b站黑马程序员<a href="https://www.bilibili.com/video/BV1Sb411s7vP?p=1%E3%80%82">https://www.bilibili.com/video/BV1Sb411s7vP?p=1。</a></p><span id="more"></span><h2 id="Day4"><a href="#Day4" class="headerlink" title="Day4"></a>Day4</h2><p>Spring的事务控制</p><h3 id="spring中基于注解的声明式事务控制配置步骤"><a href="#spring中基于注解的声明式事务控制配置步骤" class="headerlink" title="spring中基于注解的声明式事务控制配置步骤"></a>spring中基于注解的声明式事务控制配置步骤</h3><p>1.配置事务管理器</p><p>2.开启spring对注解事务的支持</p><p>3.在需要事务支持的地方使用@Transactional注解</p>]]></content>
      
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring教程 Day3</title>
      <link href="/2022/04/22/Spring%E6%95%99%E7%A8%8B-Day3/"/>
      <url>/2022/04/22/Spring%E6%95%99%E7%A8%8B-Day3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>本文为spring教程笔记3，视频资源为b站黑马程序员<a href="https://www.bilibili.com/video/BV1Sb411s7vP?p=1%E3%80%82">https://www.bilibili.com/video/BV1Sb411s7vP?p=1。</a></p><span id="more"></span><h2 id="Day3-Spring-面向切面（AOP）"><a href="#Day3-Spring-面向切面（AOP）" class="headerlink" title="Day3 Spring 面向切面（AOP）"></a>Day3 Spring 面向切面（AOP）</h2><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><ul><li>特点：字节码随用随创建，随用随加载</li><li>作用：不修改源码的基础上对方法增强</li><li>分类：</li><li><ul><li>基于接口的动态代理</li><li>基于子类的动态代理</li></ul></li><li><strong>1.基于接口的动态代理：</strong></li><li><ul><li>涉及的类：Proxy</li><li>提供者：JDK官方</li><li>如何创建代理对象：</li><li><ul><li>使用Proxy类中的newProxyInstance方法</li></ul></li><li>创建代理类的要求：被代理类最少实现一个接口，如果没有则不能使用</li><li>newProxyInstance方法的参数：</li><li><ul><li>ClassLoader：类加载器。它是用于加载代理对象字节码的，和被代理对象使用相同的类加载器。固定写法。</li></ul></li><li>Class[]：字节码数组。它是用于让代理对象和被代理对象有相同方法、固定写法。</li><li>InvocationHandler：用于提供增强的代码。他是让我们写如何代理。一般都是写一个该接口的实现类，通常情况下都是匿名内部类。但不是必须的。此接口的实现类都是谁用谁写。</li></ul></li><li><strong>2.基于子类的动态代理</strong></li><li><ul><li>涉及的类：Enhance</li><li>提供者：第三方cglib库</li><li>如何创建代理对象：</li><li><ul><li>使用Enhance类中的create方法</li></ul></li><li>创建代理对象的要求：被代理类不能是最终类</li><li>create方法的参数：</li><li><ul><li>class：字节码。它是指定被代理对象的字节码</li><li>Callback：用于提供增强的代码。他是让我们写如何代理。一般都是写一个该接口的实现类，通常情况下都是匿名内部类。但不是必须的。此接口的实现类都是谁用谁写。我们一般写的都是该接口的子接口实现类：MethodIntercepter</li></ul></li></ul></li></ul><h3 id="spring中基于XML的AOP配置步骤"><a href="#spring中基于XML的AOP配置步骤" class="headerlink" title="spring中基于XML的AOP配置步骤"></a>spring中基于XML的AOP配置步骤</h3><p>1.把通知Bean也交给spring来管理</p><p>2.使用aop：config标签表明开始AOP的配置</p><p>3.使用aop：aspect标签表明配置切面</p><p>​id属性：是给切面提供一个唯一标识</p><p>​ref属性：是指定通知类bean的id</p><p>4.在aop：aspect标签的内部使用对应标签来配置通知的类型</p><p>​我们现在示例是让printlog方法在切入点方法执行之前，所以是前置通知</p><p>​aop：before：表示配置前置通知</p><p>​method属性：用于指定logger类中哪个方法是前置通知</p><p>​pointcut属性：用于指定切入点表达式，该表达式的含义指的是对业务层中哪些方法增强</p><p>​切入点表达式的写法：</p><p>​关键字：execution（表达式）</p><p>​表达式：访问修饰符 返回值 包名.包名.包名…类名.方法名（参数列表）</p><p>​标准的表达式写法：</p><p>​<code>public void com.itheima.service.impl.AccountServiceImpl.saveAccount()</code></p><p>​访问修饰符可以省略（去掉public）</p><p>​返回值可以使用通配符，表示任意返回值（void改为*）</p><p>​包名可以使用通配符，表示任意包。但是有几级包，就要写几个*.</p><p>​包名可以用..表示当前包及其子包</p><p>​类名和方法名都可以使用*表示通配</p><p>​参数列表：</p><p>​可以直接写数据类型（基本类型直接写名称(int)，引用类型写包名、类名的方式（java.lang.String))</p><p>​可以使用通配符表示任意类型，但是必须有参数</p><p>​可以使用..表示有无参数均可，有参数可以是任意类型</p><p>​全通配写法：<code>* *..*.*(..)</code></p><p>​实际开发中切入点表达式的通常写法：切到业务层实现类下的所有方法：<code>.com.itheima.service.impl.*.*(..)</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置Logger类--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;logger&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.logger&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置AOP--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置切面--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">&quot;logAdvice&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;logger&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置通知的类型，并且建立通知方法和切入点方法的关联--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;printlog&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(public void com.itheima.service.impl.AccountServiceImpl.saveAccount())&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:before</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="四种常用的通知类型"><a href="#四种常用的通知类型" class="headerlink" title="四种常用的通知类型"></a>四种常用的通知类型</h3><ul><li>前置通知：before</li><li>后置通知：after-returning</li><li>异常通知：after-throwing</li><li>最终通知：after</li></ul><h3 id="spring中的环绕通知"><a href="#spring中的环绕通知" class="headerlink" title="spring中的环绕通知"></a>spring中的环绕通知</h3><p>问题：当配置了环绕通知之后，切入点方法没有执行，而通知方法执行了。</p><p>分析：通过对比动态代理中的环绕代码， 发现动态代理的环绕通知有明确的切入点调用，而我们的代码中没有</p><p>解决：Spring框架为我们提供了一个接口：ProceedingJoinPoint，该接口有一个方法proceed()，此方法就相当于明确调用切入点方法。该接口可以作为环绕通知的方法参数，在程序执行时，spring框架会为我们提供该接口的实现类供我们使用。</p><p>环绕通知：它是spring框架为我们提供的一种可以在代码中手动控制增强方法何时执行的方式。</p>]]></content>
      
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring教程 Day2</title>
      <link href="/2022/04/22/Spring%E6%95%99%E7%A8%8B-Day2/"/>
      <url>/2022/04/22/Spring%E6%95%99%E7%A8%8B-Day2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>本文为spring教程笔记2，视频资源为b站黑马程序员<a href="https://www.bilibili.com/video/BV1Sb411s7vP?p=1%E3%80%82">https://www.bilibili.com/video/BV1Sb411s7vP?p=1。</a></p><span id="more"></span><h2 id="Day2-spring基于注解的IOC以及IOC的案例"><a href="#Day2-spring基于注解的IOC以及IOC的案例" class="headerlink" title="Day2 spring基于注解的IOC以及IOC的案例"></a>Day2 spring基于注解的IOC以及IOC的案例</h2><h3 id="spring中IOC常用注解"><a href="#spring中IOC常用注解" class="headerlink" title="spring中IOC常用注解"></a>spring中IOC常用注解</h3><ul><li><p>用于创建对象的</p></li><li><ul><li><p>他们的作用就和在xml配置文件中编写一个bean标签实现的功能是一样的</p></li><li><p>@Component</p></li><li><ul><li>作用：把当前类对象存入spring容器中</li><li>属性：</li><li><ul><li>value：用于指定bean的id。当我们不写时，它的默认值是当前类名，且首字母改小写。</li></ul></li></ul></li><li><p>告知spring在创建容器时要扫描的包，配置所需要的标签不是在beans的约束中，而是一个名称为context名称空间和约束中。(也就是要改一下bean标签，然后在里面有一个context标签)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:coomponent-scan</span> <span class="attr">base-packet</span>=<span class="string">&quot;con.itheima&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:coomponent-scan</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>@Controller，一般用在表现层</p></li><li><p>@Service，一般用于业务层</p></li><li><p>@Repository，一般用于持久层</p></li><li><p>以上三个注解它们的作用和属性和Component是一模一样的。它们三个时spring框架为我们提供明确的三层使用的注解，使我们的三层对象更加清晰。</p></li></ul></li><li><p>用于注入数据的</p></li><li><ul><li>他们的作用就和xml配置文件中的bean标签中写一个property标签的作用是一样的</li><li>@Autowired</li><li><ul><li>作用：自动按照类型注入。只要容器中有唯一的一个bean对象类型和要注入的变量类型匹配，就可以注入成功。如果没有任何匹配，则报错。如果IOC去容器中有多个匹配，如果名字相同于匹配对象则注入成功，否则失败。</li><li>出现位置：可以是变量上，也可以是方法上</li><li>细节：在使用注解注入时，set方法不是必须的了</li></ul></li><li>Qualifier：</li><li><ul><li>作用：在按照类注入的基础上再按照名称注入。它在给类成员注入时不能单独使用（要和Autowired配合），但是在给方法参数注入时可以</li><li>属性：</li><li><ul><li>value：用于指定注入bean的id</li></ul></li></ul></li><li>Resource：</li><li><ul><li>作用：直接按照bean的id注入，可以独立使用</li><li>属性：</li><li><ul><li>name：用于指定bean的id</li></ul></li></ul></li><li>以上三个注入都只能注入其他bean类型的数据，而基本类型和String类型无法使用上述注解实现。另外，集合类型的注入只能通过XML来实现</li><li>@Value</li><li><ul><li>作用：用于注入基本类型和String类型的数据</li><li>属性：</li><li><ul><li>value：用于指定数据的值。它可以使用spring中的SpEL（也就是spring中的el表达式）。</li><li>SpEL的写法：${表达式}</li></ul></li></ul></li></ul></li><li><p>用于改变作用范围的</p></li><li><ul><li>他们的作用就和在bean标签中使用scope属性实现的功能是一样的</li><li>@Scope</li><li><ul><li>作用：用于指定bean的作用范围</li><li>属性</li><li><ul><li>value：用于指定范围的取值。常用取值：singleton，prototype</li></ul></li></ul></li></ul></li><li><p>和生命周期相关的（了解）</p></li><li><ul><li><p>他们的作用就和在bean标签中使用init-method和destroy-method的作用是一样的</p></li><li><p>@PreDestroy</p></li><li><ul><li>作用：用于指定销毁方法</li></ul></li><li><p>@PostConstruct</p></li><li><ul><li>作用：用于指定初始化方法</li></ul></li></ul></li></ul><h3 id="Spring配置类"><a href="#Spring配置类" class="headerlink" title="Spring配置类"></a>Spring配置类</h3><ul><li>@configuration</li><li><ul><li>作用：指定当前类是一个配置类</li></ul></li><li>@ComponentScan</li><li><ul><li>作用：用于通过注解指定的spring在创建容器时要扫描的包</li><li>属性：</li><li><ul><li>value、basePackages：作用时一样的，都是用于指定创建容器时要扫描的包。使用此注解就等同于在XML文件中配置了component-scan。</li></ul></li><li>当配置类作为AnnotationConfigApplicationContext对象创建的参数时，该注释可以不写。</li></ul></li><li>@Bean</li><li><ul><li>作用：用于把当前方法的返回值作为bean对象存入spring的ioc容器中</li><li>属性：</li><li><ul><li>name：用于指定bean的id，不写时默认是当前方法的名称</li></ul></li><li>当我们使用注解配置方法时，如果方法有参数，spring框架会去容器中查找有没有可用的bean对象。查找的方式和Autowired注解的作用是一样的。</li></ul></li><li>@import</li><li><ul><li>作用：用于导入其他的配置类</li><li>属性：</li><li><ul><li>value：用于指定其他配置类的字节码。当我们使用Import注解之后，有import注解的类就是父配置类，导入的就是子配置类。</li></ul></li></ul></li><li>@PropertySource</li><li><ul><li>作用：用于指定properties文件的位置</li><li>属性</li><li><ul><li>value：指定文件的名称和路径</li><li>关键字：classpath，表示类路径下</li></ul></li></ul></li></ul><h3 id="spring整合Junit"><a href="#spring整合Junit" class="headerlink" title="spring整合Junit"></a>spring整合Junit</h3><p>1.导入spring整合junit的jar（坐标）</p><p>2.使用junit提供的一个注解把原有的main方法替换了，换成spring提供的@Runwith</p><p>3.告诉spring的运行器，spring的ioc创建是基于xml还是注解的，并且说明位置。@contextConfiguration：</p><p>​locations：指定xml文件的位置，加上classpath关键字，表示在类路径下</p><p>​classes：指定注解类所在的位置</p>]]></content>
      
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring教程 Day1</title>
      <link href="/2022/04/21/Spring%E6%95%99%E7%A8%8B%20Day1/"/>
      <url>/2022/04/21/Spring%E6%95%99%E7%A8%8B%20Day1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>本文为spring教程笔记，视频资源为b站黑马程序员<a href="https://www.bilibili.com/video/BV1Sb411s7vP?p=1%E3%80%82">https://www.bilibili.com/video/BV1Sb411s7vP?p=1。</a></p><span id="more"></span><h2 id="day1"><a href="#day1" class="headerlink" title="day1"></a>day1</h2><h3 id="spring连接数据库的过程："><a href="#spring连接数据库的过程：" class="headerlink" title="spring连接数据库的过程："></a>spring连接数据库的过程：</h3><p>1.注册驱动</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DriverManager.registerDriver(new com.mysql.jdbc.Driver());</span></span><br><span class="line">Class.forname(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br></pre></td></tr></table></figure><p>2.获取连接</p><p><code>Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/test1&quot;,&quot;root&quot;,&quot;123456&quot;);</code></p><p>3.获取操作数据库的预处理对象</p><p><code>PreparedStatement pstm = conn.prepareStatement(&quot;select * from test1&quot;);</code></p><p>4.执行SQL，得到结果集</p><p><code>ResultSet rs = pstm.excuteQuery();</code></p><p>5.遍历结果集</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">system.out.println(rs.getString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6.释放资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rs.close();</span><br><span class="line">pstm.close();</span><br><span class="line">conn.closse();</span><br></pre></td></tr></table></figure><h3 id="在cmd中使用mysql"><a href="#在cmd中使用mysql" class="headerlink" title="在cmd中使用mysql"></a>在cmd中使用mysql</h3><p><code>mysql -uroot -p123456</code><br>然后就可以使用sql语句对数据库进行操作<br>例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">create database test1；</span><br><span class="line">use test1；</span><br></pre></td></tr></table></figure><p>这样之后的sql语句都是在test1这个database中进行操作的。</p><h3 id="程序的耦合"><a href="#程序的耦合" class="headerlink" title="程序的耦合"></a>程序的耦合</h3><p>即程序间的依赖关系</p><ul><li>类之间的依赖</li><li>方法间的依赖</li></ul><p>解耦：降低程序间的依赖关系</p><p>实际开发中应该做到：编译期不依赖，运行时才依赖。</p><p>解耦的思路：</p><p>第一步：使用反射来创建对象，而避免使用new关键字</p><p>第二部：通过读取配置文件来获取要创建的对象全限定类名</p><h3 id="工厂模式解耦"><a href="#工厂模式解耦" class="headerlink" title="工厂模式解耦"></a>工厂模式解耦</h3><p>三层模型：业务层，持久层，展示层</p><p>Bean：可重用组件的含义</p><p>一个创建Bean对象的工厂：它就是创建service和dao对象的</p><p>第一个：需要一个配置文件来配置我们的service和dao</p><p>​配置的内容：唯一标志&#x3D;全限定类名（key&#x3D;value）</p><p>第二个：通过读取配置文件中配置的内容，反射创建对象</p><p>配置文件可以是xml也可以是propertices</p><p>定义一个properties对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static Properties props;</span><br></pre></td></tr></table></figure><p>使用静态代码块为Properties对象赋值:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static</span><br><span class="line">try&#123;</span><br><span class="line">//实例化对象</span><br><span class="line">props = new Propertices();</span><br><span class="line">//获取properties文件的流对象</span><br><span class="line">InoutStream in = BeanFactory.class.getClassLoader().getResourceAsStream(&quot;bean.properties&quot;);</span><br><span class="line">props.load(in);</span><br><span class="line">&#125;catch(Exception e)&#123;</span><br><span class="line">throw new ExceptionInInitializerError(&quot;初始化properties失败&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据Bean的名称获取bean对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">……</span><br></pre></td></tr></table></figure><p>创建的对象要改为单例模式</p><p>对工厂模式的理解：工厂模式就是接管APP和资源的联系，由工厂控制资源的联系，并将资源提供给APP，断开了APP和资源间的依赖关系。（提供对象的名字，由工厂来从仓库中找出来）（Inversion of Control，IOC，控制反转，将对象的控制权转移给工厂）</p><h2 id="Spring基于IOC的XML开发环境"><a href="#Spring基于IOC的XML开发环境" class="headerlink" title="Spring基于IOC的XML开发环境"></a>Spring基于IOC的XML开发环境</h2><p>导入spring-context依赖</p><p>resources里面新建xml文件，导入约束，然后创建bean标签，把对象的创建交给spring管理。</p><p>获取spring的Ioc核心容器，并根据id获取对象</p><p>ApplicationContext的三个常用实现类：</p><ul><li><p>ClassPathXmlApplicationContext：它可以加载路径下的配置文件，要求配置文件必须在类路径下。不然加载不了。</p></li><li><p>FileSystemXmlApplicationContext：它可以加载磁盘任意路径下的配置文件。</p></li><li><p>AnnotationConfigAppllicationContext：它是用于读取注解创建容器的。</p></li></ul><p>核心容器的两个接口引发的问题：</p><p>ApplicationContext： 单例对象适用</p><ul><li>它在构建核心容器时，创建对象采取的策略是采用立即加载的方式。也就是说，只要一读取完配置文件就马上创建配置文件中配置的对象</li></ul><p>BeanFactory： 多例对象适用</p><ul><li>它在构建核心容器时，创建对象采取的策略是采用延时加载的方式。也就是说，什么时候根据id获取对象了，什么时候才真正创建对象。</li></ul><h2 id="Spring中的bean"><a href="#Spring中的bean" class="headerlink" title="Spring中的bean"></a>Spring中的bean</h2><h3 id="Bean对象创建的三种方式"><a href="#Bean对象创建的三种方式" class="headerlink" title="Bean对象创建的三种方式"></a>Bean对象创建的三种方式</h3><ul><li><p>1.使用默认构造函数创建</p></li><li><ul><li><p>在Spring的配置文件中使用bean标签，配以id和class属性之后，且没有其他属性和标签时，采用的就是默认构造函数创建bean对象，此时如果类中没有默认构造函数，则对象无法创建。</p></li><li><p>&#96;&#96;&#96;xml<br><bean id="accountService" class="com.itheima.factory.InstanceFactory"></bean></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">    通过读取这个全限定类名，反射创建一个对象，并且存入Spring核心容器中。</span><br><span class="line"></span><br><span class="line">* 2.使用普通工厂中的方法创建对象（使用某个类中的方法创建对象，并存入spring容器）</span><br><span class="line"></span><br><span class="line">* * ```xml</span><br><span class="line">    &lt;bean id=&quot;accountService&quot; factory-bean=&quot;instanceFactory&quot; factory-method=&quot;getAccountService&quot;&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>3.使用工厂中的静态方法创建对象（使用某个类中的静态方法创建对象，并存入spring容器）</p></li><li><ul><li>&#96;&#96;&#96;xml<br><bean id="accountService" class="com.itheima.factory.StaticFactory" factory-method="getAccountService"></bean><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### Bean对象的作用范围</span><br><span class="line"></span><br><span class="line">bean标签的scope属性：</span><br><span class="line"></span><br><span class="line">* 作用：用于指定bean的作用范围</span><br><span class="line">* 取值</span><br><span class="line">* * singleton：单例的（默认值）</span><br><span class="line">  * prototype：多例的</span><br><span class="line">  * request：作用于web应用的请求范围</span><br><span class="line">  * session：作用于web应用的会话范围</span><br><span class="line">  * global-session：作用域集群环境的会话范围（全局会话范围），当不是集群环境时，它就是session。 </span><br><span class="line"></span><br><span class="line">### Bean对象的生命周期</span><br><span class="line"></span><br><span class="line">单例对象：</span><br><span class="line"></span><br><span class="line">* 出生，当容器创建时对象出生</span><br><span class="line">* 活着，只要容器还在，对象一直活着</span><br><span class="line">* 死亡，容器销毁，对象消亡</span><br><span class="line">* 总结：单例对象的生命周期和容器相同</span><br><span class="line"></span><br><span class="line">多例对象：</span><br><span class="line"></span><br><span class="line">* 出生，当使用对象时spring框架为我们创建</span><br><span class="line">* 活着，对象只要在使用过程中就一直活着</span><br><span class="line">* 死亡，当对象长时间不用，且没有别的对象引用时，由Java垃圾回收器回收</span><br><span class="line"></span><br><span class="line">## Spring中的依赖注入</span><br><span class="line"></span><br><span class="line">依赖注入：Dependency Injection</span><br><span class="line"></span><br><span class="line">IOC的作用：降低程序间的耦合（依赖关系）</span><br><span class="line"></span><br><span class="line">依赖关系的管理：以后都交给spring来维护</span><br><span class="line"></span><br><span class="line">在当前类需要用到其他类的对象，由spring来为我们提供，我们只需要在配置文件中说明。</span><br><span class="line"></span><br><span class="line">依赖关系的维护：就称之为依赖注入。</span><br><span class="line"></span><br><span class="line">依赖注入：能注入的数据有三类：</span><br><span class="line"></span><br><span class="line">* 基本类型和String</span><br><span class="line">* 其他bean类型（在配置文件中或者注解配置过的bean）</span><br><span class="line">* 复杂类型/集合类型</span><br><span class="line"></span><br><span class="line">注入的方式有三种：</span><br><span class="line"></span><br><span class="line">* 使用构造函数提供</span><br><span class="line"></span><br><span class="line">* * 使用的标签：constructor-arg</span><br><span class="line"></span><br><span class="line">  * 标签出现的位置：bean标签的内部</span><br><span class="line"></span><br><span class="line">  * 标签中的属性：</span><br><span class="line"></span><br><span class="line">  * * type：用于指定要注入的数据的数据类型，该主句类型也是构造函数中某个或某些参数的类型。</span><br><span class="line">    * index：用于指定要注入的数据给构造函数中指定索引位置的参数赋值，索引的位置从0开始。</span><br><span class="line">    * name：用于指定给构造函数中指定名称的参数赋值。（常用）</span><br><span class="line">    * value：用于提供基本类型和String类型的数据</span><br><span class="line">    * ref：用于指定其他的bean类型数据。它指的就是在Spring的Ioc核心容器中出现过的bean对象。</span><br><span class="line"></span><br><span class="line">  * 优势：在获取bean对象时，注入数据是必须的操作，否则对象无法创建成功。</span><br><span class="line"></span><br><span class="line">  * 弊端：改变了bean对象的实例化方式，使我们在创建对象时，如果用不到这些数据，也必须提供。</span><br><span class="line"></span><br><span class="line">  * ```xml</span><br><span class="line">    &lt;bean id=&quot;accountService&quot; class=&quot;com.itheima.service.imp.AccountService&quot;&gt;</span><br><span class="line">    &lt;constructor-arg name=&quot;name&quot; value=&quot;test&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">        &lt;constructor-arg name=&quot;age&quot; value=&quot;18&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">        &lt;constructor-arg name=&quot;birthday&quot; reg=&quot;now&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    &lt;！--配置一个日期对象--&gt;</span><br><span class="line">    &lt;bean id=&quot;now&quot; class=&quot;java.util.Date&quot;&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>使用set方法提供（更常用）</p></li><li><ul><li>涉及的标签：property</li><li>出现的位置：bean标签的内部</li><li>标签的属性：</li><li><ul><li>name：用于指定注入时所调用的set方法名称</li><li>value：用于提供基本类型和String类型的数据</li><li>ref：用于指定其他的bean类型数据。</li></ul></li><li>优势：创建对象时没有明确的限制，可以直接使用默认构造函数</li><li>弊端：如果某个成员必须有值，则获取对象时有可能set方法没有执行</li><li>&#96;&#96;&#96;xml<bean id="accountService2" class="com.itheima.service.impl.AccountServiceImpl2">    <property name="name" value="TEST"></property>    <property name="age" value="21"></property>    <property name="birthday" ref="new"></property></bean><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 复杂类型的注入/集合类型的注入</span><br><span class="line"></span><br><span class="line">* * 用于给list结构集合注入的标签：list，array，set</span><br><span class="line">  * 用于给map结构集合注入的标签：map，props</span><br><span class="line">  * 结构相同，标签可以互换</span><br><span class="line"></span><br><span class="line">* ```xml</span><br><span class="line">  &lt;bean id=&quot;accountService&quot; class=&quot;com.itheima.service.impl.AccountServiceImpl3&quot;&gt;</span><br><span class="line">  &lt;property name=&quot;myStrs&quot;&gt;</span><br><span class="line">      &lt;array&gt;</span><br><span class="line">          &lt;value&gt;AAA&lt;/value&gt;</span><br><span class="line">              &lt;value&gt;BBB&lt;/value&gt;</span><br><span class="line">              &lt;value&gt;CCC&lt;/value&gt;</span><br><span class="line">          &lt;/array&gt;</span><br><span class="line">      &lt;/property&gt;</span><br><span class="line">  &lt;/bean&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>使用注解提供</p></li></ul><p>（IDEA可以用alt+insert快速生成构造函数）</p><p>如果是经常变化的数据，并不适用于注入的方式。</p>]]></content>
      
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>看板开发方法</title>
      <link href="/2022/04/21/%E7%9C%8B%E6%9D%BF%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95/"/>
      <url>/2022/04/21/%E7%9C%8B%E6%9D%BF%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>看板开发方法是近年来（2013年）最热门的敏捷和精益开发方法。越来越多的案例表明，它能够改善协作、优化管理、显著提高交付速度、质量和灵活性。看板开发方法的规则简单，但其有效实施依赖于对原理的理解、对原则的坚持和实践的应变。</p><span id="more"></span><h2 id="1-看板的原始含义"><a href="#1-看板的原始含义" class="headerlink" title="1.看板的原始含义"></a>1.看板的原始含义</h2><h3 id="原始定义"><a href="#原始定义" class="headerlink" title="原始定义"></a>原始定义</h3><p>看板源自精益制造，从丰田公司的事件中演化出来，要求准时化、自动化，提供高质量、低成本、快速响应的产品。<br>看板一词源自日文，本义是可视化卡片（硅谷（Silicon Valley）电视剧中即使用看板开发）。看板工具的实质是：后道工序在需要时，通过看板向前道工序发出信号——请告诉我需要数量的输入，前道工序只有得到看板后，才按需生产。看板信号由下游向上游传递，拉动上有的生产活动，时产品向下游移动。拉动的源头是最下游的客户价值，也就是客户订单或需求。</p><h3 id="基于看板的拉动系统实现准时化"><a href="#基于看板的拉动系统实现准时化" class="headerlink" title="基于看板的拉动系统实现准时化"></a>基于看板的拉动系统实现准时化</h3><p>准时化又叫即时生产（Just in time - JIT）是丰田生产方式的一个支柱。看板形成拉动系统，各环节根据看板信息，尽在需要的时间生产需要的数量的必要产品。这带来身缠库存的降低，降低了成本，缩短了交付周期，提高了制造过程的灵活性。</p><h2 id="2-精益产品开发"><a href="#2-精益产品开发" class="headerlink" title="2.精益产品开发"></a>2.精益产品开发</h2><h3 id="价值流动"><a href="#价值流动" class="headerlink" title="价值流动"></a>价值流动</h3><p><img src="https://static001.infoq.cn/resource/image/93/8b/93cc49843b45dd772627527c8423228b.png"></p><p>图中每个卡片代表一个价值项，如：功能需求、缺陷、技术概念验证等。他们所在的列，表示其所处的阶段。这些价值项，每经过一个阶段（图中的列）都会产生新信息，价值得以增加。</p><p>价值流动可能会被阻碍，比如，编码因对第三方接口错误而无法进展；测试因没有设备而停止。图中，红色卡片是对问题和阻碍地可视化。标识阻碍因素并推动其解决，促进价值流动。</p><p>最终限制系统端到端流量是系统瓶颈处的流量，改善端到端地价值流，必须从解决瓶颈问题开始。发现看板墙上的瓶颈并不困难，找到最长的队列就可以了。上图最长的队列出现在测试处，不难看出，测试是价值流动的瓶颈。</p><p>价值、价值流，以及问题和瓶颈的可视化，是改善价值的起始，也是其他看板实践的基础。</p><h3 id="显式化流程规则"><a href="#显式化流程规则" class="headerlink" title="显式化流程规则"></a>显式化流程规则</h3><p>显式化流程规则，是指明确定义和沟通团队所遵循的流程规则。价值项的“流传规则”是看板开发方法中最典型的流程规则。它定义了一个价值项从一个阶段进入下一个阶段所必须达到的标准。下图中，给出了某团队其中一项流传规则的实例，定义了从分析阶段进入开发阶段所必须达到的条件。</p><p><img src="https://static001.infoq.cn/resource/image/5b/5f/5b9816d08795bb9f15915fae65a8325f.png"></p><p>“流传规则”的显式化，让质量内建于各个阶段——这与精益制造中内建质量的思想是一致的。除各个“流转规则”外，其他重要的流程规则也可以或者需要被显式化，如，团队的写作规则、优先级的定义规则等。</p><p>流程显式化更重要的意义在于，它是“持续改进”的出发点和结果的载体。没有显式化的规则作为依据，讨论改进就没有基础，而变得主观和随意。改进的结果通常也需要落实到显式的流程规则当中，让改进稳步进行，避免低效的反复。显式化规则不是为了限定团队的工作方式，而是为了帮助团队更好地改进。</p><h3 id="限制在制品数量"><a href="#限制在制品数量" class="headerlink" title="限制在制品数量"></a>限制在制品数量</h3><p>限制在制品数量是看板开发的核心机制。如下图所示，列标题右边的数字标识了该阶段允许的在制品的最大数目（进行中和完成的价值项的和）。在制品数量小于这个数字时，才可以从前一阶段拉入新的工作。图中，分析阶段的在制品限制数目时3，而实际在制品数目时2，可以拉入新的工作。</p><p><img src="https://static001.infoq.cn/resource/image/34/56/3466798c64aad3bea321ded453853356.png"></p><p>限制在制品数量形成一个与精益制造类似的拉动机制。一个环节有空余的能力（在制品数量未达上限）时，从上游拉入新的工作，拉动的源头时最下游的交付或客户需求。与产品制造类似，通过拉动系统可以加速价值流动和暴露问题。</p><h3 id="度量和管理流动"><a href="#度量和管理流动" class="headerlink" title="度量和管理流动"></a>度量和管理流动</h3><p>快速、顺畅的价值流动是看板开发的目标。快速流动带来的价值产出和快速反馈，它对业务成功至关重要：顺畅流动，意味着稳定和可预测的价值交付能力，这与流动的绝对速度同等重要。</p><p><img src="https://static001.infoq.cn/resource/image/30/fc/30ae4cdb21c2d518fabdf6563e37f9fc.png"></p><p>度量为改善价值流动提供方向参考，同时为改善的结果提供反馈。看板开发方法没有定义特定的度量方法，累积流量图是实际应用较为普遍的一种。图 ㈨是一个典型的累积流量图，左面的斜线是累积已经开始的价值项（如用户需求）数目，右面斜线是累积完成价值项的数目。两条斜线的垂直距离表示某个时刻已经开始但还没有完成的价值项数目，也就是在制品的总计数量。两条斜线的水平间距表示价值项从开始到完成的周期时间，也就是从概念到交付的响应时间，它是价值流动效率的一个重要衡量。斜线的斜率反应的是价值交付的速率，也就是每周可以交付的价值项数量。</p><p><img src="https://static001.infoq.cn/resource/image/54/01/5414c088c5c0225968b9ca5b877cfa01.png"></p><p>累积流量是一个综合的价值流度量方法，可以通过它得到不同维度的信息。例如，我们设想限制在制品的数目，可以缩短周期时间、而对交付速率影响有限。但实际效果如何还要通过事实来检验，通过实验和度量，图中的数据基本验证了这一假设，让改进更有方向，结果更可衡量。同样的数据有不同的呈现方式，图 ㈩基于相同的数据，它突出了在制品数目和周期时间的变化趋势，以及两者的关系。从图中可以看出，周期时间的降低略滞后于在制品数量的降低，这符合精益理论，因为只有在积累的队列被处理完后，对交付周期的改进才能够显现出来。而图 11 反应的是系统流量（每周交付价值的数量）的变化趋势，为改进提供了信心。</p><h3 id="协同改进"><a href="#协同改进" class="headerlink" title="协同改进"></a>协同改进</h3><p>应用可视化、限制在制品数量、以及价值流度量，能够暴露产品开发中的问题和瓶颈。但发现问题还不够，重要的是如何去解决它们，对此看板开发方法给出了两个建议——团队协作和应用科学方法和模型。限制在制品数目本身就能够激发协作，例如在前面图 ㈧的看板墙，可能会出现以下的顺序场景</p><ol><li><p>测试遇到问题 (如输入质量太差) 而被阻塞 ，在制品数量达到上限</p></li><li><p>因在制品数量达到上限，根据规则，测试不能从上游（实现）拉入更多的工作</p></li><li><p>实现阶段已完成的工作无法进入下游测试环节，实现阶段的在制品数量很快也达到上限</p></li><li><p>实现要想开始更多的工作，就必须关注下游的问题，并做出反应，如提高本环节的输出质量，或者是给予帮助</p></li><li><p>实现和测试的协作使价值流动更加顺畅</p></li></ol><p><img src="https://static001.infoq.cn/resource/image/d4/47/d44efe50020a858d032e7d64fe427947.png"></p><p>图是”kanban – Successful Evolutionary Change for Your Technology Business”一书的封面插图，它反映了发生在看板墙前面的协同改进。看板开发方法的基本假设是：产品开发的目标不是单个环节效率的最大化，而是端到端价值流的提升。看板通过拉动机制暴露了限制价值流动的瓶颈，并激发团队协作，改善价值流动。</p><p>解决瓶颈问题的方案可能在瓶颈处，如临时加班、分配更多资源、或相邻环节的支持等。但很多时候解决瓶颈问题的方案在别处，例如提高瓶颈之前环节的输出质量，调整职责分配，甚至是重新设计工作流。</p><p>对于偶然出现的问题，只需要临时性解决方案。如突发性高负荷，可以通过暂时的相互支持解决。而对于系统性问题，如持续的负荷不均衡，则需要长期的方案和更加系统和科学的模型指导，如系统思考、精益思想、排队理论等，这些模型本身不属于看板方法的一部分，但它们让长期的改进有章可循，以后的文章，我将中深入地探讨其中的一些模型。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>看板的实施正是从组织流程现状出发，首先可视化实际工作流并显式化流程；在此基础上，限制在制品数量形成拉动系统以暴露系统问题和瓶颈，度量价值流动以发现改进机会；并通过团队的协作，不断改进和演化出合适的流程、方法，实现一个高效、顺畅的产品开发价值流。</p><p>适应组织的具体情况，和发现合适的变革路径，这两点是敏捷实施的最大困难，看板给出了被证明可行的方案。这可能是看板能够在国外社区迅速推广并成功运用的原因，而在国内，看板这方面的价值还远未被认识和发掘。</p><p><a href="https://www.infoq.cn/article/kanban-development-method">https://www.infoq.cn/article/kanban-development-method</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 软件开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ Map</title>
      <link href="/2022/04/20/C++%20Map/"/>
      <url>/2022/04/20/C++%20Map/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="C-std-map-用法与范例"><a href="#C-std-map-用法与范例" class="headerlink" title="C++ std::map 用法与范例"></a>C++ std::map 用法与范例</h1><p>C++map是一个关联式容器，把键和值联系起来，并用该键来执行查找元素、插入元素、删除元素等操作。<br>map是有排序的关联式容器，会根据元素对应的键来排序，而且key是唯一值。如果同样的key再insert，就会覆盖原本的value。<br>map的运作方式通常是红黑树，这样可以保证在O(log n)时间内完成查找、插入、删除等操作。<br>需要引入头文件<code>&lt;map&gt;</code></p><h2 id="map-常用功能"><a href="#map-常用功能" class="headerlink" title="map 常用功能"></a>map 常用功能</h2><ul><li>元素存取：operator[]：存取指定的[i]元素的资料</li><li>迭代器：<code>begin()</code>,<code>end()</code>,<code>rbegin()</code>,<code>rend()</code></li><li>容量：<code>empty()</code>,<code>size()</code>,<code>max_size()</code></li><li>修改器：<code>clear()</code>,<code>insert()</code>,<code>erase()</code>,<code>swap()</code></li><li>查找：<code>count()</code>,<code>find()</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;<span class="type">int</span>, std::string&gt; studentMap;</span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line">studentMap.<span class="built_in">insert</span>(std::<span class="built_in">pair</span>&lt;<span class="type">int</span>, std::string&gt;(<span class="number">1</span>, <span class="string">&quot;Tom&quot;</span>));</span><br><span class="line">studentMap[<span class="number">1</span>] = <span class="string">&quot;Tom&quot;</span>;<span class="comment">//如果存在则覆盖</span></span><br><span class="line">std::map&lt;<span class="type">int</span>, std::string&gt; studentMap = &#123;</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="string">&quot;Tom&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">2</span>, <span class="string">&quot;Jack&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">3</span>, <span class="string">&quot;John&quot;</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line">studentMap.<span class="built_in">erase</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>具体和其他STL容器相似。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> C++STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面向对象基础</title>
      <link href="/2022/04/20/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/04/20/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>本文为Java学习笔记，主要来自于廖雪峰网站。</p><span id="more"></span><h2 id="1-Java的继承"><a href="#1-Java的继承" class="headerlink" title="1.Java的继承"></a>1.Java的继承</h2><p>继承就是子类继承父类的方法，多态就是同一个方法可以有多种不同的实现形式（通过调用函数的传参来加以区分）</p><p>继承：用关键字<code>extends</code>来实现。<code>class Student extends Person</code></p><ul><li><p>子类自动获得了父类的所有字段，严禁定义与父类重名的字段</p></li><li><p>任何一个类（除了Object）都会继承自某个类。</p></li><li><p>Java只允许一个class继承自一个类，因此一个类有且仅有一个父类（除了Object）</p></li><li><p>继承的子类无法访问父类的private字段或private方法。可以把private改为protected。用protected修饰的字段可以被子类访问。</p></li><li><ul><li><p>super关键字</p></li><li><p>表示父类（超类）。子类引用父类的字段时，可以用super.fieldName</p></li><li><p>在Java中，任何class的构造方法，第一行语句必须是调用父类的构造方法。如果没有明确地调用父类的构造方法，编译器会自动加上一句<code>super();</code>（无参数构造方法）。所以如果父类没有无参数的构造方法就会编译失败。也就是说子类不会继承父类的任何构造方法。</p></li><li><p>可以用<code>super(name,age);</code>来显式调用。</p></li></ul></li><li><ul><li><p>阻止继承</p></li><li><p>正常情况下，只要某个class没有用final修饰符，那么任何类都可以从该class继承。</p></li><li><p>从Java15开始，循序使用<code>sealed</code>修饰class，并通过<code>permits</code>明确写出能够从该class继承的子类名称。</p></li><li><p>例如：定义一个shape类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">Shapr</span> permits Rect,Circle,Triangle&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样只允许指定的三个类名继承他，否则就会报错。防止继承被滥用。</p></li></ul></li><li><ul><li><p>向上转型</p></li><li><pre><code class="java">Person p = new Student();<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  * 这种把一个子类类型安全地变为父类类型的赋值，被称为向上转型（upcasting）。</span><br><span class="line"></span><br><span class="line">* * 向下转型</span><br><span class="line"></span><br><span class="line">  * ```java </span><br><span class="line">    Person p1 = new Student();</span><br><span class="line">    Student s1 = (Student) p1;</span><br></pre></td></tr></table></figure></code></pre></li><li><p>但如果实际类型就是Person，就会转型失败，报错<code>ClassCastException</code>。</p></li><li><p>为了避免向下转型出错，Java提供了<code>instanceof</code>操作符，可以先判断一个实例究竟是不是某种类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">System.out.println(s <span class="keyword">instanceof</span> Person); <span class="comment">// true</span></span><br><span class="line">System.out.println(s <span class="keyword">instanceof</span> Student); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>如果引用变量为null，那么总为false。</p></li><li><p>从Java14之后，判断instanceof后直接转型为指定变量。</p></li></ul></li></ul><h2 id="2-Java的多态"><a href="#2-Java的多态" class="headerlink" title="2.Java的多态"></a>2.Java的多态</h2><p>在继承关系中，子类如果定义了一个与父类方法签名完全相同的方法，称为覆写（Override）；如果方法签名不同，就是Overload。</p><ul><li>加上@Override可以帮助编译器检查是否进行了正确的Override。如果不小心写错了方法签名，编译器会报错。（但不是必须的）</li><li>一个实际类型为Student，引用类型为Person的变量，调用其run()方法（被子类Override），那么调用的时Person的还是Student的呢？</li><li>答案时Student的。因此可以得出结论，Java的实例方法调用时基于运行时的实际类型的动态调用，而非变量的声明类型。这个非常重要的特性在面向对象编程中称之为多态（Polymorphic）</li></ul><p>多态是指，针对某个类型的方法调用，真正执行的方法取决于运行实际实际类型的方法。</p><ul><li><p>加入编写这样一个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runTwice</span><span class="params">(Person p)</span>&#123;</span><br><span class="line">p.run();</span><br><span class="line">p.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它传入的参数类型时Person，我们无法知道传入的实际参数究竟是Person还是Student还是其他子类，因此也就无法确定调用的是不是Person类定义的run()方法。</p></li><li><p>Polymorphism的优点，就是允许添加更多类型的子类实现功能扩展，却不需要秀给基于父类的代码。</p></li><li><ul><li>弊端：Fu f &#x3D; new Zi() f不能用子类特有方法</li><li>解决方法：Zi z &#x3D; (Zi)f 由于本身是子类对象，可以向下转型成子类引用，再调用子类特有方法。</li></ul></li></ul><h2 id="3-抽象类"><a href="#3-抽象类" class="headerlink" title="3.抽象类"></a>3.抽象类</h2><h3 id="抽象类的定义"><a href="#抽象类的定义" class="headerlink" title="抽象类的定义"></a>抽象类的定义</h3><p>如果父类的方法本身不需要实现任何功能，仅仅时为了定义方法签名，目的是让子类去Override，那么，可以把父类的方法声明为抽象方法。</p><p>注意，有抽象方法的类必须声明为抽象类，这样才能正确编译：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象类本身设计成只能用于被继承，无法被实例化，子类必须Override抽象方法。</p><h3 id="面向抽象编程"><a href="#面向抽象编程" class="headerlink" title="面向抽象编程"></a>面向抽象编程</h3><p>当我们定义了抽象类Person，以及具体的Student、Teacher子类之后，我们可以通过抽象类Person类型去引用具体的子类的实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"><span class="type">Person</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>();</span><br></pre></td></tr></table></figure><p>这种引用抽象类的好处在于，我们对其进行方法的调用，并不关心Person类型变量的具体子类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s.run();</span><br><span class="line">t.run();</span><br></pre></td></tr></table></figure><p>这种尽量引用高层类型，避免引用实际子类型的方式，称之为面向抽象编程。</p><p>面向抽象编程的本质就是：</p><ul><li>上层代码只定义规范（例如：<code>abstract class Person</code>)</li><li>不需要子类就可以实现业务逻辑（正常编译）</li><li>具体的业务逻辑由不同的子类实现，调用者并不关心</li></ul><h3 id="抽象类的特点"><a href="#抽象类的特点" class="headerlink" title="抽象类的特点"></a>抽象类的特点</h3><p>A：抽象类和抽象方法必须用abstract关键字修饰。</p><p>​B：抽象类中不一定有抽象方法，但是有抽象方法的累必须定义为抽象类</p><p>​C：抽象类不能被实例化，因为它不是具体的。</p><p>​抽象类有构造方法，但是不能实例化？构造方法的作用是什么呢？</p><p>​答：用于子类访问父类数据的初始化</p><p>​D：抽象的子类</p><p>​a.如果不想重写抽象方法，该子类是一个抽象类。</p><p>​b.重写所有抽象方法，这时候子类是一个具体的类。</p><p>​抽象类的实例化其实是靠具体的子类实现的，是多态的方式。</p><p>​Animal a &#x3D; new Cat();</p><p>多态其实主要用于抽象类和其具体子类，而不是具体类和具体类之间。</p><h3 id="抽象类和接口的区别："><a href="#抽象类和接口的区别：" class="headerlink" title="抽象类和接口的区别："></a>抽象类和接口的区别：</h3><p>A：成员区别</p><p>​抽象类：成员变量：可以变量，可以常量</p><p>​构造方法：有</p><p>​成员方法：可以抽象，也可以非抽象</p><p>B：关系区别</p><p>​类与类：继承，单继承</p><p>​类与接口：实现，单实现，多实现</p><p>​接口与接口：继承，单继承，多继承</p><p>C：设计理念区别：</p><p>​抽象类：被继承体现的是“is a”的关系，抽象类中定义的是该继承体系的共性功能。</p><p>​接口：被实现体现的是“like a”的关系，接口中定义的是该继承体系的扩展功能。</p><h2 id="4-接口"><a href="#4-接口" class="headerlink" title="4.接口"></a>4.接口</h2><p>在抽象类中，抽象方法本质上是定义接口规范：即规定高层类的接口，从而保证所有子类都有相同的接口实现，这样，多态就能发挥出威力。</p><p>如果一个抽象类没有字段，所有方法都是抽象方法，就可以把该抽象类改写为接口：<code>interface</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">String getName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口定义的所有方法默认都是public abstract的，所以这两个修饰符不需要写出来。</p><p>当一个具体的class去实现interface时，需要使用implements关键字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.name + <span class="string">&quot; run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道，在Java中，一个类只能继承自另一个类，不能从多个类继承。但是，一个类可以实现多个interface：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Person</span>, Hello &#123; <span class="comment">// 实现了两个interface</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口继承"><a href="#接口继承" class="headerlink" title="接口继承"></a>接口继承</h3><p>一个interface可以继承自另一个interface，使用<code>extends</code>关键字，相当于扩展了接口的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> <span class="keyword">extends</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">    String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用的时候，实例化的对象永远只能是某个具体的子类，但总是通过接口去引用它，因为接口比抽象类更抽象。</p><h3 id="default方法"><a href="#default方法" class="headerlink" title="default方法"></a>default方法</h3><p>可以在接口中定义default方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(getName() + <span class="string">&quot; run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现类可以不必Override default方法。</p><p><code>default</code>方法和抽象类的普通方法是有所不同的。因为<code>interface</code>没有字段，<code>default</code>方法无法访问字段，而抽象类的普通方法可以访问实例字段。</p><h2 id="5-静态字段和静态方法"><a href="#5-静态字段和静态方法" class="headerlink" title="5.静态字段和静态方法"></a>5.静态字段和静态方法</h2><h3 id="静态字段"><a href="#静态字段" class="headerlink" title="静态字段"></a>静态字段</h3><p>实例字段的特点是，每个实例都有独立的字段，各个实例的同名字段互不影响。</p><p>还有一种字段，是用<code>static</code>修饰的字段，成静态字段<code>static field</code>，每个实例都会共享该字段。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不推荐使用<code>实例变量.静态字段</code>去访问静态字段，推荐使用<code>类名.静态字段</code>来访问。</p><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>用static修饰的方法称为静态方法。</p><p>调用静态方法不需要实例变量，通过类名就可以调用。静态方法属于class而不属于实例，因此，静态方法内部无法访问this变量，也无法访问实例字段，它只能访问静态字段。</p><p>静态方法常用于工具类。例如：</p><ul><li>Arrays.sort()</li><li>Math.random()</li></ul><p>静态方法也常用于辅助方法。注意到main方法也是静态方法。</p><h3 id="接口的静态字段"><a href="#接口的静态字段" class="headerlink" title="接口的静态字段"></a>接口的静态字段</h3><p>interface中可以有静态字段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MALE</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">FEMALE</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中public static final也可以省略，编译器会自动加上。</p><h2 id="6-包（Package）"><a href="#6-包（Package）" class="headerlink" title="6.包（Package）"></a>6.包（Package）</h2><p>在现实中，如果两个人写了相同的类名，或者自己写的类名和JDK的类名相同，如何解决类名冲突？</p><p>在Java中，我们使用package来解决名字冲突。</p><p>Java定义了一种名字空间，成之类包（package），一个类总是属于某个包。类名（比如Person）只是一个简写，真正的完整类名是<code>包名.类名</code></p><p>例如：</p><p>小明的<code>Person</code>类存放在包<code>ming</code>下面，因此，完整类名是<code>ming.Person</code>；</p><p>小红的<code>Person</code>类存放在包<code>hong</code>下面，因此，完整类名是<code>hong.Person</code>；</p><p>小军的<code>Arrays</code>类存放在包<code>mr.jun</code>下面，因此，完整类名是<code>mr.jun.Arrays</code>；</p><p>JDK的<code>Arrays</code>类存放在包<code>java.util</code>下面，因此，完整类名是<code>java.util.Arrays</code>。</p><p>在定义<code>class</code>的时候，我们需要在第一行声明这个<code>class</code>属于哪个包。</p><p>小明的<code>Person.java</code>文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">package ming; // 申明包名ming</span><br><span class="line"></span><br><span class="line">public class Person &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小军的<code>Arrays.java</code>文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">package mr.jun; // 申明包名mr.jun</span><br><span class="line"></span><br><span class="line">public class Arrays &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Java虚拟机执行的时候，JVM只看完整类名，因此，只要包名不同，类就不同。</p><p>包可以是多层结构，用<code>.</code>隔开。例如：<code>java.util</code>。</p><p><strong> 要特别注意：包没有父子关系。java.util和java.util.zip是不同的包，两者没有任何继承关系。</strong></p><p>没有定义包名的<code>class</code>，它使用的是默认包，非常容易引起名字冲突，因此，不推荐不写包名的做法。</p><p>我们还需要按照包结构把上面的Java文件组织起来。假设以<code>package_sample</code>作为根目录，<code>src</code>作为源码目录，那么所有文件结构就是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package_sample</span><br><span class="line">└─ src</span><br><span class="line">    ├─ hong</span><br><span class="line">    │  └─ Person.java</span><br><span class="line">    │  ming</span><br><span class="line">    │  └─ Person.java</span><br><span class="line">    └─ mr</span><br><span class="line">       └─ jun</span><br><span class="line">          └─ Arrays.java</span><br></pre></td></tr></table></figure><p>即所有Java文件对应的目录层次要和包的层次一致。</p><p>编译后的<code>.class</code>文件也需要按照包结构存放。如果使用IDE，把编译后的<code>.class</code>文件放到<code>bin</code>目录下，那么，编译的文件结构就是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package_sample</span><br><span class="line">└─ bin</span><br><span class="line">   ├─ hong</span><br><span class="line">   │  └─ Person.class</span><br><span class="line">   │  ming</span><br><span class="line">   │  └─ Person.class</span><br><span class="line">   └─ mr</span><br><span class="line">      └─ jun</span><br><span class="line">         └─ Arrays.class</span><br></pre></td></tr></table></figure><p>编译的命令相对比较复杂，我们需要在<code>src</code>目录下执行<code>javac</code>命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -d ../bin ming/Person.java hong/Person.java mr/jun/Arrays.java</span><br></pre></td></tr></table></figure><p>在IDE中，会自动根据包结构编译所有Java源码，所以不必担心使用命令行编译的复杂命令。</p><h3 id="包作用域"><a href="#包作用域" class="headerlink" title="包作用域"></a>包作用域</h3><p>位于同一个包的类，可以访问包作用域的字段和方法。不用<code>public</code>、<code>protected</code>、<code>private</code>修饰的字段和方法就是包作用域。例如，<code>Person</code>类定义在<code>hello</code>包下面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> hello;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="comment">// 包作用域:</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Main</code>类也定义在<code>hello</code>包下面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> hello;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        p.hello(); <span class="comment">// 可以调用，因为Main和Person在同一个包</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="import"><a href="#import" class="headerlink" title="import"></a>import</h3><p>在一个<code>class</code>中，我们总会引用其他的<code>class</code>。例如，小明的<code>ming.Person</code>类，如果要引用小军的<code>mr.jun.Arrays</code>类，他有三种写法：</p><p>第一种，直接写出完整类名，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Person.java</span></span><br><span class="line"><span class="keyword">package</span> ming;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        mr.jun.<span class="type">Arrays</span> <span class="variable">arrays</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">mr</span>.jun.Arrays();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很显然，每次写完整类名比较痛苦。</p><p>因此，第二种写法是用<code>import</code>语句，导入小军的<code>Arrays</code>，然后写简单类名：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Person.java</span></span><br><span class="line"><span class="keyword">package</span> ming;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入完整类名:</span></span><br><span class="line"><span class="keyword">import</span> mr.jun.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Arrays</span> <span class="variable">arrays</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Arrays</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在写<code>import</code>的时候，可以使用<code>*</code>，表示把这个包下面的所有<code>class</code>都导入进来（但不包括子包的<code>class</code>）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Person.java</span></span><br><span class="line"><span class="keyword">package</span> ming;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入mr.jun包的所有class:</span></span><br><span class="line"><span class="keyword">import</span> mr.jun.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Arrays</span> <span class="variable">arrays</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Arrays</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们一般不推荐这种写法，因为在导入了多个包后，很难看出<code>Arrays</code>类属于哪个包。</p><p>还有一种<code>import static</code>的语法，它可以导入可以导入一个类的静态字段和静态方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入System类的所有静态字段和静态方法:</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.System.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 相当于调用System.out.println(…)</span></span><br><span class="line">        out.println(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>import static</code>很少使用。</p><p>Java编译器最终编译出的<code>.class</code>文件只使用<em>完整类名</em>，因此，在代码中，当编译器遇到一个<code>class</code>名称时：</p><ul><li>如果是完整类名，就直接根据完整类名查找这个<code>class</code>；</li><li>如果是简单类名，按下面的顺序依次查找：<ul><li>查找当前<code>package</code>是否存在这个<code>class</code>；</li><li>查找<code>import</code>的包是否包含这个<code>class</code>；</li><li>查找<code>java.lang</code>包是否包含这个<code>class</code>。</li></ul></li></ul><p>如果按照上面的规则还无法确定类名，则编译报错。</p><p>我们来看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Main.java</span></span><br><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.Format;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        java.util.List list; <span class="comment">// ok，使用完整类名 -&gt; java.util.List</span></span><br><span class="line">        <span class="type">Format</span> <span class="variable">format</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// ok，使用import的类 -&gt; java.text.Format</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;hi&quot;</span>; <span class="comment">// ok，使用java.lang包的String -&gt; java.lang.String</span></span><br><span class="line">        System.out.println(s); <span class="comment">// ok，使用java.lang包的System -&gt; java.lang.System</span></span><br><span class="line">        <span class="type">MessageFormat</span> <span class="variable">mf</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 编译错误：无法找到MessageFormat: MessageFormat cannot be resolved to a type</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，编写class的时候，编译器会自动帮我们做两个import动作：</p><ul><li>默认自动<code>import</code>当前<code>package</code>的其他<code>class</code>；</li><li>默认自动<code>import java.lang.*</code>。</li></ul><p> 注意：自动导入的是java.lang包，但类似java.lang.reflect这些包仍需要手动导入。</p><p>如果有两个<code>class</code>名称相同，例如，<code>mr.jun.Arrays</code>和<code>java.util.Arrays</code>，那么只能<code>import</code>其中一个，另一个必须写完整类名。</p><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><p>为了避免名字冲突，我们需要确定唯一的包名。推荐的做法是使用倒置的域名来确保唯一性。例如：</p><ul><li>org.apache</li><li>org.apache.commons.log</li><li>com.liaoxuefeng.sample</li></ul><p>子包就可以根据功能自行命名。</p><p>要注意不要和<code>java.lang</code>包的类重名，也不要和JDK常用类重名。</p><h2 id="7-作用域"><a href="#7-作用域" class="headerlink" title="7.作用域"></a>7.作用域</h2><p>public：可以被其他任何类访问</p><p>private：访问权限限定在class的内部。由于Java支持嵌套类，如果一个类内部还定义了嵌套类，那么，嵌套类拥有private的权限。</p><p>protected：可以被子类，子类的子类等访问</p><p>package</p><p>局部变量</p><p>final：与访问权限不冲突。作用：1.修饰class阻止被继承。2.修饰method阻止被子类覆写。3.修饰field阻止被重新赋值。4.修饰局部变量阻止被重新赋值。</p><h2 id="8-内部类"><a href="#8-内部类" class="headerlink" title="8.内部类"></a>8.内部类</h2><p>有一种类，它被定义在另一个类的内部，所以成为内部类（Nested Class）。Java内部类分为好几种，通常情况下用的不多。</p><h3 id="Inner-Class"><a href="#Inner-Class" class="headerlink" title="Inner Class"></a>Inner Class</h3><p>如果一个类定义在另一个类内部，这个类就是Inner Class：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Outer</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>(<span class="string">&quot;Nested&quot;</span>); <span class="comment">// 实例化一个Outer</span></span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> outer.<span class="keyword">new</span> <span class="title class_">Inner</span>(); <span class="comment">// 实例化一个Inner</span></span><br><span class="line">        inner.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    Outer(String name) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello, &quot;</span> + Outer.<span class="built_in">this</span>.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Inner Class的实例不能单独存在，必须依附于一个Outer Class的实例。</p><p>Inner Class可以修改Outer Class的private字段，访问private方法。</p><h3 id="Anonymous-Class"><a href="#Anonymous-Class" class="headerlink" title="Anonymous Class"></a>Anonymous Class</h3><p>还有一种定义Inner Class的方法，不需要在Outer Class中明确定义Class，而是在方法内部，通过匿名类（Anonymous Class）来定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Outer</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>(<span class="string">&quot;Nested&quot;</span>);</span><br><span class="line">        outer.asyncHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    Outer(String name) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">asyncHello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Hello, &quot;</span> + Outer.<span class="built_in">this</span>.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(r).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>观察asyncHello()方法，我们在方法内部实例化了一个Runnable。Runnable本身是接口，接口是不能被实例化的，所以这里实际上是定义了一个实现了Runnable接口的匿名类，并且通过new实例化该匿名类，然后转型为Runnable。在定义匿名类的时候就必须实例化它，定义匿名类的写法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;</span><br><span class="line"><span class="comment">//实现必要的抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名类和Inner Class一样，可以访问Outer Class的<code>private</code>字段和方法。之所以我们要定义匿名类，是因为在这里我们通常不关心类名，比直接定义Inner Class可以少写很多代码。</p><p>除了接口外，匿名类也完全可以继承自普通类。观察以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        HashMap&lt;String, String&gt; map1 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        HashMap&lt;String, String&gt; map2 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;() &#123;&#125;; <span class="comment">// 匿名类!</span></span><br><span class="line">        HashMap&lt;String, String&gt; map3 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;() &#123;</span><br><span class="line">            &#123;</span><br><span class="line">                put(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">                put(<span class="string">&quot;B&quot;</span>, <span class="string">&quot;2&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(map3.get(<span class="string">&quot;A&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>map1</code>是一个普通的<code>HashMap</code>实例，但<code>map2</code>是一个匿名类实例，只是该匿名类继承自<code>HashMap</code>。<code>map3</code>也是一个继承自<code>HashMap</code>的匿名类实例，并且添加了<code>static</code>代码块来初始化数据。观察编译输出可发现<code>Main$1.class</code>和<code>Main$2.class</code>两个匿名类文件。</p><h3 id="Static-Nested-Class"><a href="#Static-Nested-Class" class="headerlink" title="Static Nested Class"></a>Static Nested Class</h3><p>和Inner Class类似，但是使用<code>static</code>修饰，称为静态内部类（Static Nested Class）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Outer.<span class="type">StaticNested</span> <span class="variable">sn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>.StaticNested();</span><br><span class="line">        sn.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">NAME</span> <span class="operator">=</span> <span class="string">&quot;OUTER&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    Outer(String name) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StaticNested</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello, &quot;</span> + Outer.NAME);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用<code>static</code>修饰的内部类和Inner Class有很大的不同，它不再依附于<code>Outer</code>的实例，而是一个完全独立的类，因此无法引用<code>Outer.this</code>，但它可以访问<code>Outer</code>的<code>private</code>静态字段和静态方法。如果把<code>StaticNested</code>移到<code>Outer</code>之外，就失去了访问<code>private</code>的权限。</p><h2 id="9-classpath和jar"><a href="#9-classpath和jar" class="headerlink" title="9.classpath和jar"></a>9.classpath和jar</h2><h3 id="classpath"><a href="#classpath" class="headerlink" title="classpath"></a>classpath</h3><p>classpath是JVM用到的一个环境变量，它用来指示JVM如何搜索class，即如果要加载一个abc.xyz.Hello的类，应该去哪搜索对应的Hello.class文件。</p><p>我们强烈<em>不推荐</em>在系统环境变量中设置<code>classpath</code>，那样会污染整个系统环境。在启动JVM时设置<code>classpath</code>才是推荐的做法。实际上就是给<code>java</code>命令传入<code>-classpath</code>或<code>-cp</code>参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -classpath .;C:\work\project1\bin;C:\shared abc.xyz.Hello</span><br></pre></td></tr></table></figure><p>或者使用<code>-cp</code>的简写。如果没有设置则默认为当前目录<code>.</code>。</p><p>假设我们有一个编译后的<code>Hello.class</code>，它的包名是<code>com.example</code>，当前目录是<code>C:\work</code>，那么，目录结构必须如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C:\work</span><br><span class="line">└─ com</span><br><span class="line">   └─ example</span><br><span class="line">      └─ Hello.class</span><br></pre></td></tr></table></figure><p>运行这个<code>Hello.class</code>必须在当前目录下使用如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\work&gt; java -cp . com.example.Hello</span><br></pre></td></tr></table></figure><p>JVM根据classpath设置的<code>.</code>在当前目录下查找<code>com.example.Hello</code>，即实际搜索文件必须位于<code>com/example/Hello.class</code>。如果指定的<code>.class</code>文件不存在，或者目录结构和包名对不上，均会报错。</p><h3 id="jar包"><a href="#jar包" class="headerlink" title="jar包"></a>jar包</h3><p>如果有很多<code>.class</code>文件，散落在各层目录中，肯定不便于管理。如果能把目录打一个包，变成一个文件，就方便多了。</p><p>jar包就是用来干这个事的，它可以把<code>package</code>组织的目录层级，以及各个目录下的所有文件（包括<code>.class</code>文件和其他文件）都打成一个jar文件，这样一来，无论是备份，还是发给客户，就简单多了。</p><p>jar包实际上就是一个zip格式的压缩文件，而jar包相当于目录。如果我们要执行一个jar包的<code>class</code>，就可以把jar包放到<code>classpath</code>中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp ./hello.jar abc.xyz.Hello</span><br></pre></td></tr></table></figure><p>这样JVM会自动在<code>hello.jar</code>文件里去搜索某个类。</p><h2 id="10-模块"><a href="#10-模块" class="headerlink" title="10.模块"></a>10.模块</h2><p>jar只是用于存放class的容器，它并不关心class之间的依赖。</p><p>从Java 9开始引入的模块，主要是为了解决“依赖”这个问题。如果<code>a.jar</code>必须依赖另一个<code>b.jar</code>才能运行，那我们应该给<code>a.jar</code>加点说明啥的，让程序在编译和运行的时候能自动定位到<code>b.jar</code>，这种自带“依赖关系”的class容器就是模块。</p><p>打包模块和JRE（略）</p><h2 id="11-为什么new子类要先执行父类的构造方法"><a href="#11-为什么new子类要先执行父类的构造方法" class="headerlink" title="11.为什么new子类要先执行父类的构造方法"></a>11.为什么new子类要先执行父类的构造方法</h2><p>实例化的本质，是调用构造函数分配实例标识，申请内存存放实例中各成员变量的初始值。如果该类继承了某个父类，也就继承了（相当于复制）了父类的所有非私有成员变量，而入伏哦没有给继承过来的成员变量赋初值，那后续施加在该成员变量的操作便无法进行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="comment">// 静态变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">p_StaticField</span> <span class="operator">=</span> <span class="string">&quot;父类--静态变量&quot;</span>;</span><br><span class="line">    <span class="comment">// 变量(其实这用对象更好能体同这一点，如专门写一个类的实例)</span></span><br><span class="line">　　</span><br><span class="line">    <span class="comment">//如果这个变量放在初始化块的后面，是会报错的，因为你根本没有被初始化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">String</span> <span class="variable">p_Field</span> <span class="operator">=</span> <span class="string">&quot;父类--变量&quot;</span>;</span><br><span class="line">    <span class="comment">// 静态初始化块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(p_StaticField);</span><br><span class="line">        System.out.println(<span class="string">&quot;父类--静态初始化块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化块</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(p_Field);</span><br><span class="line">        System.out.println(<span class="string">&quot;父类--初始化块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Parent</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类--构造器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubClass</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="comment">// 静态变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">s_StaticField</span> <span class="operator">=</span> <span class="string">&quot;子类--静态变量&quot;</span>;</span><br><span class="line">    <span class="comment">// 变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">String</span> <span class="variable">s_Field</span> <span class="operator">=</span> <span class="string">&quot;子类--变量&quot;</span>;</span><br><span class="line">    <span class="comment">// 静态初始化块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(s_StaticField);</span><br><span class="line">        System.out.println(<span class="string">&quot;子类--静态初始化块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化块</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(s_Field);</span><br><span class="line">        System.out.println(<span class="string">&quot;子类--初始化块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SubClass</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//super();</span></span><br><span class="line">        System.out.println(<span class="string">&quot;子类--构造器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 程序入口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;*************in main***************&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">SubClass</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;*************second subClass***************&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">SubClass</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">父类--静态变量</span><br><span class="line">父类--静态初始化块</span><br><span class="line">子类--静态变量</span><br><span class="line">子类--静态初始化块</span><br><span class="line">*************in main***************</span><br><span class="line">父类--变量</span><br><span class="line">父类--初始化块</span><br><span class="line">父类--构造器</span><br><span class="line">子类--变量</span><br><span class="line">子类--初始化块</span><br><span class="line">子类--构造器</span><br><span class="line">*************second subClass***************</span><br><span class="line">父类--变量</span><br><span class="line">父类--初始化块</span><br><span class="line">父类--构造器</span><br><span class="line">子类--变量</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对象与this</title>
      <link href="/2022/04/20/%E5%AF%B9%E8%B1%A1%E4%B8%8Ethis/"/>
      <url>/2022/04/20/%E5%AF%B9%E8%B1%A1%E4%B8%8Ethis/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="self与this"><a href="#self与this" class="headerlink" title="self与this"></a>self与this</h2><p>对象，可以理解为“多个相关数据的统一载体”。比如一个人，有name，age，height等社会或生理体征，而这些数据是数以一个个体的，如果用数组去存，表现力有所欠缺，无法表达“它们属于同一个个体”的含义。</p><p>但我们知道，在Java中对象是在堆空间中生成的，数据会在堆空间占据一定的内存开销，而方法只有一份。</p><p>为什么方法被设计出只有一份呢？</p><p>因为多个个体，属性可能不同，但我们都有相同的method，没必要和属性数据一样在堆空间各存一份，所以被抽取出来存放。</p><p>此时，方法相当于一套指令模板，谁都可以传入数据交给它执行，然后得到执行后的结果返回。</p><p>那么，方法如何知道是谁执行的呢？</p><p>python的self，Java的this其实就是解决这个问题的。可以理解为对象内部持有一个应用，党调用某个方法时，必须传递这个对象引用，然后方法根据这个引用就知道当前这套指令是对哪个对象的数据进行操作了。</p><h2 id="static与this"><a href="#static与this" class="headerlink" title="static与this"></a>static与this</h2><p>我们都知道，static修饰的属性或方法其实是属于类的，是所有对象共享的。</p><p>之所以一个变量或者方法要声明为static，是因为</p><ul><li>static变量：大家共有的，大家都一样，不是特定的差异化数据</li><li>static方法：这个方法不处理差异化数据</li></ul><p>也就是说，static注定是与差异化数据无关，也就是与具体对象的数据无关。</p><p>以静态方法为例，当你确定一个方法只提供通用的操作流程，而不会在内部引用具体对象的数据时，你就<strong>可以</strong>把它定为静态方法。</p><p>这个其实和我们之前听到的解释不一样。网络上一贯的解释都是上来就告诉你静态方法不能访问实例变量，再解释为什么，是倒着解释的。而上面这段话的出发点是，当你满足什么条件时，你就可以把一个方法定为静态方法。</p><p>为什么Java中静态方法无法访问非静态数据（实例字段）和非静态方法（实例方法）。<strong>因为Java不会在调用静态方法时传递this，静态方法内没有this当然无法调用实例相关的一切。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">我们在一个实例方法中调用另一个实例方法或者实例变量时，其实都是通过<span class="built_in">this</span>调用的，比如</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="built_in">this</span>.name);</span><br><span class="line">    <span class="built_in">this</span>.show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，有些培训班视频会说静态方法随着类加载而加载，此时并没有对象实例化，所以静态方法无法访问实例相关数据，倒也勉强说得通。看大家自己怎么理解了，能自圆其说即可。</p><p>java子类实例化时会隐式调用父类构造器</p><p>本质和子类调用方法给父类传参一样一样的！只不过传参的过程很特殊：</p><ul><li>new的时候自动传参，不是我们主动调用，所以感知不到</li><li>Java中的this是隐式传递的，所以我们更加注意不到了</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> springboot </tag>
            
            <tag> SSM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度优先搜索（DFS）</title>
      <link href="/2022/04/20/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%88DFS%EF%BC%89/"/>
      <url>/2022/04/20/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%88DFS%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>深度优先搜索算法是一种用于遍历或搜索树或图的算法。这个算法会尽可能深地搜索树的分支。当节点v的所在边都已被探寻过，搜索将回溯到发现节点v的那条边的起始节点。这一过程一直进行到已大仙从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程。整个进程反复进行直到所有节点都被访问为止。</p><p>深度优先搜索是图论中的经典算法，利用深度优先搜索算法可以产生目标图的拓扑排序表。利用拓扑排序表可以方便的解决很有相关的图论问题，如无权最长路径问题等等。</p><p>因发明“深度优先搜索算法”，约翰·霍普克罗夫特与罗伯特·塔扬在1986年共同获得计算机领域的最高奖：图灵奖。</p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>1.首先将根节点放入stack中。</p><p>2.从stack中取出第一个节点，并检验它是否为目标。</p><p>​如果找到目标，则结束搜寻并回传结果。</p><p>​否则将它某一个尚未检验过的直接子节点加入stack中。</p><p>3.重复步骤2.</p><p>4.如果不存在未检测过的直接子节点。</p><p>​将上一级节点加入stack中。</p><p>​重复步骤2.</p><p>5.重复步骤4。</p><p>6.如果stack为空，表示整张图都检查过了——亦即图中没有欲搜寻的目标。结束搜寻并回传“找不到目标”。</p><h2 id="实现代码（略）"><a href="#实现代码（略）" class="headerlink" title="实现代码（略）"></a>实现代码（略）</h2><p>用for循环遍历某一步的所有可能，使用递归实现进入下一个节点，并修改状态。递归结束后恢复初始状态。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>广度优先搜索（BFS）</title>
      <link href="/2022/04/19/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%88BFS%EF%BC%89/"/>
      <url>/2022/04/19/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%88BFS%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>广度优先搜索算法是一种图形搜索算法。简单的说，BDFS是从根节点开始，沿着树的宽度遍历树的结点。如果所有节点均被访问，则算法终止。广度优先搜索一般用队列（Queue）实现。</p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>BFS是一种暴力搜索算法，目的是系统地展开并检查图红的所有节点，以寻找结果。换句话说，它并不考虑结果的可能地址，彻底地搜索整张图，知道找到结果为止。BFS并不使用经验法则算法。</p><p>从算法的观点，所有展开节点得到的子节点都会被加进一个先进先出的队列中，从队列中取出第一个节点，并检验它是否为目标。如果找到目标，则结束搜索并回传结果。否则将它所有尚未检验过的直接子节点加入队列中。如果队列为空，表示整张图都检查过了，即图中没有搜索的目标，那么就结束搜索并回传“找不到目标”。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">std::queue&lt;node *&gt; visited, unvisited;</span><br><span class="line">node nodes[<span class="number">9</span>];</span><br><span class="line">node *current;</span><br><span class="line"></span><br><span class="line">unvisited.<span class="built_in">push</span>(&amp;nodes[<span class="number">0</span>]); </span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!unvisited.<span class="built_in">empty</span>()) &#123; </span><br><span class="line">    current = (unvisited.<span class="built_in">front</span>()); <span class="comment">// 目前的应该检验的</span></span><br><span class="line">    <span class="keyword">if</span> (current-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">        unvisited.<span class="built_in">push</span>(current-&gt;left); </span><br><span class="line">    <span class="keyword">if</span> (current-&gt;right != <span class="literal">NULL</span>) </span><br><span class="line">        unvisited.<span class="built_in">push</span>(current-&gt;right);</span><br><span class="line">    visited.<span class="built_in">push</span>(current);</span><br><span class="line">    cout &lt;&lt; current-&gt;self &lt;&lt; endl;</span><br><span class="line">    unvisited.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="广度优先搜索算法的应用"><a href="#广度优先搜索算法的应用" class="headerlink" title="广度优先搜索算法的应用"></a>广度优先搜索算法的应用</h2><p>广度优先搜索能用来解决图论中的许多问题，例如：</p><ul><li>查找图中的所有连接组件（Connected Component）。一个连接组件是图中的最大相连子图。</li><li>查找连接组件中的所有节点。</li><li>查找非加权图中任两点的最短路径</li><li>测试一个图是否为二分图</li><li>（Reverse）Cuthill-McKee算法</li></ul><h3 id="查找连接组件"><a href="#查找连接组件" class="headerlink" title="查找连接组件"></a>查找连接组件</h3><p>从起点开始，执行DFS后经过的所有节点，即包含起点的一个连接组件。</p><h3 id="测试是否为二分图"><a href="#测试是否为二分图" class="headerlink" title="测试是否为二分图"></a>测试是否为二分图</h3><p>从任意结点开始搜索，并在搜索过程中给节点不同的标签。例如，给开始节点标签0，开始节点所有邻居标签1，开始节点所有邻居的邻居标签0……以此类推。若在此搜索过程中，任一节点有跟其相同标签的邻居，则此图就不是二分图，否则是二分图。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>元学习（乱）</title>
      <link href="/2022/04/18/%E5%85%83%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B9%B1%EF%BC%89/"/>
      <url>/2022/04/18/%E5%85%83%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B9%B1%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>传统的机器学习-&gt;需要大量的数据-&gt;但是元学习即使是少量的数据也能达到相同的（compatible）效果。</p><p>样本过少可能产生过拟合-&gt;应用转移学习，先用充足的common classes训练</p><p>N-way and K-shot: N classes, K support samples and Q query samples</p><p>The goal: classify these N x Q query samples into N classes based on the N x K support samples.</p><p>元学习（meta-learning）在某些地方不如全分类（whole-classification）</p><p>Classifier-Baseline</p><p>Meta-Baseline</p><p> inheriting one of the most effective evaluation metrics of the whole-classification model</p><p>meta-learning 的框架可以分成三类：1.Memory-based methods 2.Optimization-based methods 3.metric-based methods</p><p>该文章主要的内容：探讨whole-classification 和 meta-learning objectives的区别。</p><p>传统的few-shot classification是给大容量的base数据集，然后用少量样本训练出新的数据集。在N-way K-shot few shot classification中，support-set有N classes with K samples per class，the query-set 在n类每类中有Q samples，目标就是分类N x Q query images into N classes。</p><p>做了个实验。。。</p><p>很多其他的方法都需要更多的参数，更加复杂的设计，而meta-baseline更加简单。</p><p>meta-baseline和classifier-baseline之前的差异很小。</p><p>base class generation上升，novel class generation在下降。让base更好的时候的副作用。</p><p>meta-baseline trained without classification training stage 在base class generalization方面更好，但是在novel class generalization上meta-baseline with whole-classification training 更好。也就是说whole-classification提供了更强的转移能力，有助于在新的分类上产生更好的效果。但也有trade-off发生在base class上。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Lifelong Learning简介</title>
      <link href="/2022/04/18/Lifelong-Learning%E7%AE%80%E4%BB%8B/"/>
      <url>/2022/04/18/Lifelong-Learning%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="2020机器学习前沿技术—-LifeLong-learning"><a href="#2020机器学习前沿技术—-LifeLong-learning" class="headerlink" title="2020机器学习前沿技术—-LifeLong learning"></a>2020机器学习前沿技术—-LifeLong learning</h1><h2 id="1-为什么要研究LifeLong-learning"><a href="#1-为什么要研究LifeLong-learning" class="headerlink" title="1.为什么要研究LifeLong learning"></a>1.为什么要研究LifeLong learning</h2><p>细数机器学习处理的问题，概括地讲，可以分为如下几类：</p><ul><li>计算机视觉（CV）： object classification, object detection, object segmentation, style transfer, denoising, image generation, image caption</li><li>语音（Speech) : speech recogniton， speech synthesis</li><li>自然语言处理（NLP): Machine translation, text classfication， emotional recogniton</li><li>推荐系统: Recommendation, CRT</li></ul><p>目前针对各个大类的不同子问题，都会设计不同的网络结构，设计不同的loss，采用不同的数据据处理。这使得机器学习”偏科严重“。</p><h2 id="2-概念"><a href="#2-概念" class="headerlink" title="2. 概念"></a>2. 概念</h2><p>LifeLong learning意味着以前学到的知识，能够促进下一个任务Task B的学习，在学习完Task B之后，要不仅可以很好地处理Task B，同时在Task A上不能有明显的下降，最好是有所提升或者保持。</p><p>学完Task A再学Task B，Task A的准确率就会下降很多，这就是Forget，这就是Transfer Learning所带来的问题，也是LifeLong learning需要解决的问题。</p><p>如果采用Multi-task Learning，需要把Task A 和Task B的训练数据都存储起来，需要的时候放在一起训练。虽然Task A和B都达到了不错的效果，但是所有数据的存储会是一个很大的问题。</p><p>因此，如何解决数据存储的问题呢？可以借助于GAN网络来完成，减少了数据存储，但带来了更大的计算量。</p><h2 id="3-这个领域还有那些前沿的研究方向"><a href="#3-这个领域还有那些前沿的研究方向" class="headerlink" title="3.这个领域还有那些前沿的研究方向"></a>3.这个领域还有那些前沿的研究方向</h2><ul><li><p><strong>Curriculum Learning</strong> 类似于一个课程系的学习， 研究的是如何安排课程学习的先后顺序。</p></li><li><p><strong>Taskonomy</strong> 研究的是各个任务之间的关系， 即该先学哪个，后学哪个。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>prompt简介</title>
      <link href="/2022/04/18/prompt%E7%AE%80%E4%BB%8B/"/>
      <url>/2022/04/18/prompt%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>近年来，NLP技术发展迅猛。自BERT于2018年被提出以来，“pre-train+fine-tune”便成为了席卷整个NLP领域的学习范式。然而，自GPT-3开始，一种新的范式引起了大家的关注并越来越流行：prompt-based learning。<br>prompt-learning生成插槽，对下游任务进行重构，然后进行answer search、answer mapping，对[Z]槽位进行预测，选取得分最高的token z 作为输出即可，然后将z映射为最终输出y。<br>相比“pre-train+fine-tune”的范式，“prompt-based learning”有什么显著的优势？</p><ul><li><p>从应用场景看，可以解决zero-shot问题</p></li><li><p>从使用成本来看，由于后者可以不对pre-trained LM做fine-tune，因此使用起来成本更低。</p></li></ul><p>prompt-based learning，给了我们什么样的启示？</p><ul><li>pre-train是必要的，但，fine-tune未必。换言之，fine-tune或许不是利用pre-trained LM 的唯一方式，更不是最有效的方式。</li></ul><p>如果包含了额外的prompt params，那么这种形式的“primpt-based learning”和”pre-train+fine-tune”的范式有什么区别？</p><ul><li>表象上来看，他俩确实区别不大，无非是起到“Adapter”作用的参数所处的位置不同。但是本质上，它们是完全不同的。前者的参数是为了让下游任务向预训练模型适配，后者的参数是为了让预训练模型向下游任务适配，这不同的出发点很可能导致了训练难度的不同，继而导致最终的效果不同。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Machine Learining </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git 常见套路</title>
      <link href="/2022/04/15/git-%E5%B8%B8%E8%A7%81%E5%A5%97%E8%B7%AF/"/>
      <url>/2022/04/15/git-%E5%B8%B8%E8%A7%81%E5%A5%97%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>本文介绍git常见操作，仅仅设计四个命令：<code>add</code>，<code>commit</code>，<code>reset</code>，<code>checkout</code>.</p><span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在进行git操作前，一定要明白git的三个【分区】是什么，否则的话肯定没办法真正理解Git的原理。</p><p>Git的三个分区分别是：<code>working directory</code> ，<code>stage/index area</code> ，<code>commit history</code>。</p><p>working directory是工作目录，也就是我们肉眼能看到的文件。在执行git add相关相关命令后，就会把work dir中的修改添加到暂存区stage area（或者叫index area）中。</p><p>当stage中存在修改时，我们使用git commit相关命令之后，就会把stage中的额修改保存到提交历史中，也就是HEAD指针指向的位置。</p><p>任何修改只要进入commit history，基本可以认为永远不会丢失了。每个commit都有唯一的hash值，我们经常说的HEAD或者master分支，都可以理解为一个只想某个commit的指针。</p><p>work dir和stage区域的状态，可以通过命令git status来查看，history区域的提交历史可以通过git log来查看。</p><h2 id="本地Git极简教程"><a href="#本地Git极简教程" class="headerlink" title="本地Git极简教程"></a>本地Git极简教程</h2><h3 id="需求一，如何把work-dir中的修改加入stage。"><a href="#需求一，如何把work-dir中的修改加入stage。" class="headerlink" title="需求一，如何把work dir中的修改加入stage。"></a>需求一，如何把work dir中的修改加入stage。</h3><p>使用git add相关命令就行了。顺便一提，add有个别名叫做stage，也就是git stage和git add命令是完全一样的。</p><h3 id="需求二，如何把stage中的修改还原到work-dir中。"><a href="#需求二，如何把stage中的修改还原到work-dir中。" class="headerlink" title="需求二，如何把stage中的修改还原到work dir中。"></a>需求二，如何把stage中的修改还原到work dir中。</h3><p>使用checkout命令，比如修改了a.txt，现在想要还原成原来的文件，使用<code>git checkout a.txt</code> ，那么就能还原成stage中的状态。</p><p>如果需要还原全部文件，可以用点（.）通配符。</p><p>work dir中的修改会被stage覆盖，无法恢复，所以使用该命令是需要确定work dir中的修改可以抛弃。</p><h3 id="需求三，将stage区的文件添加到history区。"><a href="#需求三，将stage区的文件添加到history区。" class="headerlink" title="需求三，将stage区的文件添加到history区。"></a>需求三，将stage区的文件添加到history区。</h3><p>使用<code>git commmit -m ‘一些描述’</code></p><p>如果commit完之后，发现一些错别字需要修改，又不想为改几个错别字而新开一个commit到history区，那么可以用 <code>git commit --amend</code> 这样就是把错别字的修改和之前的哪个commit中的修改合并，作为一个commit提交到history区。</p><h3 id="需求四，将history区的文件还原到stage区。"><a href="#需求四，将history区的文件还原到stage区。" class="headerlink" title="需求四，将history区的文件还原到stage区。"></a>需求四，将history区的文件还原到stage区。</h3><p>如果修改了一个文件，使用了git add . ，然后发现这个文件还需要求改，不想commit，想从stage中撤销，那么可以使用<code>git reset</code>命令：<code>git reset a.txt</code></p><p>这样就可以把a.txt文件从stage区移除，这时候进行commit操作就不会一起提交到history区了。上面的这个命令是一个简写，实际上reset命令的完整写法如下： <code>git reset --mixed HEAD a.txt</code> ，其中，mixed是一个模式（mode）参数，如果reset省略这个选项的话默认是mixed模式，HEAD指定了一个历史提交的hash值，a.txt指定了一个文件或者多个文件。</p><p>该命令的自然语言描述是：不改变work dir中的任何数据，将stage区域中的a.txt文件还原成HEAD指向的commit history中的样子。就相当于把对a.txt的修改从stage区撤销，但依然保存在work dir中，变为unstage的状态。</p><p>不会改变work dir中的数据，会改变stage区的数据，所以应确保stage中被改动的数据是可以抛弃的。</p><h3 id="需求五，将work-dir的修改提交到history区。"><a href="#需求五，将work-dir的修改提交到history区。" class="headerlink" title="需求五，将work dir的修改提交到history区。"></a>需求五，将work dir的修改提交到history区。</h3><p>先git add 然后 git commit就行了，或者一个快捷方法是使用命令 git commit -a。</p><h3 id="需求六，将history区里的历史提交还原到work-dir中。"><a href="#需求六，将history区里的历史提交还原到work-dir中。" class="headerlink" title="需求六，将history区里的历史提交还原到work dir中。"></a>需求六，将history区里的历史提交还原到work dir中。</h3><p>依然是使用checkout命令，但和之前的使用方式有一些不同：</p><p><code>git checkout HEAD .</code></p><p>这样，work dir 和stage中的所有修改都会被撤销，恢复成HEAD指向的哪个history commit。</p><p>注意，这里撤销的也只是修改，新增的文件不会被撤销。</p><p>当然，只要找到任意一个commit的HASH值，checkout命令就可以将文件恢复成任一个history commit中的样子。</p><p><code>git checkout 2bdf04a some_test.go</code></p><p>这个操作会将指定文件在work dir的数据恢复成commit的样子，且会删除该文件在stage中的数据，都无法恢复。</p><h2 id="三、其他技巧"><a href="#三、其他技巧" class="headerlink" title="三、其他技巧"></a>三、其他技巧</h2><h3 id="需求一，合并多个commit"><a href="#需求一，合并多个commit" class="headerlink" title="需求一，合并多个commit"></a>需求一，合并多个commit</h3><p>比如说我本地从17bd20c到HEAD有多个commit，但我希望把他们合并成一个commit推到远程仓库，这时候就可以使用reset命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git reset 17bd20c</span><br><span class="line">git add .</span><br><span class="line">git commit -m &#x27;&#x27;</span><br></pre></td></tr></table></figure><p>相当于把HEAD已到了17bd20c这个commit，而且不会修改work dir中的数据，只要add再commit，就相当于把中间的多个commit合并到一个了。</p><h3 id="需求二，由于HEAD指针的回退，导致有的commit在git-log命令中无法看到，怎么得到它们的Hash值呢？"><a href="#需求二，由于HEAD指针的回退，导致有的commit在git-log命令中无法看到，怎么得到它们的Hash值呢？" class="headerlink" title="需求二，由于HEAD指针的回退，导致有的commit在git log命令中无法看到，怎么得到它们的Hash值呢？"></a>需求二，由于HEAD指针的回退，导致有的commit在git log命令中无法看到，怎么得到它们的Hash值呢？</h3><p>只要不乱动本地的.git文件夹，任何修改只要提交到commit history中，都永远不会丢失。看不到某些commit只是因为他们不是我们当前HEAD位置的历史提交，我们能可以使用如下命令查看操作记录：</p><p><code>git reflog</code></p><p>比如reset，checkout等等关键操作都会在这里留下记录，所有commit的Hash值都能在这里找到。</p><h3 id="需求三，怎么解决冲突"><a href="#需求三，怎么解决冲突" class="headerlink" title="需求三，怎么解决冲突"></a>需求三，怎么解决冲突</h3><p>比较流行的代码编辑器或者IDE都会集成方便的可视化Git工具，至于解决冲突，可视化的表现方式比在命令行里git diff清晰多了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git 常见套路</title>
      <link href="/2022/04/15/git%E6%9B%B4%E6%96%B0%E6%9C%AC%E5%9C%B0%E4%BB%A3%E7%A0%81/"/>
      <url>/2022/04/15/git%E6%9B%B4%E6%96%B0%E6%9C%AC%E5%9C%B0%E4%BB%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="git更新本地代码"><a href="#git更新本地代码" class="headerlink" title="git更新本地代码"></a>git更新本地代码</h1><h2 id="1-本地代码未修改，只有master分支，直接更新"><a href="#1-本地代码未修改，只有master分支，直接更新" class="headerlink" title="1.本地代码未修改，只有master分支，直接更新"></a>1.本地代码未修改，只有master分支，直接更新</h2><p>git pull</p><p>前提是本地的代码没更改过。比如，你提交了代码到github后，随后别人也提交代码到github，然后你需要更新别人提交的代码到你本地，就可以直接使用该命令。假如你提交代码后再修改过本地的代码，就会产生冲突，直接使用该命令会失败。</p><h2 id="2-本地代码有修改，多分支。"><a href="#2-本地代码有修改，多分支。" class="headerlink" title="2.本地代码有修改，多分支。"></a>2.本地代码有修改，多分支。</h2><p>&#x2F;&#x2F;切换到master分支</p><p>git checkout master</p><p>&#x2F;&#x2F;更新master分支</p><p>git pull</p><p>&#x2F;&#x2F;切换到自己的分支isso</p><p>git checkout isso</p><p>&#x2F;&#x2F;把master分支合并到自己分支</p><p>git merge master</p><h2 id="3-本地代码有修改，只有master分支，直接覆盖本地代码。"><a href="#3-本地代码有修改，只有master分支，直接覆盖本地代码。" class="headerlink" title="3.本地代码有修改，只有master分支，直接覆盖本地代码。"></a>3.本地代码有修改，只有master分支，直接覆盖本地代码。</h2><p>&#x2F;&#x2F;重置索引和工作目录</p><p>git reset –hard</p><p>&#x2F;&#x2F;更新代码</p><p>git pull</p><h2 id="4-本地代码有修改，直接覆盖远程仓库代码"><a href="#4-本地代码有修改，直接覆盖远程仓库代码" class="headerlink" title="4.本地代码有修改，直接覆盖远程仓库代码"></a>4.本地代码有修改，直接覆盖远程仓库代码</h2><p>&#x2F;&#x2F;覆盖isso分支</p><p>git push –force origin isso</p><p>&#x2F;&#x2F;覆盖主分支</p><p>git push –force origin master</p>]]></content>
      
      
      <categories>
          
          <category> tips </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++ unordered_set</title>
      <link href="/2022/04/14/C++unordered-set/"/>
      <url>/2022/04/14/C++unordered-set/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="C-std-unordered-set用法与范例"><a href="#C-std-unordered-set用法与范例" class="headerlink" title="C++ std::unordered_set用法与范例"></a>C++ std::unordered_set用法与范例</h1><p>unordered_set是一种关联式容器，里面的元素是唯一的，并且是无排序容器，里面的值不可修改，但是可以插入或删除元素。</p><p>unordered_set和set不同之处是：set是红黑树操作，红黑树具有排序功能。unordered_set是哈希表（hash table）操作的，插入和查询的时间复杂度很低，为常数级别，相对代价是消耗较多的空间，无自动排序功能。</p><p>需要引入头文件：<code>#include&lt;unordered_set&gt;</code></p><h2 id="unordered-set-初始化用法"><a href="#unordered-set-初始化用法" class="headerlink" title="unordered_set 初始化用法"></a>unordered_set 初始化用法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::unordered_set&lt;<span class="type">int</span>&gt; myyunordered_set&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure><p>从c-style阵列来初始化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">std::unordered_set&lt;<span class="type">int</span>&gt;<span class="built_in">myunordered_set</span>(arr,arr+<span class="number">5</span>);</span><br></pre></td></tr></table></figure><h2 id="unordered-set插入元素"><a href="#unordered-set插入元素" class="headerlink" title="unordered_set插入元素"></a>unordered_set插入元素</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myunordered_set.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h2 id="遍历unordered-sort容器"><a href="#遍历unordered-sort容器" class="headerlink" title="遍历unordered_sort容器"></a>遍历unordered_sort容器</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp;s : myunordered_set)&#123;</span><br><span class="line">std::cout&lt;&lt;s&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以使用迭代器的方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (std::unordered_set&lt;<span class="type">int</span>&gt;::iterator it = myunordered_set.<span class="built_in">begin</span>(); it != myunordered_set.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="unordered-set删除指定元素"><a href="#unordered-set删除指定元素" class="headerlink" title="unordered_set删除指定元素"></a>unordered_set删除指定元素</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myunordered_set.<span class="built_in">erase</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>如果删除了不存在的元素，上述代码返回值为0；否则返回值为1。</p><h2 id="清空unordered-set元素"><a href="#清空unordered-set元素" class="headerlink" title="清空unordered_set元素"></a>清空unordered_set元素</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myunordered_set.<span class="built_in">clear</span>();</span><br></pre></td></tr></table></figure><h2 id="判断unordered-set中元素是否存在"><a href="#判断unordered-set中元素是否存在" class="headerlink" title="判断unordered_set中元素是否存在"></a>判断unordered_set中元素是否存在</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myunordered_set.<span class="built_in">count</span>(<span class="number">4</span>);</span><br></pre></td></tr></table></figure><h2 id="判断unordered-set是否为空"><a href="#判断unordered-set是否为空" class="headerlink" title="判断unordered_set是否为空"></a>判断unordered_set是否为空</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myunordered_set.<span class="built_in">empty</span>();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> C++STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++ Set</title>
      <link href="/2022/04/14/C++Set/"/>
      <url>/2022/04/14/C++Set/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="C-std-set用法与范例"><a href="#C-std-set用法与范例" class="headerlink" title="C++ std::set用法与范例"></a>C++ std::set用法与范例</h1><p>set是一个关联式容器，里面的元素是唯一的，而且是有排序的容器。set容器里面的元素的值是不可修改的，但set容器可以插入或删除元素。set通常是用红黑树（red-black tree）操作的。</p><p>要使用set容器，需要引入头文件<code>&lt;set&gt;</code></p><span id="more"></span><p>c++初始化用法：</p><p><code>std::set&lt;int&gt; myset&#123;1,2,3,4,5&#125;;</code></p><p>从c-style阵列来初始化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="function">std::set&lt;<span class="type">int</span>&gt; <span class="title">mytest</span><span class="params">(arr,arr+<span class="number">5</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>set中插入元素：</p><p><code>myset.insert(1)</code></p><p>由于set容器中没有at()成员函数，也没有operator[]，set无法单纯地随机读取某元素。但能通过iterator来读取元素。</p><p>下面先介绍使用range-based for loop来遍历set容器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">std-set.cpp<span class="comment">// g++ std-set.cpp -o a.out -std=c++11</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; myset = &#123;<span class="number">3</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    myset.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line">    myset.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line">    myset.<span class="built_in">insert</span>(<span class="number">4</span>);</span><br><span class="line">    myset.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line">    myset.<span class="built_in">insert</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;s : myset) &#123;</span><br><span class="line">        std::cout &lt;&lt; s &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：1 2 3 4 5</p><p>由此可见元素是从小到大排序的，所以set容器在插入元素的同时会根据元素来进行排序，并且没有元素重复。</p><p>也可以使用迭代器的方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (std::set&lt;<span class="type">int</span>&gt;::iterator it = myset.<span class="built_in">begin</span>(); it != myset.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="comment">// for (auto it = myset.begin(); it != myset.end(); it++) &#123;</span></span><br><span class="line">    std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure><p>（如果用rbegin()和rend()，就是反向迭代器，从大到小输出）</p><p>set中删除指定元素：<code>erase()</code></p><p><code>myset.erase(2);</code></p><p>这个函数有返回值，即是删除的元素的个数。如果要删除的元素在set中不存在，那么返回值就是0，并不会产生错误。</p><p>set中清空容器：<code>clear()</code></p><p><code>myset.clear()</code></p><p>set中判断元素是否存在：</p><p>第一种方法是用<code>count()</code>成员函数，如果存在则返回1，不存在则返回0。</p><p>第二种方法是使用<code>find()</code>成员函数，如果又找到就返回该特定元素的iterator，否则返回<a href="https://en.cppreference.com/w/cpp/container/set/end">past-the-end(end()) iterator</a>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std::set&lt;<span class="type">int</span>&gt; myset = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> search = myset.<span class="built_in">find</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span> (search != myset.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Found &quot;</span> &lt;&lt; *search &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// Found 2</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Not found\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>set中判断容器是否为空：<code>empty()</code></p><p>返回值布尔类型</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> C++STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计网实验（网络版）</title>
      <link href="/2022/04/14/%E8%AE%A1%E7%BD%91%E5%AE%9E%E9%AA%8C%EF%BC%88%E7%BD%91%E7%BB%9C%E7%89%88%EF%BC%89/"/>
      <url>/2022/04/14/%E8%AE%A1%E7%BD%91%E5%AE%9E%E9%AA%8C%EF%BC%88%E7%BD%91%E7%BB%9C%E7%89%88%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="计网实验（网络版）"><a href="#计网实验（网络版）" class="headerlink" title="计网实验（网络版）"></a>计网实验（网络版）</h1><h2 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h2><p>1）打开packet tracer，在里面新建路由器（routers）和pc（End Devices），用console线（蓝色）连接路由器console口和pc的串口（com1,i.e. RS232)，即可完成连接。</p><p>2）双击pc，打开terminal，波特率选择9600，其余默认，然后就能进入用户模式。</p><p>3）用户模式：router&gt;</p><p>​  特权模式：router#</p><p>​  全局配置模式：router(config)#</p><p>要进入特权模式，输入enable；要进入全局配置模式，在特权模式下输入configure terminal；在全局配置模式中可以选择端口；按Ctrl+Z可以退出全局配置模式。</p><p>4）编辑路由器登陆信息：</p><p>Router(config)#banner motd “Welcomee to NJU”</p><p>5）配置端口描述：</p><p>Router(config)#int fa 0&#x2F;0</p><p>Router(config-if)#description To ISP</p><p>6）关闭域名解析功能：</p><p>Router(config)#no ip domain-lookup</p><p>7）将实验端口恢复默认设置：</p><p>Router(config)#default interface f0&#x2F;0</p><p>8）设置系统时间：</p><p>Router#clock set 08:00:00 1jan 2016 </p><p>9)给路由器命名：</p><p>进入全局配置模式，用hostname<name>命令来设定路由器名称</p><p>10）给端口配IP地址：在全局配置模式下，进入各端口配置模式配置IP地址</p><p>​1.以太网口配置</p><p>​Router(config)# int f0&#x2F;0</p><p>​Router(config-if) #ip address <ip address><subnet mask></p><p>​Router(config-if)# no shutdown</p><p>​2.串行线：根据串口是DTE还是DCE来选择（略）</p><p>11）Ping命令</p><p>Router#ping <ip address></p><p>12）设置Telnet</p><p>能进行Telnet的前提：主机能ping通路由器；路由器设置了telnet密码；路由器允许通过telnet登录；如果需要进入特权模式，还需要配置enable密码。</p><p>配置命令：Router#telnet <ip address></p><p>​   Router#telnet <hostname></p><p>启动telnet：</p><p>Router#config t</p><p>Router(config)#line vty 0 4 &#x2F;&#x2F;同时允许0-4共5个连接</p><p>Router(config-line)# login</p><p>Router(config-line)#password cisco &#x2F;&#x2F;设置密码为cisco</p><p>设置enable密码：</p><p>Router(config)#enable password cisco</p><p>Router(config-line)# password cisco</p><h2 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h2><p>1）连接方法同路由器</p><p>2）将hostname改为nju</p><p>先enable进入特权模式，在con t 进入全局配置模式（命令在不引起歧义的情况下可以省略），然后</p><p>Switch(config)#hostname nju</p><p>3）设置特权密码和vty线路密码</p><p>nju(config)#enable password ccna</p><p>nju(config)#line vty 0 4</p><p>nju(config-line)#passwoed ccnp</p><p>4）设置管理ip地址</p><p>nju(config)#inter vlan1</p><p>nju(config-if)#ip add 192.168.1.1 255.255.255.0</p><p>nju(config-if)#no shut</p><p>nju(config-if)#exit</p><p>nju(config)#ip default0gateway 192.168.1.100</p><h2 id="静态路由和简单组网"><a href="#静态路由和简单组网" class="headerlink" title="静态路由和简单组网"></a>静态路由和简单组网</h2><p>1）完成拓扑图，其中pc和路由器通过fa口连接（可以不连），路由器和路由器之间通过s串口连接，pc连接console。</p><p>路由器和路由器之间的线选择Serial DTE（最后一个），连接方向是从DTE路由器连接到DCE路由器（方向反了就ping不通了）</p><p>2）按照实验手册配置ip地址,要设置clock rate</p><p>3）现在可以ping通相连的路由器</p><p>4）为了连接相邻路由器的下一跳地址，需要配置路由表。格式为：<code>ip route &lt;目标网段&gt;&lt;子网掩码&gt;&lt;下一跳路由器地址（IP地址）&gt;</code></p><p>5）现在可以ping通下一跳路由器</p><p>6）可以删除静态路由配置，然后配置默认路由</p><p>注）如果PC要连接路由器，需要配置一个不同的IP地址，同时，要配置网关gateway，设置为与路由器相连的端口的IP地址。配置正确即可ping通其他所有。（PC和路由器连接要用交叉线）</p><p>再注）即使IP和网关都设置好了，依然是ping不通的。因为中间路由器没有10网段和40网段的路由表，因此消息在传到中间路由器的时候就会因为找不到目的地址而被丢弃。（左右两边的因为手动配置了路由表，所以路由表是完整的）</p><h2 id="动态RIP"><a href="#动态RIP" class="headerlink" title="动态RIP"></a>动态RIP</h2><p>根据实验手册配置。</p><p>在配置RIP之后，路由器每30秒就会和相邻路由器交换路由表，从而实现网络的互通。</p><h2 id="配置单域OSPF"><a href="#配置单域OSPF" class="headerlink" title="配置单域OSPF"></a>配置单域OSPF</h2><p>1）配置IP地址（手册上没有）</p><p>2）配置回环接口</p><p>3）配置OSPF（DR&#x2F;BDR和手册不一样？）</p><p>4）设置计时器、安全等等</p><h2 id="VLAN间路由"><a href="#VLAN间路由" class="headerlink" title="VLAN间路由"></a>VLAN间路由</h2><p>1）按照拓扑连接</p><p>2）在设置encapsulation dot1q时报错，这是因为encapsulation dot1q是不用配置的，也就是说它只支持dot1q协议。如果遇到一个支持sli和dot1q两个协议的交换机时才用。</p><p>3）划分VLAN，为10和20（两个交换机都要配置两个，如果没有配置的话会自动配置）</p><p>4）将交换机的以太网口划分不同的VLAN</p><p>5）将交换机与路由器连接的接口设置为Trunk接口</p><p>6）将Router设置Vlan地址</p><p>7）PC设置IP地址和网关，发现不同网段也能ping通（等几秒钟，设置需要时间）</p><h2 id="NAT网络地址转换"><a href="#NAT网络地址转换" class="headerlink" title="NAT网络地址转换"></a>NAT网络地址转换</h2><p>（配置端口地址一定要no shut，不然的话会配不上。。。）</p><p>1）按照拓扑连接路由</p><p>2）配置端口的ip地址</p><p>3）配置clock rate（重要，不然ping不通）</p><p>4）在R2上完成静态NAT的配置，在R1上配置静态路由</p><p>5）现在R1应该可以ping通R3</p><p>6）设置动态NAT</p><p>7）将原来的NAT条目删除，有一条命令修改为<code>ip nat pool nju 200.1.1.253 200.1.1.254 netmask 255.255.255.0</code></p><p>8）现在依然能ping通（辅助地址的实验不做了）</p><p>9）配置PAT</p><p>10）按照实验手册，现在产生随机端口号</p><p><a href="https://blog.51cto.com/pizazzdog/112131">https://blog.51cto.com/pizazzdog/112131</a> nat命令</p><h2 id="ACL实验"><a href="#ACL实验" class="headerlink" title="ACL实验"></a>ACL实验</h2><p>1）配置R1、R2串口ip，配置时钟</p><p>2）发现能ping通</p><p>3）创建ACL</p><p>Router(config)# access-list access-list-number { permit | deny } protocol source source-wildcard [operator port] destination destination-wildcard [ operator port ] [ established ] [log]<br>4）将ACL绑定到指定端口</p><p>Router(config-if)# ip access-group access-list-number { in | out }</p><p>注意<br>access-list-number 要选择在100以上的数字<br>in 表示入站访问控制<br>out表示出站访问控制<br>“no access-list access-list-number” 命令删除指定号码的ACL<br>“no ip access-group access-list-number” 命令在特定接口禁用ACL<br>“sh access-lists”可以查看某台路由上ACL配置情况<br>5）照着实验验证，成功。</p><p>6）前置知识：</p><p><code>line vty 0 4</code>：vty指的是Virtual teletype，是一个虚拟端口，用来获得Telnet或者SSH连接。0 4代表允许5条虚拟连接。（tcp）</p><p>实验中，使用扩展acl，发现telnet无法到达。</p><p>7）实验中，使用标准ACL，发现telnet被拒绝。</p><h2 id="实验拓扑备选"><a href="#实验拓扑备选" class="headerlink" title="实验拓扑备选"></a>实验拓扑备选</h2><p><a href="https://blog.51cto.com/microdq/1968662">https://blog.51cto.com/microdq/1968662</a></p><p><a href="https://blog.51cto.com/hjtyqs/346965">https://blog.51cto.com/hjtyqs/346965</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ STL Stack Queue Deque PriorityQueue Pair</title>
      <link href="/2022/04/14/C++STL/"/>
      <url>/2022/04/14/C++STL/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="C-Stack-Queue-Deque-PriorityQueue-Pair-（Vector-Set略）"><a href="#C-Stack-Queue-Deque-PriorityQueue-Pair-（Vector-Set略）" class="headerlink" title="C++ Stack Queue Deque PriorityQueue Pair （Vector Set略）"></a>C++ Stack Queue Deque PriorityQueue Pair （Vector Set略）</h1><h2 id="Stack"><a href="#Stack" class="headerlink" title="Stack:"></a>Stack:</h2><p>头文件：</p><p><code>#include&lt;stack&gt;</code></p><p>简介：</p><p>stack（栈），是一种后进先出（Last-In-First-Out，LIFO）的线性结构，支持两种操作：push和pop。</p><p>push操作是把一个元素加入栈中，pop操作是把最晚进入的元素删除。</p><span id="more"></span><p>常用的member function：</p><p>empty()：空则返回true。</p><p>size()：返回当前stack中有多少元素。</p><p>push()：在stack中加入一个元素。注意，被加入的元素会复制一份，而非Reference。</p><p>pop()：移除顶层元素，如果为空则发生Runtime Error。</p><p>top()：返回最上层的reference。如果为空，则发生Runtime Error。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line">stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">st.<span class="built_in">push</span>(i);</span><br></pre></td></tr></table></figure><h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue:"></a>Queue:</h2><p>头文件：</p><p><code>#include&lt;queue&gt;</code></p><p>简介：</p><p>Queue（队列），是一种先进先出（FIFO）的线性结构，虽然习惯上称为enqueue和dequeue，但是在STL中名称为push和pop。</p><p>常用的member function：</p><p>empty()：空则返回true。</p><p>size()：返回当前queue中有多少元素。</p><p>push()：在queue中加入一个元素。注意，被加入的元素会复制一份，而非Reference。</p><p>pop()：移除最前端元素，如果为空则发生Runtime Error。</p><p>front()：返回最前端的reference。如果为空，则发生Runtime Error。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">que.<span class="built_in">push</span>(i);</span><br></pre></td></tr></table></figure><h2 id="Deque："><a href="#Deque：" class="headerlink" title="Deque："></a>Deque：</h2><p>头文件：</p><p><code>#include&lt;deque&gt;</code></p><p>简介：</p><p>Deque（双端队列，Double-ended queue，念作“deck”，勿与dequeue混淆），线性结构，支持四种基本操作：push，inject，pop，eject。</p><p>Push操作是把一个元素加入deque的前端，inject操作是把一个元素加入deque的猴拳；pop操作是把deque最前端的元素移除，eject操作是把的却最后全的元素移除。</p><p>注：我们都还是喜欢将push_front、push_back、pop_front、pop_back，并且在STL的名称亦是如此。</p><p>常用的member function：</p><p>empty()：空则返回true。</p><p>size()：返回当前deque中有多少元素。</p><p>push_front()：在deque前端中加入一个元素。注意，被加入的元素会复制一份，而非Reference。</p><p>push_back()：在deque后端中加入一个元素。注意，被加入的元素会复制一份，而非Reference。</p><p>pop_front()：移除deque最前端元素，如果为空则发生Runtime Error。</p><p>pop_back()：移除deque最后端元素，如果为空则发生Runtime Error。</p><p>front()：返回最前端的reference。如果为空，则发生Runtime Error。</p><p>back()：返回最后端的reference。如果为空，则发生Runtime Error。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;deque&gt;</span></span></span><br><span class="line">deque&lt;<span class="type">int</span>&gt; de;</span><br><span class="line">de.<span class="built_in">push_back</span>(i);</span><br></pre></td></tr></table></figure><h2 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue:"></a>PriorityQueue:</h2><p>头文件：</p><p><code>#include&lt;queue&gt;</code></p><p>简介：</p><p>PriorityQueue（优先队列），是一种按照优先程度来排列的结构，支持两种操作：push和pop。</p><p>push是把一个元素加入队列中，pop是把优先顺序最高的元素移除。</p><p>常用的member function：</p><p>empty()：空则返回true。</p><p>size()：返回当前有多少元素。</p><p>push()：在queue中加入一个元素。注意，被加入的元素会复制一份，而非Reference。</p><p>pop()：移除优先顺序最高的元素，如果为空则发生Runtime Error。</p><p>front()：返回优先顺序最高元素的constant reference。如果为空，则发生Runtime Error。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>&gt; pq;</span><br><span class="line">pq.<span class="built_in">push</span>(i);</span><br></pre></td></tr></table></figure><ul><li>priority_queue<T> pq; 预设由大排到小</li><li>priority_queue&lt;T, **vector**<T>, <strong>greater</strong><T> &gt; pq; 改成由小排到大</li><li>priority_queue&lt;T, **vector**<T>, <strong>cmp</strong>&gt; pq; 自定义 cmp 排序</li></ul><p>自定义cmp：使用struct（overload operator()）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span>&#123;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(node a,node b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.x&lt;b.x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Pair"><a href="#Pair" class="headerlink" title="Pair:"></a>Pair:</h2><p>头文件：</p><p><code>#include&lt;utility&gt;</code></p><p>将两个元素绑在一起，第一个元素为first，第二个元素为second。</p><h2 id="String："><a href="#String：" class="headerlink" title="String："></a>String：</h2><p>C风格字符串复制：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">strcpy</span><span class="params">( <span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src )</span></span>;</span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">strncpy</span><span class="params">( <span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">size_t</span> count )</span></span>;</span><br></pre></td></tr></table></figure><h2 id="List："><a href="#List：" class="headerlink" title="List："></a>List：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">list&lt;<span class="type">int</span>&gt; myList = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">list&lt;<span class="type">int</span>&gt;<span class="built_in">myList</span>(<span class="number">5</span>,<span class="number">10</span>);<span class="comment">//初始化为5个10</span></span><br><span class="line">myList.<span class="built_in">push_back</span>(<span class="number">4</span>);<span class="comment">//最后插入</span></span><br><span class="line">mylist.<span class="built_in">push_front</span>(<span class="number">0</span>);<span class="comment">//最前插入</span></span><br><span class="line">mylist.<span class="built_in">pop_back</span>();<span class="comment">//最后删除</span></span><br><span class="line">mylist.<span class="built_in">pop_front</span>();<span class="comment">//最前删除</span></span><br><span class="line">mylist.<span class="built_in">front</span>();<span class="comment">//获得求前面的元素</span></span><br><span class="line">mylist.<span class="built_in">back</span>();<span class="comment">//获得最后面的元素</span></span><br><span class="line"><span class="built_in">reverse</span>();<span class="comment">//反转</span></span><br><span class="line"><span class="function">iterator <span class="title">emplace</span><span class="params">(iterator pos,value_type val)</span></span>;<span class="comment">//在指定位置插入，并且链表的大小增加1</span></span><br><span class="line"><span class="comment">//等等</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure><h2 id="find"><a href="#find" class="headerlink" title="find()"></a>find()</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; myvector&#123; <span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span> &#125;;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt;::iterator it;</span><br><span class="line">it = <span class="built_in">find</span>(myvector.<span class="built_in">begin</span>(), myvector.<span class="built_in">end</span>(), <span class="number">30</span>);</span><br><span class="line"><span class="keyword">if</span> (it != myvector.<span class="built_in">end</span>())</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;查找成功：&quot;</span> &lt;&lt; *it;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;查找失败&quot;</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> C++STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ sort</title>
      <link href="/2022/04/14/C++sort/"/>
      <url>/2022/04/14/C++sort/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">std::<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>());</span><br><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>&#125;</span><br><span class="line">std::<span class="built_in">sort</span>(a,a+<span class="number">6</span>);</span><br></pre></td></tr></table></figure><p>加入sort函数样板：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">less&lt;Type&gt;</span><br><span class="line"></span><br><span class="line">less_equal&lt;Type&gt;</span><br><span class="line"></span><br><span class="line">greater&lt;Type&gt;</span><br><span class="line"></span><br><span class="line">greater_equal&lt;Type&gt;</span><br><span class="line"></span><br><span class="line">equal_to&lt;Type&gt;</span><br><span class="line"></span><br><span class="line">not_equal_to&lt;Type&gt;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">9</span>&#125;;</span><br><span class="line">std::<span class="built_in">sort</span>(arr, arr+<span class="number">10</span>, std::<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), mycompare);</span><br></pre></td></tr></table></figure><p>配合lambda匿名函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::sort(v.begin(), v.end(), [](int a, int b)&#123;</span><br><span class="line">    return a &lt; b; // 升序排列</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> C++STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring boot</title>
      <link href="/2022/04/12/Springboot/"/>
      <url>/2022/04/12/Springboot/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Springboot"><a href="#Springboot" class="headerlink" title="Springboot"></a>Springboot</h1><h2 id="创建第一个springboot项目"><a href="#创建第一个springboot项目" class="headerlink" title="创建第一个springboot项目"></a>创建第一个springboot项目</h2><p>1.File-&gt;创建maven-&gt;导入父工程，添加web依赖-&gt;在Java文件夹中创建class（有很多层文件夹）-&gt;添加注解@SpringBootApplication,创建main函数-&gt;创建controller，添加注解@Controller，添加注解@RequestMapping，添加注解@ResponseBody，可以和Controller合二为一，变为@RestController-&gt;run</p><p>2.修改端口：在resources中创建application.properties，在其中添加server.port&#x3D;8888</p><ol start="3"><li></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 后端学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++Vector浅析</title>
      <link href="/2022/04/11/C++vector%E6%B5%85%E6%9E%90/"/>
      <url>/2022/04/11/C++vector%E6%B5%85%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="C-Vector浅析"><a href="#C-Vector浅析" class="headerlink" title="C++Vector浅析"></a>C++Vector浅析</h1><h2 id="一、什么是vector？"><a href="#一、什么是vector？" class="headerlink" title="一、什么是vector？"></a>一、什么是vector？</h2><p>vector就是一个封装了动态大小数组的顺序容器。和任意其他类型容器一样，它能够存放各种类型的对象。可以简单认为，是一个能够存放任意类型的动态数组。</p><h2 id="二、容器特性"><a href="#二、容器特性" class="headerlink" title="二、容器特性"></a>二、容器特性</h2><h3 id="1-顺序排列"><a href="#1-顺序排列" class="headerlink" title="1.顺序排列"></a>1.顺序排列</h3><h3 id="2-动态数组"><a href="#2-动态数组" class="headerlink" title="2.动态数组"></a>2.动态数组</h3><h3 id="3-能够感知内存分类器的（Allocator-aware）"><a href="#3-能够感知内存分类器的（Allocator-aware）" class="headerlink" title="3.能够感知内存分类器的（Allocator-aware）"></a>3.能够感知内存分类器的（Allocator-aware）</h3><h2 id="三、基本函数实现"><a href="#三、基本函数实现" class="headerlink" title="三、基本函数实现"></a>三、基本函数实现</h2><h3 id="1-构造函数"><a href="#1-构造函数" class="headerlink" title="1.构造函数"></a>1.构造函数</h3><p>创建空vector：vector()</p><p>创建一个vector，元素的个数为nSize：vector(int nSize)</p><p>创建一个vector，元素个数为nSize，且值均为t：vector(int nSize,const t&amp; t)</p><p>复制构造函数：vector(const vector&amp;)</p><p>复制[begin,end)区间内的元素到另一个vector中：vector(begin,end)</p><h3 id="2-增加函数"><a href="#2-增加函数" class="headerlink" title="2.增加函数"></a>2.增加函数</h3><ul><li>void push_back(const T&amp; x):向量尾部增加一个元素X</li><li>iterator insert(iterator it,const T&amp; x):向量中迭代器指向元素前增加一个元素x</li><li>iterator insert(iterator it,int n,const T&amp; x):向量中迭代器指向元素前增加n个相同的元素x</li><li>iterator insert(iterator it,const_iterator first,const_iterator last):向量中迭代器指向元素前插入另一个相同类型向量的[first,last)间的数据</li></ul><h3 id="3-删除函数"><a href="#3-删除函数" class="headerlink" title="3.删除函数"></a>3.删除函数</h3><ul><li>iterator erase(iterator it):删除向量中迭代器指向元素</li><li>iterator erase(iterator first,iterator last):删除向量中[first,last)中元素</li><li>void pop_back():删除向量中最后一个元素</li><li>void clear():清空向量中所有元素</li></ul><h3 id="4-遍历函数"><a href="#4-遍历函数" class="headerlink" title="4.遍历函数"></a>4.遍历函数</h3><ul><li>reference at(int pos):返回pos位置元素的引用</li><li>reference front():返回首元素的引用</li><li>reference back():返回尾元素的引用</li><li>iterator begin():返回向量头指针，指向第一个元素</li><li>iterator end():返回向量尾指针，指向向量最后一个元素的下一个位置</li><li>reverse_iterator rbegin():反向迭代器，指向最后一个元素</li><li>reverse_iterator rend():反向迭代器，指向第一个元素之前的位置</li></ul><h3 id="5-判断函数"><a href="#5-判断函数" class="headerlink" title="5.判断函数"></a>5.判断函数</h3><ul><li>bool empty() const:判断向量是否为空，若为空，则向量中无元素</li></ul><h3 id="6-大小函数"><a href="#6-大小函数" class="headerlink" title="6.大小函数"></a>6.大小函数</h3><ul><li>int size() const:返回向量中元素的个数</li><li>int capacity() const:返回当前向量所能容纳的最大元素值</li><li>int max_size() const:返回最大可允许的vector元素数量值</li></ul><h3 id="7-其他函数"><a href="#7-其他函数" class="headerlink" title="7.其他函数"></a>7.其他函数</h3><ul><li>void swap(vector&amp;):交换两个同类型向量的数据</li><li>void assign(int n,const T&amp; x):设置向量中前n个元素的值为x</li><li>void assign(const_iterator first,const_iterator last):向量中[first,last)中元素设置成当前向量元素</li></ul><h3 id="8-看着清楚"><a href="#8-看着清楚" class="headerlink" title="8.看着清楚"></a>8.看着清楚</h3><blockquote><p>1.push_back 在数组的最后添加一个数据</p><p>2.pop_back 去掉数组的最后一个数据</p><p>3.at 得到编号位置的数据</p><p>4.begin 得到数组头的指针</p><p>5.end 得到数组的最后一个单元+1的指针</p><p>6.front 得到数组头的引用</p><p>7.back 得到数组的最后一个单元的引用</p><p>8.max_size 得到vector最大可以是多大</p><p>9.capacity 当前vector分配的大小</p><p>10.size 当前使用数据的大小</p><p>11.resize 改变当前使用数据的大小，如果它比当前使用的大，者填充默认值</p><p>12.reserve 改变当前vecotr所分配空间的大小</p><p>13.erase 删除指针指向的数据项</p><p>14.clear 清空当前的vector</p><p>15.rbegin 将vector反转后的开始指针返回(其实就是原来的end-1)</p><p>16.rend 将vector反转构的结束指针返回(其实就是原来的begin-1)</p><p>17.empty 判断vector是否为空</p><p>18.swap 与另一个vector交换数据</p></blockquote><h2 id="四、基本用法"><a href="#四、基本用法" class="headerlink" title="四、基本用法"></a>四、基本用法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt; vector&gt; </span><br><span class="line">using namespace std;</span><br></pre></td></tr></table></figure><hr><h2 id="五、简单介绍"><a href="#五、简单介绍" class="headerlink" title="五、简单介绍"></a>五、简单介绍</h2><ol><li>Vector&lt;类型&gt;标识符</li><li>Vector&lt;类型&gt;标识符(最大容量)</li><li>Vector&lt;类型&gt;标识符(最大容量,初始所有值)</li><li>Int i[5]&#x3D;{1,2,3,4,5}<br>Vector&lt;类型&gt;vi(I,i+2);&#x2F;&#x2F;得到i索引值为3以后的值</li><li>Vector&lt; vector&lt; int&gt; &gt;v; 二维向量&#x2F;&#x2F;这里最外的&lt;&gt;要有空格。否则在比较旧的编译器下无法通过</li></ol><p>具体使用见<a href="https://www.runoob.com/w3cnote/cpp-vector-container-analysis.html">https://www.runoob.com/w3cnote/cpp-vector-container-analysis.html</a></p><h2 id="六、求vector或者数组中的最大值"><a href="#六、求vector或者数组中的最大值" class="headerlink" title="六、求vector或者数组中的最大值"></a>六、求vector或者数组中的最大值</h2><p>可以用max_element()和min_element()函数，二者返回的都是迭代器或指针.</p><p>头文件：<code>#include&lt;algorithm&gt;</code></p><p>vector容器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> maxValue = *<span class="built_in">max_element</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>());</span><br><span class="line"><span class="type">int</span> maxPosition = <span class="built_in">max_element</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>())-v.<span class="built_in">begin</span>();</span><br></pre></td></tr></table></figure><p>普通数组：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="comment">//最大值：</span></span><br><span class="line"><span class="type">int</span> maxValue = *<span class="built_in">max_element</span>(a,a+<span class="number">6</span>);</span><br><span class="line"><span class="type">int</span> maxPosition = <span class="built_in">max_element</span>(a,a+<span class="number">6</span>)-a;</span><br></pre></td></tr></table></figure><h2 id="七、在指定位置插入元素"><a href="#七、在指定位置插入元素" class="headerlink" title="七、在指定位置插入元素"></a>七、在指定位置插入元素</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; demo1&#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="comment">//emplace() 每次只能插入一个 int 类型元素</span></span><br><span class="line">    demo1.<span class="built_in">emplace</span>(demo1.<span class="built_in">begin</span>(), <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; demo1.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        cout &lt;&lt; demo1[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以用insert，格式一样，可以插入多个元素。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> C++STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何在hexo上创建一篇文章</title>
      <link href="/2022/04/11/%E5%A6%82%E4%BD%95%E5%9C%A8hexo%E4%B8%8A%E5%88%9B%E5%BB%BA%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2022/04/11/%E5%A6%82%E4%BD%95%E5%9C%A8hexo%E4%B8%8A%E5%88%9B%E5%BB%BA%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="新建文章："><a href="#新建文章：" class="headerlink" title="新建文章："></a>新建文章：</h2><p>使用命令来新建文章：<br><code>hexo new [layout] &lt;title&gt;</code><br>layout是文章的布局，默认为post，可以先不写。<br>title是文章的标题，也是文件的名字，存储在source&#x2F;_posts下。<br>然后再MarkDown编辑器上打开编辑。</p><h2 id="Font-matter设置"><a href="#Font-matter设置" class="headerlink" title="Font-matter设置"></a>Font-matter设置</h2><p>Font-matter是文章最上方分隔的区域，用于指定文章的变量设置。</p><table><thead><tr><th>参数</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td>layout</td><td>布局</td><td>无</td></tr><tr><td>title</td><td>标题</td><td>无</td></tr><tr><td>date</td><td>建立日期</td><td>文件建立日期</td></tr><tr><td>update</td><td>更新日期</td><td>文件更新日期</td></tr><tr><td>comments</td><td>开启文章的评论功能</td><td>true</td></tr><tr><td>tags</td><td>标签</td><td>（不适用于分页）</td></tr><tr><td>categories</td><td>分类</td><td>（不适用于分页）</td></tr><tr><td>permalink</td><td>覆盖文章网址</td><td>无</td></tr></tbody></table><span id="more"></span><p>截断，用于显示更多。</p><p>之后用hexo g &amp; hexo d 就可以啦！</p>]]></content>
      
      
      
        <tags>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/01/01/hello-world/"/>
      <url>/2022/01/01/hello-world/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
